# 第13章、**复合类型：枚举和结构体**

## 13.1 — 程序定义（用户定义）类型介绍

由于基本类型是作为核心 C++ 语言的一部分定义的，因此可以立即使用。例如，如果我们想定义一个类型为`int`或 的变量`double`，我们可以这样做：

```c++
int x; // define variable of fundamental type 'int'
double d; // define variable of fundamental type 'double'
```

对于作为基本类型（包括函数、指针、引用和数组）的简单扩展的复合类型来说也是如此：

```c++
void fcn(int) {}; // define a function of type void()(int)
int* ptr; // define variable of compound type 'pointer to int'
int& ref { x }; // define variable of compound type 'reference to int' (initialized with x)
int arr[5]; // define an array of 5 integers of type int[5] (we'll cover this in a future chapter)
```

这是可行的，因为 C++ 语言已经知道这些类型的类型名称（和符号）的含义——我们不需要提供或导入任何定义。

但是，请考虑类型别名的情况（在课程[10.7 -- 类型定义和类型别名](https://www.learncpp.com/cpp-tutorial/typedefs-and-type-aliases/)中介绍），它允许我们为现有类型定义一个新名称。由于类型别名会在程序中引入新的标识符，因此必须先定义类型别名，然后才能使用：

```c++
#include <iostream>

using length = int; // define a type alias with identifier 'length'

int main()
{
    length x { 5 }; // we can use 'length' here since we defined it above
    std::cout << x << '\n';

    return 0;
}
```

如果我们省略 的定义`length`，编译器将不知道 a`length`是什么，当我们尝试使用该类型定义变量时，它会报错。 的定义`length`不会创建对象 - 它只是告诉编译器 a`length`是什么，以便以后可以使用。

### **什么是用户定义/程序定义类型？**

回到上一章的介绍（[12.1——复合数据类型简介](https://www.learncpp.com/cpp-tutorial/introduction-to-compound-data-types/)），我们介绍了存储分数的挑战，该分数具有概念上相互关联的分子和分母。在那一课中，我们讨论了使用两个单独的整数分别存储分数的分子和分母时遇到的一些挑战。

如果 C++ 有内置分数类型，那就完美了——但事实并非如此。而且还有数百种其他可能有用的类型，但 C++ 没有包括它们，因为不可能预测某人可能需要的一切（更不用说实现和测试这些东西了）。

相反，C++ 以不同的方式解决了这些问题：允许我们创建全新的自定义类型供我们的程序使用！此类类型通常称为**用户定义类型**（尽管我们认为术语**“程序定义类型”**更好——我们将在本课后面讨论两者的区别）。

C++ 有两种不同的复合类型，可用于创建程序定义的类型：

- 枚举类型（包括无范围枚举和有范围枚举）
- 类类型（包括结构、类和联合）。

### **定义程序定义类型**

与类型别名一样，程序定义类型也必须先定义才能使用。程序定义类型的定义称为 类型**定义**。

虽然我们还没有介绍什么是结构体，但这里有一个例子展示了自定义 Fraction 类型的定义和使用该类型的对象的实例：

```c++
// Define a program-defined type named Fraction so the compiler understands what a Fraction is
// (we'll explain what a struct is and how to use them later in this chapter)
// This only defines what a Fraction type looks like, it doesn't create one
struct Fraction
{
	int numerator {};
	int denominator {};
};

// Now we can make use of our Fraction type
int main()
{
	Fraction f { 3, 4 }; // this actually instantiates a Fraction object named f

	return 0;
}
```

在此示例中，我们使用`struct`关键字来定义一个名为 的新程序定义类型`Fraction`（在全局范围内，因此可以在文件的其余部分的任何位置使用）。这不会分配任何内存 - 它只是告诉编译器 是什么样子`Fraction`，因此我们可以稍后分配类型的对象`Fraction`。然后，在 中，我们实例化`Fraction`f（并初始化）一个名为`main()`的变量。

程序定义的类型定义必须以分号结尾。未在类型定义末尾添加分号是程序员常见的错误，并且很难调试，因为编译器可能会在类型定义*后的行上出错。*

**警告**：不要忘记用分号结束类型定义。

我们将在下一课（[13.2--无作用域枚举](https://www.learncpp.com/cpp-tutorial/unscoped-enumerations/)）中展示更多定义和使用程序定义类型的示例，并从[第 13.7 课--结构体、成员和成员选择简介](https://www.learncpp.com/cpp-tutorial/introduction-to-structs-members-and-member-selection/)开始介绍结构体。

### **命名程序定义类型**

按照惯例，程序定义类型的命名以大写字母开头，并且不使用后缀（例如`Fraction`，不是`fraction`，`fraction_t`或`Fraction_t`）。

**最佳实践**：以大写字母开头命名程序定义类型，并且不要使用后缀。

新程序员有时会发现如下的变量定义令人困惑，因为类型名称和变量名很相似：

```c++
Fraction fraction {}; // Instantiates a variable named fraction of type Fraction
```

这与任何其他变量定义没什么不同：类型 ( `Fraction`) 放在第一位（因为 Fraction 是大写的，我们知道它是程序定义的类型），然后是变量名称 ( `fraction`)，然后是可选的初始化程序。因为 C++ 区分大小写，所以这里没有命名冲突！

### **在多文件程序中使用程序定义类型**

每个使用程序定义类型的代码文件在使用之前都需要查看完整的类型定义。前向声明是不够的。这是必需的，以便编译器知道为该类型的对象分配多少内存。

为了将类型定义传播到需要它们的代码文件中，程序定义类型通常在头文件中定义，然后 #include 到需要该类型定义的任何代码文件中。这些头文件通常与程序定义类型同名（例如，名为 Fraction 的程序定义类型将在 Fraction.h 中定义）

**最佳实践**：仅在一个代码文件中使用的程序定义类型应在该代码文件中尽可能靠近第一个使用点进行定义。在多个代码文件中使用的程序定义类型应该在与程序定义类型同名的头文件中定义，然后根据需要将其#include 到每个代码文件中。

下面是一个示例，如果我们将 Fraction 类型移动到头文件（名为 Fraction.h）以便可以将其包含在多个代码文件中，它将是什么样子：

`Fraction.h：`

```c++
#ifndef FRACTION_H
#define FRACTION_H

// Define a new type named Fraction
// This only defines what a Fraction looks like, it doesn't create one
// Note that this is a full definition, not a forward declaration
struct Fraction
{
	int numerator {};
	int denominator {};
};

#endif
```

`Fraction.cpp:`

```c++
#include "Fraction.h" // include our Fraction definition in this code file

// Now we can make use of our Fraction type
int main()
{
	Fraction f{ 3, 4 }; // this actually creates a Fraction object named f

	return 0;
}
```

### **类型定义部分不受单一定义规则 (ODR) 的约束**

在课程[2.7 — 前向声明和定义](https://www.learncpp.com/cpp-tutorial/forward-declarations/#ODR)中，我们讨论了一次定义规则如何要求每个函数和全局变量在每个程序中只有一个定义。要在不包含定义的文件中使用给定函数或全局变量，我们需要前向声明（我们通常通过头文件传播）。这是可行的，因为声明足以满足编译器对函数和非 constexpr 变量的要求，然后链接器可以将所有内容连接起来。

但是，以类似的方式使用前向声明对类型不起作用，因为编译器通常需要查看完整定义才能使用给定类型。我们必须能够将完整类型定义传播到需要它的每个代码文件。

为了实现这一点，类型部分不受单一定义规则的约束：允许在多个代码文件中定义给定类型。

您已经使用了此功能（可能没有意识到）：如果您的程序有两个代码文件`#include <iostream>`，那么您将所有输入/输出类型定义导入到这两个文件中。

有两个注意事项值得了解。首先，每个代码文件仍然只能有一个类型定义（这通常不是问题，因为标头保护会阻止这种情况）。其次，给定类型的所有类型定义必须相同，否则会导致未定义的行为。

### **命名法：用户定义类型与程序定义类型**

“用户定义类型”这个术语有时会出现在日常对话中，C++ 语言标准中也提到过（但未定义）。在日常对话中，该术语往往表示“在您自己的程序中定义的类型”（例如上面的 Fraction 类型示例）。

C++ 语言标准以非常规方式使用术语“用户定义类型”。在语言标准中，“用户定义类型”是指由您、标准库或实现定义的任何类类型或枚举类型（例如，编译器为支持语言扩展而定义的类型）。也许违反直觉，这意味着`std::string`（标准库中定义的类类型）被视为用户定义类型！

为了提供额外的区分，C++20 语言标准对术语“程序定义类型”进行了有益的定义，即指未作为标准库、实现或核心语言的一部分定义的类类型和枚举类型。换句话说，“程序定义类型”仅包括由我们（或第三方库）定义的类类型和枚举类型。

因此，当仅谈论我们在自己的程序中定义的类类型和枚举类型时，我们更喜欢使用术语“程序定义”，因为它具有更精确的定义。

| 类型     | 意义                                                         | 示例                                 |
| -------- | ------------------------------------------------------------ | ------------------------------------ |
| 基本的   | 核心 C++ 语言的内置类型                                      | int，std::nullptr_t                  |
| Compound | 由基本类型构建的类型                                         | int&、double*、std::string、Fraction |
| 用户定义 | 类类型或枚举类型 （包括标准库或实现中定义的类型） （在非正式使用中，通常用于表示程序定义的类型） | std::string，Fraction                |
| 程序定义 | 类类型或枚举类型 （不包括标准库或实现中定义的类型）          | Fraction                             |

## 13.2 — 无作用域枚举

C++ 包含许多有用的基本数据类型和复合数据类型（我们在课程[4.1 - 基本数据类型简介](https://www.learncpp.com/cpp-tutorial/introduction-to-fundamental-data-types/)和课程[12.1 - 复合数据类型简介](https://www.learncpp.com/cpp-tutorial/introduction-to-compound-data-types/)中介绍过）。但这些类型并不总是能满足我们想要做的事情。

例如，假设您正在编写一个程序，需要跟踪苹果是红色、黄色还是绿色，或者衬衫是什么颜色（从预设的颜色列表中）。如果只有基本类型可用，您将如何做到这一点？

您可以使用某种隐式映射将颜色存储为整数值（0 = 红色，1 = 绿色，2 = 蓝色）：

```c++
int main()
{
    int appleColor{ 0 }; // my apple is red
    int shirtColor{ 1 }; // my shirt is green

    return 0;
}
```

但这根本不直观，我们已经讨论过为什么魔法数字不好（[5.2 -- 文字](https://www.learncpp.com/cpp-tutorial/literals/)）。我们可以通过使用符号常量来摆脱魔法数字：

```c++
constexpr int red{ 0 };
constexpr int green{ 1 };
constexpr int blue{ 2 };

int main()
{
    int appleColor{ red };
    int shirtColor{ green };

    return 0;
}
```

虽然这对于阅读来说稍微好一些，但是程序员仍然需要推断出`appleColor`和`shirtColor`（类型`int`）用于保存颜色符号常量集合中定义的值之一（这些值可能在其他地方定义，可能在单独的文件中）。

我们可以使用类型别名使这个程序更清晰一些：

```c++
using Color = int; // define a type alias named Color

// The following color values should be used for a Color
constexpr Color red{ 0 };
constexpr Color green{ 1 };
constexpr Color blue{ 2 };

int main()
{
    Color appleColor{ red };
    Color shirtColor{ green };

    return 0;
}
```

我们越来越接近了。阅读此代码的人仍然必须了解这些颜色符号常量应该与类型变量一起使用`Color`，但至少类型现在有一个唯一的名称，因此搜索的人`Color`将能够找到相关符号常量的集合。

然而，由于`Color`只是 的别名`int`，我们仍然面临一个问题，即没有任何东西可以强制正确使用这些颜色符号常量。我们仍然可以这样做：

```c++
Color eyeColor{ 8 }; // syntactically valid, semantically meaningless
```

此外，如果我们在调试器中调试任何这些变量，我们将只能看到颜色的整数值（例如`0`），而看不到符号含义（`red`），这会使我们更难判断程序是否正确。

幸运的是，我们可以做得更好。

为了启发，请考虑一下`bool`类型。`bool`特别有趣的是，它只有两个定义的值：`true`和`false`。我们可以直接使用`true`或`false`（作为文字），也可以实例化一个`bool`对象并让它保存其中一个值。此外，编译器能够区分`bool`其他类型。这意味着我们可以重载函数，并自定义这些函数在传递`bool`值时的行为。

如果我们有能力定义自己的自定义类型，并且*可以*定义与该类型相关的命名值集，那么我们就有完美的工具来优雅地解决上述挑战……

### **枚举**

枚举（也称为**枚举类型**或枚举**）是一种复合数据类型，其****值**仅限于一组命名的符号常量（称为**枚举器**）。

C++ 支持两种类型的枚举：无范围枚举（我们现在将介绍）和有范围枚举（我们将在本章后面介绍）。

因为枚举是程序定义的类型[13.1 -- 程序定义（用户定义）类型介绍](https://www.learncpp.com/cpp-tutorial/introduction-to-program-defined-user-defined-types/)，所以每个枚举都需要在使用它之前进行完整定义（前向声明是不够的）。

### **无作用域枚举**

范围枚举是通过`enum`关键字定义的。

枚举类型最好通过示例来讲解，因此让我们定义一个可以保存一些颜色值的无范围枚举。我们将在下面解释它的工作原理。

```c++
// Define a new unscoped enumeration named Color
enum Color
{
    // Here are the enumerators
    // These symbolic constants define all the possible values this type can hold
    // Each enumerator is separated by a comma, not a semicolon
    red,
    green,
    blue, // trailing comma optional but recommended
}; // the enum definition must end with a semicolon

int main()
{
    // Define a few variables of enumerated type Color
    Color apple { red };   // my apple is red
    Color shirt { green }; // my shirt is green
    Color cup { blue };    // my cup is blue

    Color socks { white }; // error: white is not an enumerator of Color
    Color hat { 2 };       // error: 2 is not an enumerator of Color

    return 0;
}
```

我们通过使用`enum`关键字来开始我们的示例，以告诉编译器我们正在定义一个无范围的枚举，我们将其命名为`Color`。

在一对花括号内，我们定义了类型的枚举器`Color`：`red`、`green`和`blue`。这些枚举器定义了该类型所限的特定值`Color`。每个枚举器必须用逗号（而不是分号）分隔 - 最后一个枚举器后面的尾随逗号是可选的，但为了保持一致性，建议使用。

最常见的是每行定义一个枚举器，但在简单情况下（枚举器数量较少且不需要注释），它们也可以全部定义在一行上。

类型定义`Color`以分号结尾。现在我们已经完全定义了什么`Color`是枚举类型！

在 中`main()`，我们实例化了三个类型为 的变量`Color`：`apple`用颜色 初始化`red`，`shirt`用颜色 初始化`green`，`cup`用颜色 初始化`blue`。 为每个对象分配内存。 请注意，枚举类型的初始化器必须是该类型定义的枚举器之一。 变量`socks`和`hat`会导致编译错误，因为初始化器`white`和`2`不是 的枚举器`Color`。

枚举器隐式地是 constexpr。

**提醒**

快速回顾一下命名法：

- 枚举或*枚举类型*是程序定义的类型本身（例如*）*。`Color`
- *枚举器*是属于枚举的特定命名值（例如`red`）。

### **命名枚举和枚举器**

按照惯例，枚举类型的名称以大写字母开头（所有程序定义的类型都是如此）。

**警告**:枚举不必命名，但是在现代 C++ 中应该避免使用未命名的枚举。

枚举器必须有名字。遗憾的是，枚举器名称没有通用的命名约定。常见的选择包括以小写字母开头（例如 red）、以大写字母开头（Red）、全部大写字母（RED）、全部大写字母加前缀（COLOR_RED），或以“k”为前缀并插入大写字母（kColorRed）。

现代 C++ 指南通常建议避免使用全大写的命名约定，因为全大写通常用于预处理器宏，并且可能会发生冲突。我们还建议避免使用以大写字母开头的约定，因为以大写字母开头的名称通常保留用于程序定义的类型。

**最佳实践:**枚举类型以大写字母开头命名。枚举器以小写字母开头命名。

### **枚举类型是不同的类型**

您创建的每个枚举类型都被视为一种**不同的类型**，这意味着编译器可以将其与其他类型区分开来（与 typedef 或类型别名不同，它们被认为与它们所别名的类型没有区别）。

由于枚举类型是不同的，因此定义为一个枚举类型的一部分的枚举器不能与另一个枚举类型的对象一起使用：

```c++
enum Pet
{
    cat,
    dog,
    pig,
    whale,
};

enum Color
{
    black,
    red,
    blue,
};

int main()
{
    Pet myPet { black }; // compile error: black is not an enumerator of Pet
    Color shirt { pig }; // compile error: pig is not an enumerator of Color

    return 0;
}
```

不管怎样，你可能都不想要一件猪衬衫。

### **使用枚举**

由于枚举器具有描述性，因此它们对于增强代码文档和可读性非常有用。当您拥有一组较小的相关常量，并且对象每次只需要保存其中一个值时，最好使用枚举类型。

通常定义的枚举包括一周中的日子、基本方向和一副牌的花色：

```c++
enum DaysOfWeek
{
    sunday,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday,
    saturday,
};

enum CardinalDirections
{
    north,
    east,
    south,
    west,
};

enum CardSuits
{
    clubs,
    diamonds,
    hearts,
    spades,
};
```

有时函数会向调用者返回状态代码，以指示函数是否成功执行或遇到错误。传统上，使用较小的负数来表示不同的可能错误代码。例如：

```c++
int readFileContents()
{
    if (!openFile())
        return -1;
    if (!readFile())
        return -2;
    if (!parseFile())
        return -3;

    return 0; // success
}
```

但是，使用这样的魔法数字不太具有描述性。更好的方法是使用枚举类型：

```c++
enum FileReadResult
{
    readResultSuccess,
    readResultErrorFileOpen,
    readResultErrorFileRead,
    readResultErrorFileParse,
};

FileReadResult readFileContents()
{
    if (!openFile())
        return readResultErrorFileOpen;
    if (!readFile())
        return readResultErrorFileRead;
    if (!parseFile())
        return readResultErrorFileParse;

    return readResultSuccess;
}
```

然后，调用者可以根据适当的枚举器测试函数的返回值，这比测试特定整数值的返回结果更容易理解。

```c++
if (readFileContents() == readResultSuccess)
{
    // do something
}
else
{
    // print error message
}
```

枚举类型在游戏中也很有用，可以识别不同类型的物品、怪物或地形。基本上，任何由一小组相关对象组成的事物都可以。

例如：

```c++
enum ItemType
{
	sword,
	torch,
	potion,
};

int main()
{
	ItemType holding{ torch };

	return 0;
}
```

当用户需要在两个或多个选项之间做出选择时，枚举类型也可以作为有用的函数参数：

```c++
enum SortOrder
{
    alphabetical,
    alphabeticalReverse,
    numerical,
};

void sortData(SortOrder order)
{
    switch (order)
    {
        case alphabetical:
            // sort data in forwards alphabetical order
            break;
        case alphabeticalReverse:
            // sort data in backwards alphabetical order
            break;
        case numerical:
            // sort data numerically
            break;
    }
}
```

许多语言使用枚举来定义布尔值 - 毕竟，布尔值本质上只是一个具有 2 个枚举器的枚举：`false`和`true`！然而，在 C++ 中，`true`和`false`被定义为关键字而不是枚举器。

因为枚举很小并且复制起来很便宜，所以可以通过值传递（和返回）它们。

在课程[O.1 -- 通过 std::bitset 进行位标志和位操作](https://www.learncpp.com/cpp-tutorial/bit-flags-and-bit-manipulation-via-stdbitset/)中，我们讨论了位标志。枚举还可用于定义相关位标志位置的集合，以供使用`std::bitset`：

```c++
#include <bitset>
#include <iostream>

namespace Flags
{
    enum State
    {
        isHungry,
        isSad,
        isMad,
        isHappy,
        isLaughing,
        isAsleep,
        isDead,
        isCrying,
    };
}

int main()
{
    std::bitset<8> me{};
    me.set(Flags::isHappy);
    me.set(Flags::isLaughing);

    std::cout << std::boolalpha; // print bool as true/false

    // Query a few states (we use the any() function to see if any bits remain set)
    std::cout << "I am happy? " << me.test(Flags::isHappy) << '\n';
    std::cout << "I am laughing? " << me.test(Flags::isLaughing) << '\n';

    return 0;
}
```

如果您想知道如何在需要整数值的地方使用枚举器，无作用域枚举器将隐式转换为整数值。我们将在下一课中进一步探讨这一点（[13.3--无作用域枚举器整数转换](https://www.learncpp.com/cpp-tutorial/unscoped-enumerator-integral-conversions/)）。

### **无范围枚举的范围**

无范围枚举之所以如此命名，是因为它们将其枚举器名称放入与枚举定义本身相同的范围中（而不是像命名空间那样创建一个新的范围区域）。

例如，给定这个程序：

```c++
enum Color // this enum is defined in the global namespace
{
    red, // so red is put into the global namespace
    green,
    blue,
};

int main()
{
    Color apple { red }; // my apple is red

    return 0;
}
```

枚举`Color`在全局范围内定义。因此，所有枚举名称（`red`、`green`和`blue`）也进入全局范围。这会污染全局范围并显著增加命名冲突的可能性。

这样做的后果是，一个枚举器名称不能在同一范围内的多个枚举中使用：

```c++
enum Color
{
    red,
    green,
    blue, // blue is put into the global namespace
};

enum Feeling
{
    happy,
    tired,
    blue, // error: naming collision with the above blue
};

int main()
{
    Color apple { red }; // my apple is red
    Feeling me { happy }; // I'm happy right now (even though my program doesn't compile)

    return 0;
}
```

在上面的例子中，两个无作用域枚举（`Color`和`Feeling`）都将同名的枚举器`blue`放入全局作用域中。这会导致命名冲突和随后的编译错误。

无作用域枚举还为其枚举器提供了一个命名作用域区域（就像命名空间充当其中声明的名称的命名作用域区域一样）。这意味着我们可以按如下方式访问无作用域枚举的枚举器：

```c++
enum Color
{
    red,
    green,
    blue, // blue is put into the global namespace
};

int main()
{
    Color apple { red }; // okay, accessing enumerator from global namespace
    Color raspberry { Color::red }; // also okay, accessing enumerator from scope of Color

    return 0;
}
```

大多数情况下，访问无范围枚举器时不需要使用范围解析运算符。

### **避免枚举器命名冲突**

有很多常用的方法可以防止无范围枚举器命名冲突。

一种选择是在每个枚举器前面加上枚举本身的名称：

```c++
enum Color
{
    color_red,
    color_blue,
    color_green,
};

enum Feeling
{
    feeling_happy,
    feeling_tired,
    feeling_blue, // no longer has a naming collision with color_blue
};

int main()
{
    Color paint { color_blue };
    Feeling me { feeling_blue };

    return 0;
}
```

这仍然会污染命名空间，但通过使名称更长且更独特，可以减少命名冲突的机会。

更好的选择是将枚举类型放在提供单独范围区域的东西里面，比如命名空间：

```c++
namespace Color
{
    // The names Color, red, blue, and green are defined inside namespace Color
    enum Color
    {
        red,
        green,
        blue,
    };
}

namespace Feeling
{
    enum Feeling
    {
        happy,
        tired,
        blue, // Feeling::blue doesn't collide with Color::blue
    };
}

int main()
{
    Color::Color paint{ Color::blue };
    Feeling::Feeling me{ Feeling::blue };

    return 0;
}
```

这意味着我们现在必须在枚举和枚举器名称前加上范围区域的名称。

`Note:`类还提供了作用域，通常将与类相关的枚举类型放在类的作用域内。我们将在第[15.3 课——嵌套类型（成员类型）](https://www.learncpp.com/cpp-tutorial/nested-types-member-types/)中讨论这一点。

一个相关的选项是使用作用域枚举（它定义自己的作用域区域）。我们将很快讨论作用域枚举（[13.6 -- 作用域枚举（枚举类）](https://www.learncpp.com/cpp-tutorial/scoped-enumerations-enum-classes/)）。

**最佳实践**:最好将枚举放在命名范围区域（例如命名空间或类）内，这样枚举器就不会污染全局命名空间。

或者，如果枚举仅在单个函数主体中使用，则应在函数内部定义枚举。这会将枚举及其枚举器的范围限制在该函数内。此类枚举的枚举器将覆盖全局范围内定义的同名枚举器。

### **与枚举器进行比较**

我们可以使用相等运算符（`operator==`和`operator!=`）来测试枚举是否具有特定枚举器的值。

```c++
#include <iostream>

enum Color
{
    red,
    green,
    blue,
};

int main()
{
    Color shirt{ blue };

    if (shirt == blue) // if the shirt is blue
        std::cout << "Your shirt is blue!";
    else
        std::cout << "Your shirt is not blue!";

    return 0;
}
```

在上面的例子中，我们使用 if 语句来测试是否`shirt`等于枚举器`blue`。这为我们提供了一种方法，可以根据枚举所持有的枚举器来条件化程序的行为。

### **测验**

定义一个名为 MonsterType 的枚举类型，在以下怪物种族之间进行选择：兽人、地精、巨魔、食人魔和骷髅。

```c++
enum MonsterType
{
    orc,
    goblin,
    troll,
    ogre,
    skeleton,
};
```

将 `MonsterType` 枚举放入命名空间中。然后，创建一个 main() 函数并实例化一个 troll。该程序应该可以编译。

```c++
namespace Monster
{
    enum MonsterType
    {
        orc,
        goblin,
        troll,
        ogre,
        skeleton,
    };
}

int main()
{
    // We use [[maybe_unused]] to avoid warnings about unused variables
    // You could also output the monster instead
    [[maybe_unused]] Monster::MonsterType monster{ Monster::troll };

    return 0;
}
```

## 13.3 — 无作用域枚举器整数转换

在上一课（[13.2-无作用域枚举](https://www.learncpp.com/cpp-tutorial/unscoped-enumerations/)）中，我们提到枚举器是符号常量。我们当时没有告诉你的是，这些枚举器具有整数类型的值。

[这与字符（ 4.11 -- Chars](https://www.learncpp.com/cpp-tutorial/chars/) ）的情况类似。考虑：

```c++
char ch { 'A' };
```

char 实际上只是一个 1 字节的整数值，并且字符`'A'`会转换为整数值（在本例中为`65`）并存储。

当我们定义枚举时，每个枚举器都会根据其在枚举器列表中的位置自动与一个整数值相关联。 默认情况下，第一个枚举器被赋予整数值`0`，并且每个后续枚举器的值都比前一个枚举器大一：

```c++
enum Color
{
    black,   // 0
    red,     // 1
    blue,    // 2
    green,   // 3
    white,   // 4
    cyan,    // 5
    yellow,  // 6
    magenta, // 7
};

int main()
{
    Color shirt{ blue }; // shirt actually stores integral value 2

    return 0;
}
```

可以明确定义枚举器的值。这些整数值可以是正数或负数，并且可以与其他枚举器共享相同的值。任何未定义的枚举器都会被赋予一个比前一个枚举器大 1 的值。

```c++
enum Animal
{
    cat = -3,    // values can be negative
    dog,         // -2
    pig,         // -1
    horse = 5,
    giraffe = 5, // shares same value as horse
    chicken,     // 6
};
```

注意，在这种情况下，`horse`和`giraffe`被赋予了相同的值。当发生这种情况时，枚举器变得不唯一——本质上，`horse`和`giraffe`是可以互换的。尽管 C++ 允许这样做，但通常应避免将相同的值分配给同一枚举中的两个枚举器。

大多数情况下，枚举器的默认值就是您想要的，因此除非有特殊原因，否则请不要提供您自己的值。

**最佳实践：**除非有令人信服的理由，否则请避免为枚举器分配明确的值。

### **值初始化枚举**

如果枚举是零初始化的（当我们使用值初始化时会发生这种情况），则枚举将被赋予值`0`，即使没有具有该值的对应枚举器。

```c++
#include <iostream>

enum Animal
{
    cat = -3,    // -3
    dog,         // -2
    pig,         // -1
    // note: no enumerator with value 0 in this list
    horse = 5,   // 5
    giraffe = 5, // 5
    chicken,     // 6
};

int main()
{
    Animal a {}; // value-initialization zero-initializes a to value 0
    std::cout << a; // prints 0

    return 0;
}
```

这有两个语义后果：

- 如果存在值为 0 的枚举器，则值初始化会将枚举默认为该枚举器的含义。例如，使用前面的`enum Color`示例，值初始化`Color`将默认为`black`）。因此，最好考虑将值为 0 的枚举器设为代表枚举的最佳默认含义的枚举器。

  类似这样的情况很可能会导致问题：

  ```c++
  enum UniverseResult
  {
      destroyUniverse, // default value (0)
      saveUniverse
  };
  ```

  

- 如果没有值为 0 的枚举器，则值初始化很容易创建语义上无效的枚举。在这种情况下，我们建议添加值为 0 的“无效”或“未知”枚举器，以便您有文档记录该状态的含义，以及您可以明确处理的该状态的名称。

  ```c++
  enum Winner
  {
      winnerUnknown, // default value (0)
      player1,
      player2,
  };
  
  // somewhere later in your code
  if (w == winnerUnknown) // handle case appropriately
  ```

  

**最佳实践**

让表示 0 的枚举器成为枚举的最佳默认含义。如果没有好的默认含义，请考虑添加一个值为 0 的“无效”或“未知”枚举器，以便明确记录该状态，并在适当的情况下进行明确处理。

### **无范围枚举将隐式转换为整数值**

尽管枚举存储的是整数值，但它们不被视为整数类型（它们是复合类型）。但是，无作用域枚举将隐式转换为整数值。由于枚举器是编译时常量，因此这是一个 constexpr 转换（我们将在第[10.4 课——收缩转换、列表初始化和 constexpr 初始化器](https://www.learncpp.com/cpp-tutorial/narrowing-conversions-list-initialization-and-constexpr-initializers/)中介绍这些内容）。

考虑以下程序：

```c++
#include <iostream>

enum Color
{
    black, // assigned 0
    red, // assigned 1
    blue, // assigned 2
    green, // assigned 3
    white, // assigned 4
    cyan, // assigned 5
    yellow, // assigned 6
    magenta, // assigned 7
};

int main()
{
    Color shirt{ blue };

    std::cout << "Your shirt is " << shirt << '\n'; // what does this do?

    return 0;
}
```

由于枚举类型保存整数值，正如您所料，这将打印：

![image-20241020103419932](./assets/image-20241020103419932.png)

当枚举类型用于函数调用或与运算符一起使用时，编译器将首先尝试查找与枚举类型匹配的函数或运算符。例如，当编译器尝试编译时`std::cout << shirt`，编译器将首先查看是否`operator<<`知道如何将类型的对象`Color`（因为`shirt`是类型`Color`）打印到`std::cout`。但它不知道。

由于编译器找不到匹配项，因此它会检查是否`operator<<`知道如何打印无范围枚举转换为的整数类型的对象。如果可以，则中的值`shirt`将转换为整数值并打印为整数值`2`。

### **枚举大小和基础类型（基数）**

枚举器的值属于整数类型。但是什么整数类型呢？用于表示枚举器值的特定整数类型称为枚举的**基础类型**（或**基数**）。

对于无作用域枚举，C++ 标准未指定应使用哪种特定整数类型作为基础类型，因此选择由实现定义。大多数编译器将使用`int`作为基础类型（这意味着无作用域枚举的大小与 相同`int`），除非需要更大的类型来存储枚举器值。但您不应假设这适用于每个编译器或平台。

可以为枚举明确指定基础类型。基础类型必须是整数类型。例如，如果您在某些带宽敏感的环境中工作（例如通过网络发送数据），则可能需要为枚举指定较小的类型：

```c++
#include <cstdint>  // for std::int8_t
#include <iostream>

// Use an 8-bit integer as the enum underlying type
enum Color : std::int8_t
{
    black,
    red,
    blue,
};

int main()
{
    Color c{ black };
    std::cout << sizeof(c) << '\n'; // prints 1 (byte)

    return 0;
}
```

**最佳实践**

仅在必要时指定枚举的基类型。

**警告**

由于`std::int8_t`和`std::uint8_t`通常是 char 类型的类型别名，因此使用其中任何一种类型作为枚举基数很可能会导致枚举器打印为 char 值而不是 int 值。

### **整数到无范围枚举器的转换**

虽然编译器会将无作用域枚举隐式转换为整数，但它不会*将*整数隐式转换为无作用域枚举。以下操作将产生编译器错误：

```c++
enum Pet // no specified base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet { 2 }; // compile error: integer value 2 won't implicitly convert to a Pet
    pet = 3;       // compile error: integer value 3 won't implicitly convert to a Pet

    return 0;
}
```

有两种方法可以解决这个问题。

首先，您可以使用以下方法将整数明确转换为无范围枚举器`static_cast`：

```c++
enum Pet // no specified base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet { static_cast<Pet>(2) }; // convert integer 2 to a Pet
    pet = static_cast<Pet>(3);       // our pig evolved into a whale!

    return 0;
}
```

我们将在第 13.4 课中看到一个例子[——将枚举转换为字符串，并](https://www.learncpp.com/cpp-tutorial/converting-an-enumeration-to-and-from-a-string/)在其中利用这一点。

对目标枚举的枚举器所表示的任何整数值进行 static_cast 都是安全的。由于我们的`Pet`枚举具有值为`0`、`1`、`2`和 的枚举器`3`，因此将整数值`0`、`1`、`2`和静态转换`3`为 a`Pet`是有效的。

静态转换目标枚举基础类型范围内的任何整数值也是安全的，即使没有枚举器表示该值。静态转换基础类型范围之外的值将导致未定义的行为。

**Note**

<u>如果枚举具有明确定义的基础类型，则枚举的范围与基础类型的范围相同。</u>

<u>如果枚举没有显式的底层类型，事情会稍微复杂一些。在这种情况下，编译器可以选择底层类型，它可以选择任何有符号或无符号类型，只要所有枚举器的值都适合该类型。鉴于此，只有适合最小位数范围（可以容纳所有枚举器的值）的整数值才是安全的。</u>

<u>我们来做两个例子来说明这一点：</u>

- <u>对于具有值 2、9 和 12 的枚举器，这些枚举器至少可以适合范围为 0 到 15 的无符号 4 位整数类型。因此，只有将 0 到 15 的整数值 static_cast 转换为此枚举类型才是安全的。</u>
- <u>对于具有值 -28、2 和 6 的枚举数，这些枚举数至少可以适合范围为 -32 到 31 的有符号 6 位整数类型。因此，只有将整数值 -32 到 31 static_cast 为这种枚举类型才是安全的。</u>

其次，从 C++17 开始，如果无范围枚举具有明确指定的基数，则编译器将允许您使用整数值列出初始化无范围枚举：

```c++
enum Pet: int // we've specified a base
{
    cat, // assigned 0
    dog, // assigned 1
    pig, // assigned 2
    whale, // assigned 3
};

int main()
{
    Pet pet1 { 2 }; // ok: can brace initialize unscoped enumeration with specified base with integer (C++17)
    Pet pet2 (2);   // compile error: cannot direct initialize with integer
    Pet pet3 = 2;   // compile error: cannot copy initialize with integer

    pet1 = 3;       // compile error: cannot assign with integer

    return 0;
}
```

### **测验**

真或假。枚举器可以是：

- 给定一个整数值   真的

- 没有明确的价值 确实如此。 未明确赋值的枚举器将被隐式赋值为前一个枚举器的整数值 + 1。如果没有前一个枚举器，则枚举器将采用 0 值。 

- 给定浮点值  错误的

- 给定负值 真的

- 给定一个非唯一值 真的

- 给定先前枚举器的值（例如洋红色=红色）没错。枚举器不必是唯一的。由于枚举器隐式转换为整数，并且可以将整数赋给枚举器，因此可以使用其他枚举器初始化枚举器（尽管通常没有理由这样做！）。

- 给定一个非 `constexpr` 值  错误。由于枚举器是 `constexpr`，因此它们的值也必须是 `constexpr`。

  

## 13.4 — 将枚举转换为字符串

在上一课（[13.3 -- 无范围枚举器整数转换](https://www.learncpp.com/cpp-tutorial/unscoped-enumerator-integral-conversions/)）中，我们展示了这样的示例：

```c++
#include <iostream>

enum Color
{
    black, // 0
    red,   // 1
    blue,  // 2
};

int main()
{
    Color shirt{ blue };

    std::cout << "Your shirt is " << shirt << '\n';

    return 0;
}
```

因为`operator<<`不知道如何打印`Color`，所以编译器会隐式地将其转换`Color`为整数值并打印出来。

大多数情况下，将枚举打印为整数值（例如`2`）并不是我们想要的。相反，我们通常希望打印枚举器所代表的任何名称（例如`blue`）。C++ 没有提供现成的方法来执行此操作，因此我们必须自己找到解决方案。幸运的是，这并不难。

### **获取枚举器的名称**

获取枚举器名称的典型方法是编写一个函数，该函数允许我们传入枚举器并以字符串形式返回枚举器的名称。但这需要某种方法来确定应为给定的枚举器返回哪个字符串。

有两种常见的方法可以实现这一点。

在课程[8.5 -- Switch 语句基础](https://www.learncpp.com/cpp-tutorial/switch-statement-basics/)中，我们注意到 switch 语句可以切换整数值或枚举值。在下面的示例中，我们使用 switch 语句选择一个枚举器并返回该枚举器的适当颜色字符串文字：

```c++
#include <iostream>
#include <string_view>

enum Color
{
    black,
    red,
    blue,
};

constexpr std::string_view getColorName(Color color)
{
    switch (color)
    {
    case black: return "black";
    case red:   return "red";
    case blue:  return "blue";
    default:    return "???";
    }
}

int main()
{
    constexpr Color shirt{ blue };

    std::cout << "Your shirt is " << getColorName(shirt) << '\n';

    return 0;
}
```

在上面的例子中，我们打开了`color`，它保存了我们传入的枚举器。在 switch 内部，我们为 的每个枚举器都有一个 case 标签`Color`。每个 case 都会以 C 样式字符串文字的形式返回相应颜色的名称。此 C 样式字符串文字会隐式转换为`std::string_view`，并返回给调用者。我们还有一个默认 case，它返回`"???"`，以防用户传入我们意想不到的内容。

**提醒**

由于 C 样式字符串文字存在于整个程序中，因此可以返回`std::string_view`查看 C 样式字符串文字的 。当`std::string_view`复制回调用者时，正在查看的 C 样式字符串文字仍将存在。

该函数是 constexpr，因此我们可以在常量表达式中使用颜色的名称。

虽然这可以让我们获得枚举器的名称，但如果我们想将该名称打印到控制台，则必须执行的操作`std::cout << getColorName(shirt)`并不像那么好`std::cout << shirt`。我们将`std::cout`在即将到来的课程 13.5 中教授如何打印枚举[——重载 I/O 运算符的介绍](https://www.learncpp.com/cpp-tutorial/introduction-to-overloading-the-i-o-operators/)。

解决将枚举器映射到字符串的程序的第二种方法是使用数组。我们将在第[17.6 课——std::array 和枚举](https://www.learncpp.com/cpp-tutorial/stdarray-and-enumerations/)中介绍这一点。

### **无范围枚举器输入**

现在让我们看一个输入案例。在下面的例子中，我们定义一个`Pet`枚举。由于`Pet`是程序定义的类型，因此语言不知道如何`Pet`使用输入`std::cin`：

```c++
#include <iostream>

enum Pet
{
    cat,   // 0
    dog,   // 1
    pig,   // 2
    whale, // 3
};

int main()
{
    Pet pet { pig };
    std::cin >> pet; // compile error: std::cin doesn't know how to input a Pet

    return 0;
}
```

解决此问题的一个简单方法是读入一个整数，然后将`static_cast`其转换为适当枚举类型的枚举器：

```c++
#include <iostream>
#include <string_view>

enum Pet
{
    cat,   // 0
    dog,   // 1
    pig,   // 2
    whale, // 3
};

constexpr std::string_view getPetName(Pet pet)
{
    switch (pet)
    {
    case cat:   return "cat";
    case dog:   return "dog";
    case pig:   return "pig";
    case whale: return "whale";
    default:    return "???";
    }
}

int main()
{
    std::cout << "Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): ";

    int input{};
    std::cin >> input; // input an integer

    if (input < 0 || input > 3)
        std::cout << "You entered an invalid pet\n";
    else
    {
        Pet pet{ static_cast<Pet>(input) }; // static_cast our integer to a Pet
        std::cout << "You entered: " << getPetName(pet) << '\n';
    }

    return 0;
}
```

虽然这可行，但有点尴尬。还要注意，我们只应该`static_cast<Pet>(input)`在知道`input`在枚举器范围内时才这样做。

### 从字符串获取枚举

如果用户可以输入一个代表枚举器的字符串（例如“pig”），而不是输入数字，那么效果会更好，我们可以将该字符串转换为适当的`Pet`枚举器。但是，这样做需要我们解决几个挑战。

首先，我们不能打开一个字符串，所以我们需要使用其他东西来匹配用户传入的字符串。这里最简单的方法是使用一系列 if 语句。

其次，`Pet`如果用户传入无效字符串，我们应该返回什么枚举器？一种选择是添加一个枚举器来表示“无/无效”，然后返回它。但是，更好的选择是`std::optional`在这里使用。

```c++
#include <iostream>
#include <optional> // for std::optional
#include <string>
#include <string_view>

enum Pet
{
    cat,   // 0
    dog,   // 1
    pig,   // 2
    whale, // 3
};

constexpr std::string_view getPetName(Pet pet)
{
    switch (pet)
    {
    case cat:   return "cat";
    case dog:   return "dog";
    case pig:   return "pig";
    case whale: return "whale";
    default:    return "???";
    }
}

constexpr std::optional<Pet> getPetFromString(std::string_view sv)
{
    if (sv == "cat")   return cat;
    if (sv == "dog")   return dog;
    if (sv == "pig")   return pig;
    if (sv == "whale") return whale;

    return {};
}

int main()
{
    std::cout << "Enter a pet: cat, dog, pig, or whale: ";
    std::string s{};
    std::cin >> s;

    std::optional<Pet> pet { getPetFromString(s) };

    if (!pet)
        std::cout << "You entered an invalid pet\n";
    else
        std::cout << "You entered: " << getPetName(*pet) << '\n';

    return 0;
}
```

在上述解决方案中，我们使用一系列 if-else 语句进行字符串比较。如果用户的输入字符串与枚举器字符串匹配，我们将返回相应的枚举器。如果没有匹配的字符串，我们将返回`{}`，这意味着“无值”。

**note**

注意上面的解决方案只匹配小写字母。如果要匹配任意大小写，可以使用以下函数将用户的输入转换为小写：

```c++
#include <algorithm> // for std::transform
#include <cctype>    // for std::tolower
#include <string>
#include <string_view>

// This function returns a std::string that is the lower-case version of the std::string_view passed in.
// Only 1:1 character mapping can be performed by this function
std::string toASCIILowerCase(std::string_view sv)
{
    std::string lower{};
    std::transform(sv.begin(), sv.end(), std::back_inserter(lower),
        [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
    return lower;
}
```

此函数遍历 中的每个字符`std::string_view sv`，使用 将其转换为小写字符`std::tolower()`（在 lambda 的帮助下），然后将该小写字符附加到`lower`。

与输出情况类似，如果我们可以的话会更好`std::cin >> pet`。我们将在即将到来的课程[13.5——I/O 运算符重载简介](https://www.learncpp.com/cpp-tutorial/introduction-to-overloading-the-i-o-operators/)中介绍这一点。

## 13.5 — I/O 运算符重载介绍

在上一课 ( [13.4 -- 将枚举转换为字符串以及从字符串转换](https://www.learncpp.com/cpp-tutorial/converting-an-enumeration-to-and-from-a-string/)) 中，我们展示了这个例子，其中我们使用一个函数将枚举转换为等效的字符串：

```c++
#include <iostream>
#include <string_view>

enum Color
{
    black,
    red,
    blue,
};

constexpr std::string_view getColorName(Color color)
{
    switch (color)
    {
    case black: return "black";
    case red:   return "red";
    case blue:  return "blue";
    default:    return "???";
    }
}

int main()
{
    constexpr Color shirt{ blue };

    std::cout << "Your shirt is " << getColorName(shirt) << '\n';

    return 0;
}
```

尽管上面的例子运行良好，但也存在两个缺点：

1. 我们必须记住我们创建的用于获取枚举器名称的函数的名称。
2. 必须调用这样的函数会使我们的输出语句变得更加混乱。

`operator<<`理想情况下，如果我们能够以某种方式教会输出枚举，那就太好了，所以我们可以做这样的事情：`std::cout << shirt`并让它做我们期望的事情。

### **运算符重载简介**

在课程[11.1 — 函数重载简介](https://www.learncpp.com/cpp-tutorial/introduction-to-function-overloading/)中，我们介绍了函数重载，它允许我们创建具有相同名称的多个函数，只要每个函数具有唯一的函数原型即可。使用函数重载，我们可以创建适用于不同数据类型的函数变体，而不必为每个变体想出一个唯一的名称。

类似地，C++ 也支持**运算符重载**，它允许我们定义现有运算符的重载，以便我们可以使这些运算符与我们程序定义的数据类型一起工作。

基本运算符重载相当简单：

- 使用运算符的名称作为函数的名称来定义函数。
- 为每个操作数添加一个适当类型的参数（按从左到右的顺序）。这些参数之一必须是用户定义类型（类类型或枚举类型），否则编译器会出错。
- 将返回类型设置为任何有意义的类型。
- 使用return语句返回操作的结果。

当编译器在表达式中遇到运算符的使用，并且一个或多个操作数是用户定义类型时，编译器将检查是否存在可用于解析该调用的重载运算符函数。例如，给定某个表达式`x + y`，编译器将使用函数重载解析来查看是否存在`operator+(x, y)`可用于评估该运算的函数调用。如果可以找到一个非歧义`operator+`函数，则将调用该函数，并将运算结果作为返回值返回。

**note：**运算符也可以重载为最左操作数的成员函数。

### 重载`operator<<`以打印枚举器

在我们继续之前，让我们快速回顾一下`operator<<`它用于输出时的工作原理。

考虑一个简单的表达式，如`std::cout << 5`.`std::cout`有类型`std::ostream`（这是标准库中的用户定义类型），并且`5`是类型的文字`int`。

当评估此表达式时，编译器将寻找一个`operator<<`可以处理类型为`std::ostream`和 的参数的重载函数`int`。它将找到这样一个函数（也定义为标准 I/O 库的一部分）并调用它。在该函数内部，`std::cout`用于输出`x`到控制台（具体如何实现定义）。最后，该`operator<<`函数返回其左操作数（在本例中为`std::cout`），以便`operator<<`可以链接后续对 的调用。

考虑到上述情况，让我们实现一个重载`operator<<`来打印`Color`：

```c++
#include <iostream>
#include <string_view>

enum Color
{
	black,
	red,
	blue,
};

constexpr std::string_view getColorName(Color color)
{
    switch (color)
    {
    case black: return "black";
    case red:   return "red";
    case blue:  return "blue";
    default:    return "???";
    }
}

// Teach operator<< how to print a Color
// std::ostream is the type of std::cout, std::cerr, etc...
// The return type and parameter type are references (to prevent copies from being made)
std::ostream& operator<<(std::ostream& out, Color color)
{
    out << getColorName(color); // print our color's name to whatever output stream out
    return out;                 // operator<< conventionally returns its left operand

    // The above can be condensed to the following single line:
    // return out << getColorName(color)
}

int main()
{
	Color shirt{ blue };
	std::cout << "Your shirt is " << shirt << '\n'; // it works!

	return 0;
}
```

让我们稍微解开一下重载运算符函数。首先，函数的名称是`operator<<`，因为这是我们正在重载的运算符的名称。`operator<<`有两个参数。左边的参数是我们的输出流，其类型为`std::ostream`。我们在这里使用非常量引用传递，因为我们不想`std::ostream`在调用函数时复制对象，但`std::ostream`需要修改对象才能进行输出。右边的参数是我们的`Color`对象。由于`operator<<`通常返回其左操作数，因此返回类型与左操作数的类型匹配，即`std::ostream&`。

现在让我们看看实现。`std::ostream`对象已经知道如何`std::string_view`使用a 来打印`operator<<`（这是标准库的一部分）。因此，`out << getColorName(color)`只需将颜色名称作为 a 获取`std::string_view`，然后将其打印到输出流即可。

请注意，我们的实现使用参数`out`而不是`std::cout`因为我们希望允许调用者确定他们将输出到哪个输出流（例如`std::cerr << color`应该输出到`std::cerr`，而不是`std::cout`）。

返回左操作数也很简单。左操作数是参数`out`，所以我们只需返回`out`。

综上所述：当我们调用 时`std::cout << shirt`，编译器将看到我们已经重载了，`operator<<`可以使用 类型的对象`Color`。`operator<<`然后使用`std::cout`作为`out`参数 调用我们的重载函数，并使用我们的`shirt`变量（其值为`blue`）作为参数`color`。由于`out`是对 的引用`std::cout`，并且`color`是枚举器的副本`blue`，因此表达式`out << getColorName(color)`将打印`"blue"`到控制台。最后，`out`如果我们想要链接其他输出，则将返回给调用者。

### 重载`operator>>`以输入枚举器

与我们上面教导如何`operator<<`输出枚举类似，我们也可以教导`operator>>`如何输入枚举：

```c++
#include <iostream>
#include <limits>
#include <optional>
#include <string>
#include <string_view>

enum Pet
{
    cat,   // 0
    dog,   // 1
    pig,   // 2
    whale, // 3
};

constexpr std::string_view getPetName(Pet pet)
{
    switch (pet)
    {
    case cat:   return "cat";
    case dog:   return "dog";
    case pig:   return "pig";
    case whale: return "whale";
    default:    return "???";
    }
}

constexpr std::optional<Pet> getPetFromString(std::string_view sv)
{
    if (sv == "cat")   return cat;
    if (sv == "dog")   return dog;
    if (sv == "pig")   return pig;
    if (sv == "whale") return whale;

    return {};
}

// pet is an in/out parameter
std::istream& operator>>(std::istream& in, Pet& pet)
{
    std::string s{};
    in >> s; // get input string from user

    std::optional<Pet> match { getPetFromString(s) };
    if (match) // if we found a match
    {
        pet = *match; // dereference std::optional to get matching enumerator
        return in;
    }

    // We didn't find a match, so input must have been invalid
    // so we will set input stream to fail state
    in.setstate(std::ios_base::failbit);

    // On an extraction failure, operator>> zero-initializes fundamental types
    // Uncomment the following line to make this operator do the same thing
    // pet = {};

    return in;
}

int main()
{
    std::cout << "Enter a pet: cat, dog, pig, or whale: ";
    Pet pet{};
    std::cin >> pet;

    if (std::cin) // if we found a match
        std::cout << "You chose: " << getPetName(pet) << '\n';
    else
    {
        std::cin.clear(); // reset the input stream to good
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        std::cout << "Your pet was not valid\n";
    }

    return 0;
}
```

这里与输出情况有几个值得注意的区别。首先，`std::cin`具有类型`std::istream`，因此我们使用`std::istream&`作为左参数和返回值的类型，而不是`std::ostream&`。其次，`pet`参数是非 const 引用。`operator>>`如果我们的提取结果匹配，这允许我们修改传入的右操作数的值。

**关键见解：**我们的右操作数（`pet`）是一个输出参数。我们将在第[12.13 课“输入和输出参数”](https://www.learncpp.com/cpp-tutorial/in-and-out-parameters/)中介绍输出参数。

如果`pet`是值参数而不是引用参数，那么我们的`operator>>`函数最终会将新值分配给右操作数的副本，而不是实际的右操作数。在这种情况下，我们希望修改右操作数。

在函数内部，我们使用`operator>>`输入`std::string`（它已经知道如何执行的操作）。如果用户输入的值与我们的宠物之一匹配，那么我们可以分配`pet`适当的枚举器并返回左操作数（`in`）。

如果用户没有输入有效的宠物，我们会通过进入`std::cin`“失败模式”来处理这种情况。这是`std::cin`提取失败时通常会进入的状态。然后调用者可以检查`std::cin`提取是成功还是失败。

**相关内容**

在第 17.6课[——std::array 和枚举](https://www.learncpp.com/cpp-tutorial/stdarray-and-enumerations/)中，我们展示了如何使用它`std::array`来减少输入和输出运算符的冗余，并避免在添加新的枚举器时修改它们。

## 13.6 — 范围枚举（枚举类）

尽管无作用域枚举在 C++ 中是不同的类型，但它们不是类型安全的，在某些情况下会允许您执行无意义的操作。考虑以下情况：

```c++
#include <iostream>

int main()
{
    enum Color
    {
        red,
        blue,
    };

    enum Fruit
    {
        banana,
        apple,
    };

    Color color { red };
    Fruit fruit { banana };

    if (color == fruit) // The compiler will compare color and fruit as integers
        std::cout << "color and fruit are equal\n"; // and find they are equal!
    else
        std::cout << "color and fruit are not equal\n";

    return 0;
}
```

当比较`color`和`fruit`时，编译器会查看是否知道如何比较a`Color`和a `Fruit`。但不知道。接下来，它会尝试将`Color`和/或转换`Fruit`为整数，看看是否能找到匹配项。最终，编译器会确定，如果将两者都转换为整数，则可以进行比较。由于`color`和`fruit`都设置为可转换为整数值的枚举器`0`，`color`因此将等于`fruit`。

这在语义上毫无意义，因为`color`和`fruit`来自不同的枚举，并且不旨在进行比较。使用标准枚举器，没有简单的方法可以防止这种情况。

由于这样的挑战，以及命名空间污染问题（在全局范围内定义的无范围枚举将其枚举器放在全局命名空间中），C++ 设计人员确定需要一个更清晰的枚举解决方案。

### **范围枚举**

该解决方案是**范围枚举**（在 C++ 中通常称为**枚举类**，其原因很快就会变得显而易见）。

范围枚举的工作方式与无范围枚举类似（[13.2 -- 无范围枚举](https://www.learncpp.com/cpp-tutorial/unscoped-enumerations/)），但有两个主要区别：它们不会隐式转换为整数，并且枚举器*仅*放置在枚举的范围区域中（而不是定义枚举的范围区域中）。

要创建范围枚举，我们使用关键字`enum class`。范围枚举定义的其余部分与无范围枚举定义相同。以下是一个例子：

```c++
#include <iostream>
int main()
{
    enum class Color // "enum class" defines this as a scoped enumeration rather than an unscoped enumeration
    {
        red, // red is considered part of Color's scope region
        blue,
    };

    enum class Fruit
    {
        banana, // banana is considered part of Fruit's scope region
        apple,
    };

    Color color { Color::red }; // note: red is not directly accessible, we have to use Color::red
    Fruit fruit { Fruit::banana }; // note: banana is not directly accessible, we have to use Fruit::banana

    if (color == fruit) // compile error: the compiler doesn't know how to compare different types Color and Fruit
        std::cout << "color and fruit are equal\n";
    else
        std::cout << "color and fruit are not equal\n";

    return 0;
}
```

该程序在第 19 行产生编译错误，因为范围枚举不会转换为任何可以与其他类型进行比较的类型。

**顺便说一下……**

关键字`class`（连同`static`关键字）是 C++ 语言中最常重载的关键字之一，根据上下文可能具有不同的含义。虽然作用域枚举使用关键字`class`，但它们不被视为“类类型”（为结构、类和联合保留）。

`enum struct`在此上下文中也有效，并且行为与 相同`enum class`。但是， 的使用`enum struct`不符合惯用语，因此请避免使用。

### **作用域枚举定义自己的作用域区域**

与无范围枚举不同，无范围枚举将其枚举器放在与枚举本身相同的范围中，而有范围枚举*仅*将其枚举器放在枚举的范围区域中。换句话说，有范围枚举就像其枚举器的命名空间。当在全局范围内使用有范围枚举时，这种内置命名空间有助于减少全局命名空间污染和名称冲突的可能性。

要访问范围枚举器，我们这样做就像它在具有与范围枚举相同名称的命名空间中一样：

```c++
#include <iostream>

int main()
{
    enum class Color // "enum class" defines this as a scoped enum rather than an unscoped enum
    {
        red, // red is considered part of Color's scope region
        blue,
    };

    std::cout << red << '\n';        // compile error: red not defined in this scope region
    std::cout << Color::red << '\n'; // compile error: std::cout doesn't know how to print this (will not implicitly convert to int)

    Color color { Color::blue }; // okay

    return 0;
}
```

因为范围枚举为枚举器提供了自己的隐式命名空间，所以没有必要将范围枚举放在另一个范围区域（例如命名空间）内，除非有其他令人信服的理由，因为这将是多余的。

### **范围枚举不会隐式转换为整数**

与非作用域枚举器不同，作用域枚举器不会隐式转换为整数。在大多数情况下，这是一件好事，因为这样做几乎没有意义，并且它有助于防止语义错误，例如比较来自不同枚举的枚举器，或诸如 之类的表达式`red + 5`。

请注意，您仍然可以在同一范围的枚举内比较枚举器（因为它们属于同一类型）：

```c++
#include <iostream>
int main()
{
    enum class Color
    {
        red,
        blue,
    };

    Color shirt { Color::red };

    if (shirt == Color::red) // this Color to Color comparison is okay
        std::cout << "The shirt is red!\n";
    else if (shirt == Color::blue)
        std::cout << "The shirt is blue!\n";

    return 0;
}
```

在某些情况下，将范围枚举器视为整数值很有用。在这些情况下，您可以使用 将范围枚举器显式转换为整数`static_cast`。C++23 中的更好选择是使用`std::to_underlying()`（在 <utility> 标头中定义），它将枚举器转换为枚举的基础类型的值。

```c++
#include <iostream>
#include <utility> // for std::to_underlying() (C++23)

int main()
{
    enum class Color
    {
        red,
        blue,
    };

    Color color { Color::blue };

    std::cout << color << '\n'; // won't work, because there's no implicit conversion to int
    std::cout << static_cast<int>(color) << '\n';   // explicit conversion to int, will print 1
    std::cout << std::to_underlying(color) << '\n'; // convert to underlying type, will print 1 (C++23)

    return 0;
}
```

相反，您也可以将`static_cast`整数添加到范围枚举器，这在从用户输入时很有用：

```c++
#include <iostream>

int main()
{
    enum class Pet
    {
        cat, // assigned 0
        dog, // assigned 1
        pig, // assigned 2
        whale, // assigned 3
    };

    std::cout << "Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): ";

    int input{};
    std::cin >> input; // input an integer

    Pet pet{ static_cast<Pet>(input) }; // static_cast our integer to a Pet

    return 0;
}
```

从 C++17 开始，你可以使用不带 static_cast 的整数值列表初始化范围枚举（与无范围枚举不同，你不需要指定基数）：

```c++
// using enum class Pet from prior example
Pet pet { 1 }; // okay
```

**最佳实践**

<u>除非有令人信服的理由，否则应优先使用有范围的枚举，而不是无范围的枚举。</u>

尽管范围枚举具有诸多好处，但无范围枚举在 C++ 中仍然很常用，因为在某些情况下我们需要隐式转换为 int（进行大量的 static_casting 会很烦人）并且我们不需要额外的命名空间。

### 简化范围枚举器到整数的转换（高级）

范围枚举很棒，但缺少隐式转换为整数的功能有时会成为痛点。如果我们需要经常将范围枚举转换为整数（例如，我们想将范围枚举用作数组索引的情况），那么每次需要转换时都必须使用 static_cast ，这会严重扰乱我们的代码。

如果您发现自己处于一种需要更容易地将范围枚举器转换为整数的情况，那么一个有用的方法是重载一元运算`operator+`符来执行此转换：

```c++
#include <iostream>
#include <type_traits> // for std::underlying_type_t

enum class Animals
{
    chicken, // 0
    dog, // 1
    cat, // 2
    elephant, // 3
    duck, // 4
    snake, // 5

    maxAnimals,
};

// Overload the unary + operator to convert Animals to the underlying type
// adapted from https://stackoverflow.com/a/42198760, thanks to Pixelchemist for the idea
// In C++23, you can #include <utility> and return std::to_underlying(a) instead
constexpr auto operator+(Animals a) noexcept
{
    return static_cast<std::underlying_type_t<Animals>>(a);
}

int main()
{
    std::cout << +Animals::elephant << '\n'; // convert Animals::elephant to an integer using unary operator+

    return 0;
}
```

此方法可防止意外的隐式转换为整数类型，但提供了一种根据需要明确请求此类转换的便捷方法。

### `using enum`语句

C++20 中引入了一条语句，该`using enum`语句将枚举中的所有枚举器导入到当前作用域中。当与枚举类类型一起使用时，这使我们能够访问枚举类枚举器，而无需在每个枚举类枚举器前面加上枚举类的名称。

这在我们有许多相同、重复的前缀的情况下很有用，例如在 switch 语句中：

```c++
#include <iostream>
#include <string_view>

enum class Color
{
    black,
    red,
    blue,
};

constexpr std::string_view getColor(Color color)
{
    using enum Color; // bring all Color enumerators into current scope (C++20)
    // We can now access the enumerators of Color without using a Color:: prefix

    switch (color)
    {
    case black: return "black"; // note: black instead of Color::black
    case red:   return "red";
    case blue:  return "blue";
    default:    return "???";
    }
}

int main()
{
    Color shirt{ Color::blue };

    std::cout << "Your shirt is " << getColor(shirt) << '\n';

    return 0;
}
```

在上面的例子中，`Color`是一个枚举类，所以我们通常会使用完全限定名称（例如`Color::blue`）来访问枚举器。然而，在函数中`getColor()`，我们添加了语句`using enum Color;`，它允许我们在没有前缀的情况下访问这些枚举器`Color::`。

这使得我们避免在 switch 语句中使用多个冗余、明显的前缀。

### **测验**

问题 #1

定义一个名为 Animal 的枚举类，其中包含以下动物：猪、鸡、山羊、猫、狗、鸭。编写一个名为 getAnimalName() 的函数，该函数接受一个 Animal 参数并使用 switch 语句将该动物的名称作为 std::string_view（或 std::string，如果您使用的是 C++14）返回。编写另一个名为 printNumberOfLegs() 的函数，该函数使用 switch 语句打印每只动物行走的腿数。确保这两个函数都有一个打印错误消息的默认情况。使用一只猫和一只鸡从 main() 调用 printNumberOfLegs()。您的输出应如下所示：

```c++
猫有四条腿。
一只鸡有两条腿。
```

```c++
#include <iostream>
#include <string_view> // C++17
//#include <string> // for C++14

enum class Animal
{
    pig,
    chicken,
    goat,
    cat,
    dog,
    duck,
};

constexpr std::string_view getAnimalName(Animal animal) // C++17
// const std::string getAnimalName(Animal animal) // C++14
{
    // If C++20 capable, could use `using enum Animal` here to reduce Animal prefix redundancy
    switch (animal)
    {
        case Animal::chicken:
            return "chicken";
        case Animal::duck:
            return "duck";
        case Animal::pig:
            return "pig";
        case Animal::goat:
            return "goat";
        case Animal::cat:
            return "cat";
        case Animal::dog:
            return "dog";

        default:
            return "???";
    }
}

void printNumberOfLegs(Animal animal)
{
    std::cout << "A " << getAnimalName(animal) << " has ";

    // If C++20 capable, could use `using enum Animal` here to reduce Animal prefix redundancy
    switch (animal)
    {
        case Animal::chicken:
        case Animal::duck:
            std::cout << 2;
            break;

        case Animal::pig:
        case Animal::goat:
        case Animal::cat:
        case Animal::dog:
            std::cout << 4;
            break;

        default:
            std::cout << "???";
            break;
    }

    std::cout << " legs.\n";
}

int main()
{
    printNumberOfLegs(Animal::cat);
    printNumberOfLegs(Animal::chicken);

    return 0;
}
```

## 13.7 — 结构体、成员和成员选择简介

在编程中，有很多情况下我们需要多个变量来表示感兴趣的内容。正如我们在上一章的介绍中讨论的那样（[12.1-复合数据类型简介](https://www.learncpp.com/cpp-tutorial/introduction-to-compound-data-types/)），分数有一个分子和分母，它们链接在一起形成一个数学对象。

或者，假设我们想编写一个程序，需要存储公司员工的信息。我们可能有兴趣跟踪员工的姓名、职称、年龄、员工 ID、经理 ID、工资、生日、雇用日期等属性……

如果我们使用独立变量来追踪所有这些信息，可能看起来像这样：

```c++
std::string name;
std::string title;
int age;
int id;
int managerId;
double wage;
int birthdayYear;
int birthdayMonth;
int birthdayDay;
int hireYear;
int hireMonth;
int hireDay;
```

但是，这种方法存在许多问题。首先，无法立即确定这些变量是否真正相关（您必须阅读注释，或查看它们在上下文中的使用方式）。其次，现在有 12 个变量需要管理。如果我们想将这个员工传递给一个函数，我们必须传递 12 个参数（并且要按正确的顺序传递），这会弄乱我们的函数原型和函数调用。而且由于函数只能返回一个值，函数如何返回员工呢？

如果我们想要多个员工，我们需要为每个额外的员工定义 12 个变量（每个变量都需要一个唯一的名称）！这显然根本无法扩展。我们真正需要的是某种方式将所有这些相关的数据组织在一起，使它们更易于管理。

幸运的是，C++ 提供了两种复合类型来解决此类挑战：结构（我们现在将介绍）和类（我们稍后将探讨）。结构**（****structure**的缩写）是一种程序定义的数据类型（[13.1——程序定义（用户定义）类型简介](https://www.learncpp.com/cpp-tutorial/introduction-to-program-defined-user-defined-types/)），它允许我们将多个变量捆绑在一起形成一个类型。正如您即将看到的那样，这使得相关变量集的管理变得更加简单！

**提醒：**结构体是一种类类型（类和联合也是）。因此，适用于类类型的任何内容也适用于结构体。

### **定义结构体**

因为结构体是程序定义的类型，所以我们首先必须告诉编译器我们的结构体类型是什么样的，然后才能开始使用它。以下是简化员工结构体定义的示例：

```c++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};
```

该`struct`关键字用于告诉编译器我们正在定义一个已命名的结构`Employee`（因为程序定义的类型的名称通常以大写字母开头）。

然后，在一对花括号内，我们定义每个 Employee 对象将包含的变量。在此示例中，`Employee`我们创建的每个对象将有 3 个变量： an `int id`、 an`int age`和 a `double wage`。结构体中的变量称为**数据成员**（或**成员变量**）。

**提示**

<u>在日常用语中，*成员*是指属于某个群体的个人。例如，你可能是篮球队的成员，而你的妹妹可能是合唱团的成员。</u>

<u>在 C++ 中，**成员**是属于结构（或类）的变量、函数或类型。所有成员都必须在结构（或类）定义中声明。</u>

<u>我们将在以后的课程中多次使用*“成员”*这个术语，因此请确保记住它的含义。</u>

就像我们使用一组空花括号来初始化（[1.4 -- 变量赋值和初始化](https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/)）普通变量一样，每个成员变量后面的空花括号可确保`Employee`在创建时初始化我们内部的成员变量的值。我们将在几节课中介绍默认成员初始化时（ [13.9 -- 默认成员初始化](https://www.learncpp.com/cpp-tutorial/default-member-initialization/)）`Employee`对此进行更多讨论。

最后，我们用分号结束类型定义。

提醒一下，`Employee`这只是一种类型定义——此时实际上并没有创建任何对象。

### **定义结构对象**

为了使用该`Employee`类型，我们只需定义一个类型的变量`Employee`：

```c++
Employee joe {}; // Employee is the type, joe is the variable name
```

`Employee`这定义了一个名为的变量`joe`。执行代码时，将实例化一个包含 3 个数据成员的 Employee 对象。空括号确保我们的对象已进行值初始化。

与任何其他类型一样，可以定义同一结构类型的多个变量：

```c++
Employee joe {}; // create an Employee struct for Joe
Employee frank {}; // create an Employee struct for Frank
```

### 访问成员

请考虑以下示例：

```c++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe {};

    return 0;
}
```

在上面的例子中，名称`joe`指的是整个结构体对象（其中包含成员变量）。要访问特定的成员变量，我们在结构体变量名称和成员名称之间使用**成员选择运算符**( `operator.`)。例如，要访问 Joe 的 age 成员，我们将使用`joe.age`。

结构体成员变量的工作方式与普通变量一样，因此可以对其进行正常操作，包括赋值、算术、比较等……

```c++
#include <iostream>

struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe {};

    joe.age = 32;  // use member selection operator (.) to select the age member of variable joe

    std::cout << joe.age << '\n'; // print joe's age

    return 0;
}
```

结构体的最大优点之一是我们只需要为每个结构体变量创建一个新名称（成员名称作为结构体类型定义的一部分是固定的）。在下面的例子中，我们实例化了两个`Employee`对象：`joe`和`frank`。

```c++
#include <iostream>

struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe {};
    joe.id = 14;
    joe.age = 32;
    joe.wage = 60000.0;

    Employee frank {};
    frank.id = 15;
    frank.age = 28;
    frank.wage = 45000.0;

    int totalAge { joe.age + frank.age };
    std::cout << "Joe and Frank have lived " << totalAge << " total years\n";

    if (joe.wage > frank.wage)
        std::cout << "Joe makes more than Frank\n";
    else if (joe.wage < frank.wage)
        std::cout << "Joe makes less than Frank\n";
    else
        std::cout << "Joe and Frank make the same amount\n";

    // Frank got a promotion
    frank.wage += 5000.0;

    // Today is Joe's birthday
    ++joe.age; // use pre-increment to increment Joe's age by 1

    return 0;
}
```

在上面的例子中，很容易分辨出哪些成员变量属于 Joe，哪些属于 Frank。这提供了比单个变量更高级别的组织。此外，由于 Joe 和 Frank 的成员具有相同的名称，因此当您拥有多个相同结构类型的变量时，这可以提供一致性。

## 13.8 — 结构聚合初始化

在上一课（[13.7 -- 结构体、成员和成员选择简介](https://www.learncpp.com/cpp-tutorial/introduction-to-structs-members-and-member-selection/)）中，我们讨论了如何定义结构体、实例化结构体对象以及访问其成员。在本课中，我们将讨论如何初始化结构体。

### 数据成员默认未初始化

与普通变量非常相似，数据成员默认不初始化。考虑以下结构：

```c++
#include <iostream>

struct Employee
{
    int id; // note: no initializer here
    int age;
    double wage;
};

int main()
{
    Employee joe; // note: no initializer here either
    std::cout << joe.id << '\n';

    return 0;
}
```

因为我们没有提供任何初始化器，所以当`joe`实例化时`joe.id`，、`joe.age`和`joe.wage`都将未初始化。然后当我们尝试打印的值时，我们将得到未定义的行为`joe.id`。

但是，在我们向您展示如何初始化结构之前，让我们先稍微绕一下弯路。

### 什么是聚合？

在一般编程中，**聚合数据类型**（也称为**聚合**）是可以包含多个数据成员的任何类型。某些类型的聚合允许成员具有不同的类型（例如结构），而其他类型的聚合则要求所有成员必须是单一类型（例如数组）。

在 C++ 中，聚合的定义更窄并且相当复杂。

**注：**在本教程系列中，当我们使用术语“聚合”（或“非聚合”）时，我们指的是聚合的 C++ 定义。

**对于高级读者**

<u>为了简单起见，C++ 中的聚合要么是 C 样式的数组（[17.7--C 样式数组简介](https://www.learncpp.com/cpp-tutorial/introduction-to-c-style-arrays/)），要么是具有以下内容的类类型（结构体、类或联合）：</u>

- <u>没有用户声明的构造函数（[14.9--构造函数简介](https://www.learncpp.com/cpp-tutorial/introduction-to-constructors/)）</u>
- <u>没有私有或受保护的非静态数据成员（[14.5--公共和私有成员以及访问说明符](https://www.learncpp.com/cpp-tutorial/public-and-private-members-and-access-specifiers/)）</u>
- <u>无虚函数（[25.2--虚函数和多态性](https://www.learncpp.com/cpp-tutorial/virtual-functions/)）</u>

<u>流行的类型`std::array`（[17.1--std::array 简介](https://www.learncpp.com/cpp-tutorial/introduction-to-stdarray/)）也是一个聚合体。</u>

<u>[您可以在此处](https://en.cppreference.com/w/cpp/language/aggregate_initialization)找到 C++ 聚合的精确定义。</u>

此时要理解的关键是：仅具有数据成员的结构是聚合。

### **结构的聚合初始化**

因为普通变量只能保存一个值，所以我们只需要提供一个初始化程序：

```c++
int x { 5 };
```

但是，一个结构体可以有多个成员：

```c++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};
```

当我们定义具有结构类型的对象时，我们需要某种方式在初始化时初始化多个成员：

```c++
Employee joe; // how do we initialize joe.id, joe.age, and joe.wage?
```

**聚合使用一种称为聚合初始化**的初始化形式，它允许我们直接初始化聚合的成员。为此，我们提供了一个**初始化列表**作为初始化器，它只是一个用逗号分隔的值的括号列表。

聚合初始化有两种主要形式：

```c++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee frank = { 1, 32, 60000.0 }; // copy-list initialization using braced list
    Employee joe { 2, 28, 45000.0 };     // list initialization using braced list (preferred)

    return 0;
}
```

这些初始化形式中的每一种都进行**逐个成员初始化**，这意味着结构中的每个成员都按照声明的顺序进行初始化。因此，`Employee joe { 2, 28, 45000.0 };`首先`joe.id`用值初始化`2`，然后`joe.age`用值初始化`28`，最后`joe.wage`用值`45000.0`初始化。

**最佳实践**

<u>初始化聚合时优先使用（非复制）支撑列表形式。</u>

在 C++20 中，我们还可以使用带括号的值列表来初始化（一些）聚合：

```c++
Employee robert ( 3, 45, 62500.0 );  // direct initialization using parenthesized list (C++20)
```

我们建议尽可能避免使用最后一种形式，因为它目前不适用于利用括号省略的聚合（尤其是`std::array`）。

### **初始化列表中缺少初始化项**

如果初始化聚合但初始化值的数量少于成员的数量，则所有剩余成员将使用空的初始化列表进行初始化。在大多数情况下，这将对这些成员执行值初始化。

```c++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe { 2, 28 }; // joe.wage will be value-initialized to 0.0

    return 0;
}
```

在上面的例子中，`joe.id`将用值进行初始化，`2` `joe.age`将用值进行初始化`28`，并且因为`joe.wage`没有给出显式的初始化器，它将被值初始化为`0.0`。

这意味着我们通常可以使用一个空的初始化列表来对结构的所有成员进行值初始化：

```c++
Employee joe {}; // value-initialize all members
```

### 重载`operator<<`以打印结构体

在第 13.5 课[- I/O 运算符重载简介](https://www.learncpp.com/cpp-tutorial/introduction-to-overloading-the-i-o-operators/)中，我们展示了如何重载以打印枚举器。重载结构`operator<<`也很有用。`operator<<`

下面是与上一节相同的例子，但现在重载了`operator<<`：

```c++
#include <iostream>

struct Employee
{
    int id {};
    int age {};
    double wage {};
};

std::ostream& operator<<(std::ostream& out, const Employee& e)
{
    out << e.id << ' ' << e.age << ' ' << e.wage;
    return out;
}

int main()
{
    Employee joe { 2, 28 }; // joe.wage will be value-initialized to 0.0
    std::cout << joe << '\n';

    return 0;
}
```

我们可以看到，`joe.wage`值确实被初始化为`0.0`。

与枚举不同，结构可以有多个成员——如何格式化结构的输出完全取决于您。请注意，`operator<<`上面的重载输出的三个值并不直观——这些值是什么意思？

让我们做同样的例子，但更新我们的输出函数以使其更具描述性：

```c++
#include <iostream>

struct Employee
{
    int id {};
    int age {};
    double wage {};
};

std::ostream& operator<<(std::ostream& out, const Employee& e)
{
    out << "id: " << e.id << " age: " << e.age << " wage: " << e.wage;
    return out;
}

int main()
{
    Employee joe { 2, 28 }; // joe.wage will be value-initialized to 0.0
    std::cout << joe << '\n';

    return 0;
}
```

![image-20241020111945994](./assets/image-20241020111945994.png)

### **Const 结构**

结构类型的变量可以是 const（或 constexpr），并且与所有 const 变量一样，它们必须被初始化。

```c++
struct Rectangle
{
    double length {};
    double width {};
};

int main()
{
    const Rectangle unit { 1.0, 1.0 };
    const Rectangle zero { }; // value-initialize all members

    return 0;
}
```

### 指定初始化程序C++20

从值列表初始化结构时，初始化器将按照声明的顺序应用于成员。

```c++
struct Foo
{
    int a {};
    int c {};
};

int main()
{
    Foo f { 1, 3 }; // f.a = 1, f.c = 3

    return 0;
}
```

现在考虑一下如果更新此结构定义以添加不是最后一个成员的新成员会发生什么：

```c++
struct Foo
{
    int a {};
    int b {}; // just added
    int c {};
};

int main()
{
    Foo f { 1, 3 }; // now, f.a = 1, f.b = 3, f.c = 0

    return 0;
}
```

现在，所有初始化值都已发生改变，更糟糕的是，编译器可能不会将其检测为错误（毕竟语法仍然有效）。

为了避免这种情况，C++20 添加了一种新的初始化结构成员的方法，称为**指定初始化器**。指定初始化器允许您明确定义哪些初始化值映射到哪些成员。可以使用列表或复制初始化来初始化成员，并且必须按照在结构中声明它们的顺序进行初始化，否则将导致警告或错误。未指定初始化器的成员将进行值初始化。

```c++
struct Foo
{
    int a{ };
    int b{ };
    int c{ };
};

int main()
{
    Foo f1{ .a{ 1 }, .c{ 3 } }; // ok: f1.a = 1, f1.b = 0 (value initialized), f1.c = 3
    Foo f2{ .a = 1, .c = 3 };   // ok: f2.a = 1, f2.b = 0 (value initialized), f2.c = 3
    Foo f3{ .b{ 2 }, .a{ 1 } }; // error: initialization order does not match order of declaration in struct

    return 0;
}
```

指定初始化器很不错，因为它们提供了一定程度的自文档性，并有助于确保您不会无意中混淆初始化值的顺序。但是，指定初始化器也会使初始化器列表变得非常混乱，因此我们目前不建议将其用作最佳实践。

此外，由于没有强制要求在初始化聚合的所有地方一致使用指定的初始化程序，因此最好避免在现有聚合定义的中间添加新成员，以避免初始化程序转移的风险。

**最佳实践：**向聚合添加新成员时，最安全的做法是将其添加到定义列表的底部，以便其他成员的初始化程序不会发生变化。

### 使用初始化列表进行赋值

如上一课所示，我们可以单独为结构体的成员赋值：

```c++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe { 1, 32, 60000.0 };

    joe.age  = 33;      // Joe had a birthday
    joe.wage = 66000.0; // and got a raise

    return 0;
}
```

对于单个成员来说，这很好，但当我们想要更新许多成员时，这并不好。与使用初始化列表初始化结构类似，您也可以使用初始化列表（执行成员赋值）为结构赋值：

```c++
struct Employee
{
    int id {};
    int age {};
    double wage {};
};

int main()
{
    Employee joe { 1, 32, 60000.0 };
    joe = { joe.id, 33, 66000.0 }; // Joe had a birthday and got a raise

    return 0;
}
```

请注意，因为我们不想更改`joe.id`，所以我们需要将`joe.id`列表中的当前值作为占位符提供，以便成员赋值可以分配`joe.id`给`joe.id`。这有点丑陋。

### **使用相同类型的另一个结构初始化一个结构**

也可以使用相同类型的另一个结构来初始化结构：

```c++
#include <iostream>

struct Foo
{
    int a{};
    int b{};
    int c{};
};

std::ostream& operator<<(std::ostream& out, const Foo& f)
{
    out << f.a << ' ' << f.b << ' ' << f.c;
    return out;
}

int main()
{
    Foo foo { 1, 2, 3 };

    Foo x = foo; // copy-initialization
    Foo y(foo);  // direct-initialization
    Foo z {foo}; // direct-list-initialization

    std::cout << x << '\n';
    std::cout << y << '\n';
    std::cout << z << '\n';

    return 0;
}
```

请注意，这使用了我们熟悉的标准初始化形式（复制、直接或直接列表初始化）而不是聚合初始化。

最常见的情况是使用返回相同类型结构的函数的返回值初始化结构。我们将在第[13.10 课“传递和返回结构”](https://www.learncpp.com/cpp-tutorial/passing-and-returning-structs/)中更详细地介绍这一点。