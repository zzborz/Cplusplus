# 21.1 — 运算符重载简介

在课程[11.1 — 函数重载简介](https://www.learncpp.com/cpp-tutorial/introduction-to-function-overloading/)中，您了解了函数重载，它提供了一种机制来创建和解析对具有相同名称的多个函数的函数调用，只要每个函数都有唯一的函数原型。这允许您创建函数的变体以处理不同的数据类型，而不必为每个变体想出一个唯一的名称。

在 C++ 中，运算符以函数形式实现。通过在运算符函数上使用函数重载，您可以定义自己的运算符版本，以处理不同的数据类型（包括您编写的类）。使用函数重载来重载运算符称为**运算符重载**。

在本章中，我们将研究与运算符重载相关的主题。

## **运算符作为函数**

请考虑以下示例：

```cpp
int x { 2 };
int y { 3 };
std::cout << x + y << '\n';
```

编译器自带了用于整数操作数的加法运算符 (+) 的内置版本——此函数将整数 x 和 y 相加并返回整数结果。看到表达式时`x + y`，您可以在脑海中将其转换为函数调用`operator+(x, y)`（其中，operator+ 是函数的名称）。

现在考虑这个类似的代码片段：

```cpp
double z { 2.0 };
double w { 3.0 };
std::cout << w + z << '\n';
```

编译器还附带了用于双精度操作数的加法运算符 (+) 的内置版本。表达式 w + z 变为函数调用`operator+(w, z)`，函数重载用于确定编译器应调用此函数的双精度版本，而不是整数版本。

现在考虑一下如果我们尝试添加程序定义类的两个对象会发生什么：

```cpp
Mystring string1 { "Hello, " };
Mystring string2 { "World!" };
std::cout << string1 + string2 << '\n';
```

在这种情况下，你希望发生什么？直观的预期结果是字符串“Hello, World!”将打印在屏幕上。但是，由于 Mystring 是程序定义的类型，因此编译器没有可用于 Mystring 操作数的内置版本的加法运算符。因此在这种情况下，它会给我们一个错误。为了使其按我们想要的方式工作，我们需要编写一个重载函数来告诉编译器 + 运算符应如何与两个 Mystring 类型的操作数一起工作。我们将在下一课中讨论如何做到这一点。

## **解决重载运算符**

在评估包含运算符的表达式时，编译器使用以下规则：

- 如果*所有*操作数都是基本数据类型，则编译器将调用内置例程（如果存在）。如果不存在内置例程，则编译器将产生编译器错误。
- 如果*任何*操作数是程序定义类型（例如，您的某个类或枚举类型），则编译器将使用函数重载解析算法（在课程[11.3 -- 函数重载解析和模糊匹配](https://www.learncpp.com/cpp-tutorial/function-overload-resolution-and-ambiguous-matches/)中描述）来查看是否可以找到一个无歧义的最佳匹配重载运算符。这可能涉及隐式转换一个或多个操作数以匹配重载运算符的参数类型。它还可能涉及隐式将程序定义类型转换为基本类型（通过重载类型转换，我们将在本章后面介绍），以便它可以匹配内置运算符。如果找不到匹配项（或找到模糊匹配项），则编译器将出错。

## **运算符重载有哪些限制？**

首先，C++ 中几乎所有现有的运算符都可以重载。例外情况包括：条件 (?:)、sizeof、作用域 (::)、成员选择器 (.)、指针成员选择器 (.*)、typeid 和强制类型转换运算符。

其次，您只能重载现有的运算符。您不能创建新的运算符或重命名现有的运算符。例如，您不能创建一个`operator**`用于执行指数的运算符。

第三，重载运算符中的至少一个操作数必须是用户定义类型。这意味着你可以重载`operator+(int, Mystring)`，但不能重载`operator+(int, double)`。

由于标准库类被视为用户定义的，这意味着您可以定义`operator+(double, std::string)`。但是，这不是一个好主意，因为未来的语言标准可能会定义此重载，这可能会破坏使用您的重载的任何程序。因此，最佳做法是您的重载运算符应至少对一种程序定义的类型进行操作。这保证了未来的语言标准不会破坏您的程序。

**最佳实践**

**重载运算符应该至少对一种程序定义类型进行操作（作为函数的参数或隐式对象）。**

第四，无法改变运算符支持的操作数的数量。

最后，所有运算符都保留其默认优先级和结合性（无论其用于什么），并且无法改变。

一些新程序员尝试重载按位异或运算符 (^) 来执行幂运算。然而，在 C++ 中，运算符 ^ 的优先级低于基本算术运算符，这会导致表达式求值不正确。

在基础数学中，指数运算在基本算术之前解析，因此 4 + 3 ^ 2 解析为 4 + (3 ^ 2) => 4 + 9 => 13。
但是在 C++ 中，算术运算符的优先级高于运算符 ^，因此 4 + 3 ^ 2 解析为 (4 + 3) ^ 2 => 7 ^ 2 => 49。

每次使用时，您都需要明确地将指数部分（例如 4 + (3 ^ 2)）括起来以使其正常工作，这并不直观，并且容易出错。

由于这个优先级问题，通常最好仅以类似于其原始意图的方式使用运算符。

**最佳实践**

**在重载运算符的时候，最好让运算符的功能尽可能的接近运算符的原始意图。**

此外，由于运算符没有描述性名称，因此它们的用途并不总是很清楚。例如，对于字符串类来说，operator+ 可能是执行字符串连接的合理选择。但是 operator- 呢？你希望它做什么？这不清楚。

**最佳实践**

**如果重载运算符的含义不清晰且不直观，请改用命名函数。**

最后，重载运算符应以与原始运算符一致的方式返回值。不修改其操作数的运算符（例如算术运算符）通常应按值返回结果。修改其最左操作数的运算符（例如预增量、任何赋值运算符）通常应按引用返回最左操作数。

**最佳实践**

**不修改操作数的运算符（例如算术运算符）通常应按值返回结果。**

修改其最左边操作数的运算符（例如预增、任何赋值运算符）通常应通过引用返回最左边的操作数。

在这些限制内，您仍会发现许多有用的功能可以为您的自定义类重载！您可以重载 + 运算符来连接程序定义的字符串类，或将两个 Fraction 类对象加在一起。您可以重载 << 运算符，以便轻松地将您的类打印到屏幕（或文件）。您可以重载相等运算符 (==) 来比较两个类对象。这使得运算符重载成为 C++ 中最有用的功能之一——因为它允许您以更直观的方式处理类。

# 21.2 — 使用友元函数重载算术运算符

C++ 中最常用的运算符是算术运算符，即加法运算符 (+)、减法运算符 (-)、乘法运算符 (*) 和除法运算符 (/)。请注意，所有算术运算符都是二元运算符，这意味着它们需要两个操作数，即运算符两侧各一个。所有这四个运算符都以完全相同的方式重载。

事实证明，重载运算符有三种不同的方法：成员函数方法、友元函数方法和普通函数方法。在本课中，我们将介绍友元函数方法（因为它对于大多数二元运算符来说更直观）。下一课，我们将讨论普通函数方法。最后，在本章的后面一课中，我们将介绍成员函数方法。当然，我们还将更详细地总结何时使用每种方法。

## 使用友元函数重载运算符

考虑以下类：

```cpp
class Cents
{
private:
	int m_cents {};

public:
	Cents(int cents) : m_cents{ cents } { }
	int getCents() const { return m_cents; }
};
```

下面的例子展示了如何重载加号运算符 (+) 来将两个“Cents”对象加在一起：

```cpp
#include <iostream>

class Cents
{
private:
	int m_cents {};

public:
	Cents(int cents) : m_cents{ cents } { }

	// add Cents + Cents using a friend function
	friend Cents operator+(const Cents& c1, const Cents& c2);

	int getCents() const { return m_cents; }
};

// note: this function is not a member function!
Cents operator+(const Cents& c1, const Cents& c2)
{
	// use the Cents constructor and operator+(int, int)
	// we can access m_cents directly because this is a friend function
	return c1.m_cents + c2.m_cents;
}

int main()
{
	Cents cents1{ 6 };
	Cents cents2{ 8 };
	Cents centsSum{ cents1 + cents2 };
	std::cout << "I have " << centsSum.getCents() << " cents.\n";

	return 0;
}
```

得出的结果是：

```
I have 14 cents.
```

重载加法运算符（+）很简单，只需声明一个名为 operator+ 的函数，给它两个我们要添加的操作数类型的参数，选择一个合适的返回类型，然后编写该函数即可。

在我们的 Cents 对象中，实现我们的 operator+() 函数非常简单。首先，参数类型：在此版本的 operator+ 中，我们将把两个 Cents 对象相加，因此我们的函数将采用两个 Cents 类型的对象。其次，返回类型：我们的 operator+ 将返回 Cents 类型的结果，因此这就是我们的返回类型。

最后，实现：要将两个 Cents 对象相加，我们实际上需要从每个 Cents 对象中添加 m_cents 成员。由于我们的重载 operator+() 函数是类的友元，因此我们可以直接访问参数的 m_cents 成员。此外，由于 m_cents 是一个整数，并且 C++ 知道如何使用内置版本的加法运算符（适用于整数操作数）将整数相加，因此我们可以简单地使用 + 运算符进行加法。

重载减法运算符（-）也很简单：

```cpp
#include <iostream>

class Cents
{
private:
	int m_cents {};

public:
	explicit Cents(int cents) : m_cents{ cents } { }

	// add Cents + Cents using a friend function
	friend Cents operator+(const Cents& c1, const Cents& c2);

	// subtract Cents - Cents using a friend function
	friend Cents operator-(const Cents& c1, const Cents& c2);

	int getCents() const { return m_cents; }
};

// note: this function is not a member function!
Cents operator+(const Cents& c1, const Cents& c2)
{
	// use the Cents constructor and operator+(int, int)
	// we can access m_cents directly because this is a friend function
	return Cents { c1.m_cents + c2.m_cents };
}

// note: this function is not a member function!
Cents operator-(const Cents& c1, const Cents& c2)
{
	// use the Cents constructor and operator-(int, int)
	// we can access m_cents directly because this is a friend function
	return Cents { c1.m_cents - c2.m_cents };
}

int main()
{
	Cents cents1{ 6 };
	Cents cents2{ 2 };
	Cents centsSum{ cents1 - cents2 };
	std::cout << "I have " << centsSum.getCents() << " cents.\n";

	return 0;
}
```

`operator*`重载乘法运算符（*）和除法运算符（/）就像分别为和定义函数一样简单`operator/`。

## 友元函数可以在类内部定义

即使友元函数不是类的成员，但如果需要，它们仍然可以在类内部定义：

```cpp
#include <iostream>

class Cents
{
private:
	int m_cents {};

public:
	explicit Cents(int cents) : m_cents{ cents } { }

	// add Cents + Cents using a friend function
        // This function is not considered a member of the class, even though the definition is inside the class
	friend Cents operator+(const Cents& c1, const Cents& c2)
	{
		// use the Cents constructor and operator+(int, int)
		// we can access m_cents directly because this is a friend function
		return Cents { c1.m_cents + c2.m_cents };
	}

	int getCents() const { return m_cents; }
};

int main()
{
	Cents cents1{ 6 };
	Cents cents2{ 8 };
	Cents centsSum{ cents1 + cents2 };
	std::cout << "I have " << centsSum.getCents() << " cents.\n";

	return 0;
}
```

对于具有简单实现的重载运算符来说，这很好。

## 为不同类型的操作数重载运算符

通常情况下，您希望重载运算符能够处理不同类型的操作数。例如，如果我们有 Cents(4)，我们可能希望将整数 6 添加到其中以产生结果 Cents(10)。

当 C++ 计算表达式 时`x + y`，x 成为第一个参数，y 成为第二个参数。当 x 和 y 具有相同的类型时，无论添加 x + y 还是 y + x 都没有关系——无论哪种方式，都会调用相同版本的运算符 +。但是，当操作数具有不同的类型时，x + y 不会调用与 y + x 相同的函数。

例如，`Cents(4) + 6`将调用 operator+(Cents, int)，并将`6 + Cents(4)`调用 operator+(int, Cents)。因此，每当我们为不同类型的操作数重载二元运算符时，我们实际上都需要编写两个函数——每个案例一个。以下是一个例子：

```cpp
#include <iostream>

class Cents
{
private:
	int m_cents {};

public:
	explicit Cents(int cents) : m_cents{ cents } { }

	// add Cents + int using a friend function
	friend Cents operator+(const Cents& c1, int value);

	// add int + Cents using a friend function
	friend Cents operator+(int value, const Cents& c1);


	int getCents() const { return m_cents; }
};

// note: this function is not a member function!
Cents operator+(const Cents& c1, int value)
{
	// use the Cents constructor and operator+(int, int)
	// we can access m_cents directly because this is a friend function
	return Cents { c1.m_cents + value };
}

// note: this function is not a member function!
Cents operator+(int value, const Cents& c1)
{
	// use the Cents constructor and operator+(int, int)
	// we can access m_cents directly because this is a friend function
	return Cents { c1.m_cents + value };
}

int main()
{
	Cents c1{ Cents{ 4 } + 6 };
	Cents c2{ 6 + Cents{ 4 } };

	std::cout << "I have " << c1.getCents() << " cents.\n";
	std::cout << "I have " << c2.getCents() << " cents.\n";

	return 0;
}
```

请注意，两个重载函数具有相同的实现 - 这是因为它们执行相同的操作，只是以不同的顺序获取参数。

另一个例子

我们来看另一个例子：

```cpp
#include <iostream>

class MinMax
{
private:
	int m_min {}; // The min value seen so far
	int m_max {}; // The max value seen so far

public:
	MinMax(int min, int max)
		: m_min { min }, m_max { max }
	{ }

	int getMin() const { return m_min; }
	int getMax() const { return m_max; }

	friend MinMax operator+(const MinMax& m1, const MinMax& m2);
	friend MinMax operator+(const MinMax& m, int value);
	friend MinMax operator+(int value, const MinMax& m);
};

MinMax operator+(const MinMax& m1, const MinMax& m2)
{
	// Get the minimum value seen in m1 and m2
	int min{ m1.m_min < m2.m_min ? m1.m_min : m2.m_min };

	// Get the maximum value seen in m1 and m2
	int max{ m1.m_max > m2.m_max ? m1.m_max : m2.m_max };

	return MinMax { min, max };
}

MinMax operator+(const MinMax& m, int value)
{
	// Get the minimum value seen in m and value
	int min{ m.m_min < value ? m.m_min : value };

	// Get the maximum value seen in m and value
	int max{ m.m_max > value ? m.m_max : value };

	return MinMax { min, max };
}

MinMax operator+(int value, const MinMax& m)
{
	// calls operator+(MinMax, int)
	return m + value;
}

int main()
{
	MinMax m1{ 10, 15 };
	MinMax m2{ 8, 11 };
	MinMax m3{ 3, 12 };

	MinMax mFinal{ m1 + m2 + 5 + 8 + m3 + 16 };

	std::cout << "Result: (" << mFinal.getMin() << ", " <<
		mFinal.getMax() << ")\n";

	return 0;
}
```

MinMax 类会跟踪迄今为止所见的最小值和最大值。我们重载了 3 次 + 运算符，以便我们可以将两个 MinMax 对象相加，或者将整数添加到 MinMax 对象。

此示例产生的结果：

```
结果：（3，16）
```

您会注意到这是我们添加到 mFinal 的最小值和最大值。

让我们再多谈谈“MinMax mFinal { m1 + m2 + 5 + 8 + m3 + 16 }”如何求值。请记住，operator+ 从左到右求值，因此 m1 + m2 首先求值。这变为对 operator+(m1, m2) 的调用，它产生返回值 MinMax(8, 15)。然后 MinMax(8, 15) + 5 接下来求值。这变为对 operator+(MinMax(8, 15), 5) 的调用，它产生返回值 MinMax(5, 15)。然后 MinMax(5, 15) + 8 以相同的方式求值以产生 MinMax(5, 15)。然后 MinMax(5, 15) + m3 求值以产生 MinMax(3, 15)。最后，MinMax(3, 15) + 16 求值为 MinMax(3, 16)。然后，此最终结果用于初始化 mFinal。

换句话说，该表达式的计算结果为“MinMax mFinal = (((((m1 + m2) + 5) + 8) + m3) + 16)”，每个连续操作都会返回一个 MinMax 对象，该对象成为下一个运算符的左边操作数。

使用其他运算符实现运算符

在上面的例子中，请注意，我们通过调用 operator+(MinMax, int)（产生相同的结果）来定义 operator+(int, MinMax)。这使我们能够将 operator+(int, MinMax) 的实现缩减为一行，通过最大限度地减少冗余并使函数更易于理解，使我们的代码更易于维护。

通常可以通过调用其他重载运算符来定义重载运算符。如果这样做会产生更简单的代码，则应该这样做。在实现很简单（例如一行代码）的情况下，这样做可能值得，也可能不值得。

## 测验时间

### 问题 #1

a) 编写一个名为 Fraction 的类，该类具有整数分子和分母成员。编写一个 print() 函数打印出分数。

以下代码应该可以编译：

```cpp
#include <iostream>

int main()
{
    Fraction f1{ 1, 4 };
    f1.print();

    Fraction f2{ 1, 2 };
    f2.print();

    return 0;
}
```

这应该打印：

```
1/4 
1/2
```

```cpp
#include <iostream>

class Fraction
{
private:
	int m_numerator { 0 };
	int m_denominator { 1 };

public:
	explicit Fraction(int numerator, int denominator=1)
		: m_numerator{numerator}, m_denominator{denominator}
	{
	}

	void print() const
	{
		std::cout << m_numerator << '/' << m_denominator << '\n';
	}
};

int main()
{
	Fraction f1 {1, 4};
	f1.print();

	Fraction f2 {1, 2};
	f2.print();

	return 0;
}
```

b) 添加重载乘法运算符来处理分数与整数以及两个分数之间的乘法。使用友元函数方法。

提示：要将两个分数相乘，首先将两个分子相乘，然后将两个分母相乘。要将分数和整数相乘，将分数的分子乘以整数，分母保持不变。

以下代码应该可以编译：

```cpp
#include <iostream>

int main()
{
    Fraction f1{2, 5};
    f1.print();

    Fraction f2{3, 8};
    f2.print();

    Fraction f3{ f1 * f2 };
    f3.print();

    Fraction f4{ f1 * 2 };
    f4.print();

    Fraction f5{ 2 * f2 };
    f5.print();

    Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };
    f6.print();

    return 0;
}
```

这应该打印：

```
2/5 
3/8 
6/40 
4/5 
6/8 
6/24
```

```cpp
#include <iostream>

class Fraction
{
private:
	int m_numerator { 0 };
	int m_denominator { 1 };

public:
	explicit Fraction(int numerator, int denominator=1)
		: m_numerator{numerator}, m_denominator{denominator}
	{
	}

	// We don't want to pass by value, because copying is slow.
	// We can't and shouldn't pass by non-const reference, because then
	// our functions wouldn't work with r-values.
	friend Fraction operator*(const Fraction& f1, const Fraction& f2);
	friend Fraction operator*(const Fraction& f1, int value);
	friend Fraction operator*(int value, const Fraction& f1);

	void print() const
	{
		std::cout << m_numerator << '/' << m_denominator << '\n';
	}
};

Fraction operator*(const Fraction& f1, const Fraction& f2)
{
	return Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };
}

Fraction operator*(const Fraction& f1, int value)
{
	return Fraction { f1.m_numerator * value, f1.m_denominator };
}

Fraction operator*(int value, const Fraction& f1)
{
	return Fraction { f1 * value };
}

int main()
{
	Fraction f1{2, 5};
	f1.print();

	Fraction f2{3, 8};
	f2.print();

	Fraction f3{ f1 * f2 };
	f3.print();

	Fraction f4{ f1 * 2 };
	f4.print();

	Fraction f5{ 2 * f2 };
	f5.print();

	Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };
	f6.print();

	return 0;
}
```

c) 为什么如果我们使构造函数非显式化并且从以前的解决方案中删除整数乘法运算符，程序仍然能够正常工作？

```cpp
// Remove explicit from constructor
	Fraction(int numerator, int denominator=1)
		: m_numerator{numerator}, m_denominator{denominator}
	{
	}

// We can remove these operators, and the program continues to work
Fraction operator*(const Fraction& f1, int value);
Fraction operator*(int value, const Fraction& f1);
```



我们还有

```cpp
Fraction operator*(const Fraction& f1, const Fraction& f2)
```

例如，当我们将分数乘以整数时

```cpp
Fraction f5{ 2 * f2 };
```

非显式 Fraction(int, int) 构造函数将用于从 2 生成一个新的 Fraction，然后使用 Fraction * Fraction 运算符将这个新的 Fraction 与 f2 相乘。

因为这需要转换`2`为`Fraction`，所以这比使用整数乘法的重载运算符的实现稍微慢一些。



d) 如果我们把引用参数设为`operator*(Fraction, Fraction)`非常量，函数中的下面这一行`main`就不再起作用了。为什么？

```cpp
// The non-const multiplication operator looks like this
Fraction operator*(Fraction& f1, Fraction& f2)

// This doesn't work anymore
Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };
```

我们正在乘以临时的 Fraction 对象，但非常数引用不能绑定到临时对象。



e) 额外加分：分数 2/4 与 1/2 相同，但 2/4 不能化简为最简数。我们可以通过找到分子和分母之间的最大公约数 (GCD)，然后将分子和分母都除以 GCD，将任何给定分数化简为最简数。

`std::gcd()`已添加到 C++17 的标准库中（在 <numeric> 标头中）。

如果您使用的是较旧的编译器，则可以使用此函数来查找 GCD：

```cpp
#include <cmath> // for std::abs

int gcd(int a, int b) {
    return (b == 0) ? std::abs(a) : gcd(b, a % b);
}
```

编写一个名为 reduce() 的成员函数来减少分数。确保所有分数都正确减少。

以下内容应编译：

```cpp
#include <iostream>

int main()
{
    Fraction f1{2, 5};
    f1.print();

    Fraction f2{3, 8};
    f2.print();

    Fraction f3{ f1 * f2 };
    f3.print();

    Fraction f4{ f1 * 2 };
    f4.print();

    Fraction f5{ 2 * f2 };
    f5.print();

    Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };
    f6.print();

    Fraction f7{0, 6};
    f7.print();

    return 0;
}
```

并产生结果：

```
2/5 
3/8 
3/20 
4/5 
3/4 
1/4 
0/1
```

```cpp
#include <iostream>
#include <numeric> // for std::gcd

// This version of the Fraction class auto-reduces fractions
class Fraction
{
private:
	int m_numerator{ 0 };
	int m_denominator{ 1 };

public:
	explicit Fraction(int numerator, int denominator = 1)
		: m_numerator{ numerator }, m_denominator{ denominator }
	{
		// We put reduce() in the constructor to ensure any fractions we make get reduced!
		// Since all of the overloaded operators create new Fractions, we can guarantee this will get called here
		reduce();
	}

	void reduce()
	{
		int gcd{ std::gcd(m_numerator, m_denominator) };
		if (gcd) // Make sure we don't try to divide by 0
		{
			m_numerator /= gcd;
			m_denominator /= gcd;
		}
	}

	friend Fraction operator*(const Fraction& f1, const Fraction& f2);
	friend Fraction operator*(const Fraction& f1, int value);
	friend Fraction operator*(int value, const Fraction& f1);

	void print() const
	{
		std::cout << m_numerator << '/' << m_denominator << '\n';
	}
};

Fraction operator*(const Fraction& f1, const Fraction& f2)
{
	return Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };
}

Fraction operator*(const Fraction& f1, int value)
{
	return Fraction { f1.m_numerator * value, f1.m_denominator };
}

Fraction operator*(int value, const Fraction& f1)
{
	return Fraction { f1 * value };
}

int main()
{
	Fraction f1{ 2, 5 };
	f1.print();

	Fraction f2{ 3, 8 };
	f2.print();

	Fraction f3{ f1 * f2 };
	f3.print();

	Fraction f4{ f1 * 2 };
	f4.print();

	Fraction f5{ 2 * f2 };
	f5.print();

	Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };
	f6.print();

	Fraction f7{ 0, 6 };
	f7.print();

	return 0;
}
```

# 21.3 — 使用普通函数重载运算符

在上一课中，我们将 operator+ 重载为友元函数：

```cpp
#include <iostream>

class Cents
{
private:
  int m_cents{};

public:
  Cents(int cents)
    : m_cents{ cents }
  {}

  // add Cents + Cents using a friend function
  friend Cents operator+(const Cents& c1, const Cents& c2);

  int getCents() const { return m_cents; }
};

// note: this function is not a member function!
Cents operator+(const Cents& c1, const Cents& c2)
{
  // use the Cents constructor and operator+(int, int)
  // we can access m_cents directly because this is a friend function
  return { c1.m_cents + c2.m_cents };
}

int main()
{
  Cents cents1{ 6 };
  Cents cents2{ 8 };
  Cents centsSum{ cents1 + cents2 };
  std::cout << "I have " << centsSum.getCents() << " cents.\n";

  return 0;
}
```

使用友元函数重载运算符非常方便，因为它可以让您直接访问正在操作的类的内部成员。在上面的初始 Cents 示例中，我们的友元函数版本的 operator+ 直接访问了成员变量 m_cents。

但是，如果您不需要该访问权限，则可以将重载运算符编写为普通函数。请注意，上面的 Cents 类包含一个访问函数 (getCents())，它允许我们获取 m_cents，而无需直接访问私有成员。因此，我们可以将重载的 operator+ 编写为非友元：

```cpp
#include <iostream>

class Cents
{
private:
  int m_cents{};

public:
  Cents(int cents)
    : m_cents{ cents }
  {}

  int getCents() const { return m_cents; }
};

// note: this function is not a member function nor a friend function!
Cents operator+(const Cents& c1, const Cents& c2)
{
  // use the Cents constructor and operator+(int, int)
  // we don't need direct access to private members here
  return Cents{ c1.getCents() + c2.getCents() };
}

int main()
{
  Cents cents1{ 6 };
  Cents cents2{ 8 };
  Cents centsSum{ cents1 + cents2 };
  std::cout << "I have " << centsSum.getCents() << " cents.\n";

  return 0;
}
```

由于普通函数和友元函数的工作方式几乎相同（它们只是对私有成员的访问级别不同），因此我们通常不会区分它们。唯一的区别是类内部的友元函数声明也充当原型。对于普通函数版本，您必须提供自己的函数原型。

Cents.h：

```cpp
#ifndef CENTS_H
#define CENTS_H

class Cents
{
private:
  int m_cents{};

public:
  Cents(int cents)
    : m_cents{ cents }
  {}

  int getCents() const { return m_cents; }
};

// Need to explicitly provide prototype for operator+ so uses of operator+ in other files know this overload exists
Cents operator+(const Cents& c1, const Cents& c2);

#endif
```

Cents.cpp:

```cpp
#include "Cents.h"

// note: this function is not a member function nor a friend function!
Cents operator+(const Cents& c1, const Cents& c2)
{
  // use the Cents constructor and operator+(int, int)
  // we don't need direct access to private members here
  return { c1.getCents() + c2.getCents() };
}
```

main.cpp:

```cpp
#include "Cents.h"
#include <iostream>

int main()
{
  Cents cents1{ 6 };
  Cents cents2{ 8 };
  Cents centsSum{ cents1 + cents2 }; // without the prototype in Cents.h, this would fail to compile
  std::cout << "I have " << centsSum.getCents() << " cents.\n";

  return 0;
}
```

一般而言，如果可以利用现有的成员函数来实现这一点，则应优先使用普通函数而不是友元函数（接触类内部的函数越少越好）。但是，不要添加额外的访问函数，只是为了将运算符重载为普通函数而不是友元函数！

**最佳实践**

**如果可以在不添加额外函数的情况下实现这一点，则优先将运算符重载为普通函数而不是朋友函数。**

# 21.4 — 重载 I/O 操作符

对于具有多个成员变量的类，在屏幕上打印每个单独的变量很快就会变得令人厌烦。例如，考虑以下类：

```cpp
class Point
{
private:
    double m_x{};
    double m_y{};
    double m_z{};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
      : m_x{x}, m_y{y}, m_z{z}
    {
    }

    double getX() const { return m_x; }
    double getY() const { return m_y; }
    double getZ() const { return m_z; }
};
```

如果您想要将此类的一个实例打印到屏幕上，您必须执行以下操作：

```cpp
Point point { 5.0, 6.0, 7.0 };

std::cout << "Point(" << point.getX() << ", " <<
    point.getY() << ", " <<
    point.getZ() << ')';
```

当然，将其作为可重用函数更有意义。在前面的示例中，您已经看到我们创建了`print()`如下函数：

```cpp
class Point
{
private:
    double m_x{};
    double m_y{};
    double m_z{};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
      : m_x{x}, m_y{y}, m_z{z}
    {
    }

    double getX() const { return m_x; }
    double getY() const { return m_y; }
    double getZ() const { return m_z; }

    void print() const
    {
        std::cout << "Point(" << m_x << ", " << m_y << ", " << m_z << ')';
    }
};
```

虽然这要好得多，但它仍然有一些缺点。因为`print()`返回`void`，它不能在输出语句中间调用。相反，你必须这样做：

```cpp
int main()
{
    const Point point { 5.0, 6.0, 7.0 };

    std::cout << "My point is: ";
    point.print();
    std::cout << " in Cartesian space.\n";
}
```

如果你可以简单地输入以下内容，那就容易多了：

```cpp
Point point{5.0, 6.0, 7.0};
cout << "My point is: " << point << " in Cartesian space.\n";
```

并得到相同的结果。输出不会分散到多个语句中，也不必记住打印函数的名称。

幸运的是，通过超载`operator<<`，您可以！

## 重载`operator<<`

重载`operator<<`与重载 operator+ 类似（都是二元运算符），只是参数类型不同。

考虑表达式`std::cout << point`。如果运算符是`<<`，那么操作数是什么？左操作数是`std::cout`对象，右操作数是`Point`类对象。`std::cout`实际上是 类型的对象`std::ostream`。因此，我们的重载函数将如下所示：

```cpp
// std::ostream is the type for object std::cout
friend std::ostream& operator<< (std::ostream& out, const Point& point);
```

`operator<<`我们类的实现`Point`相当简单——因为 C++ 已经知道如何使用 输出双精度数`operator<<`，并且我们的成员都是双精度数，所以我们可以简单地使用`operator<<`输出我们的 的数据成员`Point`。以下是`Point`重载 的上述类`operator<<`。

```cpp
#include <iostream>

class Point
{
private:
    double m_x{};
    double m_y{};
    double m_z{};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
      : m_x{x}, m_y{y}, m_z{z}
    {
    }

    friend std::ostream& operator<< (std::ostream& out, const Point& point);
};

std::ostream& operator<< (std::ostream& out, const Point& point)
{
    // Since operator<< is a friend of the Point class, we can access Point's members directly.
    out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ')'; // actual output done here

    return out; // return std::ostream so we can chain calls to operator<<
}

int main()
{
    const Point point1 { 2.0, 3.0, 4.0 };

    std::cout << point1 << '\n';

    return 0;
}
```



这非常简单--注意我们的输出行与之前编写的`print()`函数中的输出行是多么相似。最显著的区别是，`std::cout` 变成了参数 `out`（调用函数时，参数`out`将是对`std::cout` 的引用）。

这里最棘手的部分是返回类型。通过算术运算符，我们计算并按值返回了一个答案（因为我们创建并返回了一个新结果）。但是，如果尝试按值返回`std::ostream`，就会出现编译器错误。这是因为 `std::ostream` 明确禁止复制。

在本例中，我们将左侧参数作为引用返回。这不仅可以防止复制 `std::ostream`，还允许我们将输出命令 "链 "在一起，例如 `std::cout << point << '\n'`。

考虑一下如果我们的`operator<<`返回`void`会发生什么。当编译器求值`std::cout << point << '\n'`时，由于优先级/关联性规则，它会将此表达式求值为`(std::cout << point) << '\n';`。`std::cout << point`将调用我们的返回 void 的重载`operator<<`函数，该函数返回`void`。然后部分评估的表达式变为：`void << '\n';`，这毫无意义！

通过将`out`参数作为返回类型返回，`(std::cout << point)`返回`std::cout`。然后我们的部分求值表达式变为：`std::cout << '\n';`，然后它自己被求值！

任何时候，我们希望重载的二元运算符以这种方式链接，左操作数应该被返回（通过引用）。在这种情况下，通过引用返回左侧参数是可以的——因为左侧参数是由调用函数传入的，所以当被调用函数返回时，它必须仍然存在。因此，我们不必担心引用的东西会超出范围并在运算符返回时被破坏。

为了证明它有效，请考虑以下示例，它使用了我们上面编写的重载的 Point 类`operator<<`：

```cpp
#include <iostream>

class Point
{
private:
    double m_x{};
    double m_y{};
    double m_z{};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
      : m_x{x}, m_y{y}, m_z{z}
    {
    }

    friend std::ostream& operator<< (std::ostream& out, const Point& point);
};

std::ostream& operator<< (std::ostream& out, const Point& point)
{
    // Since operator<< is a friend of the Point class, we can access Point's members directly.
    out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ')';

    return out;
}

int main()
{
    Point point1 { 2.0, 3.5, 4.0 };
    Point point2 { 6.0, 7.5, 8.0 };

    std::cout << point1 << ' ' << point2 << '\n';

    return 0;
}
```



其结果如下：

```
Point(2, 3.5, 4) Point(6, 7.5, 8)
```

在上面的例子中，`operator<<`是友元，因为它需要直接访问 的成员`Point`。但是，如果可以通过 getter 访问成员，则`operator<<`可以将其实现为非友元。

## 重载`operator>>`

还可以重载输入运算符。这与重载输出运算符的方式类似。您需要知道的关键是`std::cin`是 类型的对象`std::istream`。以下是添加了`Point`重载的类`operator>>`：

```cpp
#include <iostream>

class Point
{
private:
    double m_x{};
    double m_y{};
    double m_z{};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
      : m_x{x}, m_y{y}, m_z{z}
    {
    }

    friend std::ostream& operator<< (std::ostream& out, const Point& point);
    friend std::istream& operator>> (std::istream& out, Point& point);
};

std::ostream& operator<< (std::ostream& out, const Point& point)
{
    // Since operator<< is a friend of the Point class, we can access Point's members directly.
    out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ')';

    return out;
}

// note that point must be non-const so we can modify the object
std::istream& operator>> (std::istream& in, Point& point)
{
    // This version subject to partial extraction issues (see below)
    in >> point.m_x >> point.m_y >> point.m_z;

    return in;
}

int main()
{
    std::cout << "Enter a point: ";

    Point point{ 1.0, 2.0, 3.0 }; // non-zero test data
    std::cin >> point;

    std::cout << "You entered: " << point << '\n';

    return 0;
}
```

假设用户输入`4.0 5.6 7.26`，程序会产生以下结果：

```
You entered: Point(4, 5.6, 7.26)
```

现在让我们看看当用户输入时会发生什么`4.0b 5.6 7.26`（注意`b`后面的`4.0`）：

```
You entered: Point(4, 0, 3)
```

我们的点现在是一个奇怪的混合体，由一个来自用户输入的值 ( `4.0`)、一个已初始化为零的值 ( `0.0`) 和一个未受输入函数影响的值 ( `3.0`) 组成。这……不太好！

## 防止部分提取

当我们提取单个值时，只有两种可能的结果：提取失败或成功。但是，当我们在输入操作中提取多个值时，事情会变得稍微复杂一些。

上述操作符 >> 的实现可能会导致部分提取。这正是我们在输入`4.0b 5.6 7.26`时看到的情况。对 `x_y`的提取成功地从用户输入中提取出了`4.0`，在输入流中留下了`b 5.6 7.26`。向 `m_y`提取`b`失败，因此`m_y`被复制赋值为 `0.0`，输入流被设置为失败模式。由于我们还没有清除失败模式，对`m_z`的提取立即终止，m_z 在提取尝试之前的值仍然保留`3.0`。

在任何情况下，这都不是理想的结果。在某些情况下，这甚至可能非常危险。想象一下，我们`operator>>`为某个`Fraction`对象编写了一个。成功提取分子后，分母提取失败会将分母设置为`0.0`，这可能会导致除以零并导致应用程序崩溃。

那么我们如何避免这种情况呢？一种方法是让我们的操作具有事务性。**事务操作**必须完全成功或完全失败——不允许部分成功或失败。这有时被称为“全有或全无”。如果在事务期间的任何时候发生故障，则必须撤消操作所做的先前更改。

<u>关键见解</u>

<u>交易在现实生活中无时无刻不在发生。假设我想将钱从一个银行账户转到另一个银行账户。这需要两个步骤：首先必须先从一个账户中扣除这笔钱，然后必须将其存入另一个账户。在执行此操作时，有三种可能性：</u>

- <u>扣款步骤失败（例如资金不足）。交易失败，两个账户余额均未反映该笔转账。</u>
- <u>记账步骤失败（例如由于技术问题）。在这种情况下，必须撤销扣款（已成功）。交易失败，账户余额均未反映转账。</u>
- <u>两个步骤均成功。交易成功，两个账户余额均反映转账情况。</u>

<u>最终的结果是只有两种可能的结果：转账彻底失败，账户余额不变，或者转账成功，账户余额都发生变化。</u>

让我们将重载重新实现`Point` `operator>>`为事务操作：

```cpp
// note that point must be non-const so we can modify the object
// note that this implementation is a non-friend
std::istream& operator>> (std::istream& in, Point& point)
{
    double x{};
    double y{};
    double z{};

    if (in >> x >> y >> z)      // if all extractions succeeded
        point = Point{x, y, z}; // overwrite our existing point

    return in;
}
```

在此实现中，我们不会直接用用户的输入覆盖数据成员。相反，我们将用户的输入提取到临时变量（`x`、`y`和`z`）中。一旦所有提取尝试都完成，我们将检查所有提取是否都成功。如果成功，我们将一起更新 的所有成员`Point`。否则，我们不会更新任何成员。

**提示**

**`if (in >> x >> y >> z)`相当于`in >> x >> y >> z; if (in)`。请记住，每次提取都会返回，`in`因此可以将多个提取链接在一起。单语句版本使用`in`上次提取返回的作为 if 语句的条件，而多语句版本则`in`显式使用。**

<u>提示</u>

<u>事务操作可以使用多种不同的策略来实现。例如：</u>

- <u>成功时更改：存储每个子操作的结果。如果所有子操作都成功，则用存储的结果替换相关数据。这是我们在`Point`上面的示例中使用的策略。</u>
- <u>失败时恢复：复制任何可以更改的数据。如果任何子操作失败，可以使用复制的数据恢复先前子操作所做的更改。</u>
- <u>失败时回滚：如果任何子操作失败，则每个先前的子操作都会被撤销（使用相反的子操作）。此策略通常用于数据库，因为数据太大而无法备份，并且子操作的结果无法存储。</u>

虽然上述方法`operator>>`可以防止部分提取，但它与基本类型的工作方式不一致`operator>>`。当提取到具有基本类型的对象失败时，该对象不会保持不变——它会被复制赋值`0`（这可确保对象具有一些一致的值，以防在提取尝试之前未初始化）。因此，为了保持一致性，您可能希望在提取失败时将对象重置为其默认状态（至少在存在这种情况的情况下）。

这是替代版本，如果任何提取失败，`operator>>`则会重置`Point`为其默认状态：

```cpp
// note that point must be non-const so we can modify the object
// note that this implementation is a non-friend
std::istream& operator>> (std::istream& in, Point& point)
{
    double x{};
    double y{};
    double z{};

    in >> x >> y >> z;
    point = in ? Point{x, y, z} : Point{};

    return in;
}
```

**作者注**

**从技术上讲，这样的操作不再是事务性的（因为失败不会“什么都不做”）。似乎没有一个通用术语来描述不保证部分结果的操作。也许是“不可分割的操作”。**

## 处理语义上无效的输入

提取可能会因多种原因而失败。

如果`operator>>`无法将任何内容提取到变量中，`std::cin`则会自动进入故障模式（我们将在课程[9.5 中讨论 - std::cin 和处理无效输入]）。然后，此函数的调用者可以检查`std::cin`它是否失败并根据需要处理该情况。

但是，如果用户输入的值可提取但语义无效（例如，`Fraction`分母为`0`），该怎么办？因为`std::cin`确实提取了某些内容，所以它不会自动进入失败模式。然后调用者可能不会意识到出了问题。

为了解决这个问题，我们可以让重载`operator>>`确定提取的任何值是否在语义上无效，如果是，则手动将输入流置于故障模式。这可以通过调用来完成`std::cin.setstate(std::ios_base::failbit);`。

下面是一个事务重载的示例，如果用户输入可提取的负值，它将导致输入流进入故障模式`operator>>`：`Point`

```cpp
std::istream& operator>> (std::istream& in, Point& point)
{
    double x{};
    double y{};
    double z{};

    in >> x >> y >> z;
    if (x < 0.0 || y < 0.0 || z < 0.0)       // if any extractable input is negative
        in.setstate(std::ios_base::failbit); // set failure mode manually
    point = in ? Point{x, y, z} : Point{};

    return in;
}
```

## 结论

重载`operator<<`并`operator>>`轻松地将您的类输出到屏幕并从控制台接受用户输入。

## 测验时间

### 问题 #1

以下面的 Fraction 类为例，添加一个`operator>>`和`operator>>`。`operator>>`应避免部分提取，如果用户输入的分母为`0`，则操作失败。

下面的程序应该可以编译：

```cpp
int main()
{
	Fraction f1{};
	std::cout << "Enter fraction 1: ";
	std::cin >> f1;

	Fraction f2{};
	std::cout << "Enter fraction 2: ";
	std::cin >> f2;

	std::cout << f1 << " * " << f2 << " is " << f1 * f2 << '\n'; // note: The result of f1 * f2 is an r-value

	return 0;
}
```

并产生结果：

```
Enter fraction 1: 2/3
Enter fraction 2: 3/8
2/3 * 3/8 is 1/4
```

这是 Fraction 类：

```cpp
#include <iostream>
#include <numeric> // for std::gcd

class Fraction
{
private:
	int m_numerator{};
	int m_denominator{};

public:
	Fraction(int numerator=0, int denominator=1):
		m_numerator{numerator}, m_denominator{denominator}
	{
		// We put reduce() in the constructor to ensure any new fractions we make get reduced!
		// Any fractions that are overwritten will need to be re-reduced
		reduce();
	}

	void reduce()
	{
		int gcd{ std::gcd(m_numerator, m_denominator) };
		if (gcd)
		{
			m_numerator /= gcd;
			m_denominator /= gcd;
		}
	}

	friend Fraction operator*(const Fraction& f1, const Fraction& f2);
	friend Fraction operator*(const Fraction& f1, int value);
	friend Fraction operator*(int value, const Fraction& f1);

	void print() const
	{
		std::cout << m_numerator << '/' << m_denominator << '\n';
	}
};

Fraction operator*(const Fraction& f1, const Fraction& f2)
{
	return Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };
}

Fraction operator*(const Fraction& f1, int value)
{
	return Fraction { f1.m_numerator * value, f1.m_denominator };
}

Fraction operator*(int value, const Fraction& f1)
{
	return Fraction { f1.m_numerator * value, f1.m_denominator };
}
```

如果您使用的是 C++17 之前的编译器，则可以用此函数替换 std::gcd：

```cpp
#include <cmath>

int gcd(int a, int b) {
    return (b == 0) ? std::abs(a) : gcd(b, a % b);
}
```

```cpp
#include <iostream>
#include <limits>
#include <numeric> // for std::gcd

class Fraction
{
private:
    int m_numerator{ 0 };
    int m_denominator{ 1 };

public:
    Fraction(int numerator=0, int denominator = 1) :
        m_numerator{ numerator }, m_denominator{ denominator }
    {
        // We put reduce() in the constructor to ensure any new fractions we make get reduced!
        // Any fractions that are overwritten will need to be re-reduced
        reduce();
    }

    void reduce()
    {
        int gcd{ std::gcd(m_numerator, m_denominator) };
        if (gcd)
        {
            m_numerator /= gcd;
            m_denominator /= gcd;
        }
    }

    friend Fraction operator*(const Fraction& f1, const Fraction& f2);
    friend Fraction operator*(const Fraction& f1, int value);
    friend Fraction operator*(int value, const Fraction& f1);

    friend std::ostream& operator<<(std::ostream& out, const Fraction& f1);

    void print() const
    {
        std::cout << m_numerator << '/' << m_denominator << '\n';
    }
};

Fraction operator*(const Fraction& f1, const Fraction& f2)
{
    return Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };
}

Fraction operator*(const Fraction& f1, int value)
{
    return Fraction { f1.m_numerator * value, f1.m_denominator };
}

Fraction operator*(int value, const Fraction& f1)
{
    return Fraction { f1.m_numerator * value, f1.m_denominator };
}

std::ostream& operator<<(std::ostream& out, const Fraction& f1)
{
    out << f1.m_numerator << '/' << f1.m_denominator;
    return out;
}

std::istream& operator>>(std::istream& in, Fraction& f1)
{
    int numerator {};
    char ignore {};
    int denominator {};

    in >> numerator >> ignore >> denominator;
    if (denominator == 0)                       // if our denominator is semantically invalid
        in.setstate(std::ios_base::failbit);    // set failure mode manually
    if (in)                                     // if we're not in failure mode
        f1 = Fraction {numerator, denominator}; // update our object to the extracted values

    return in;
}

int main()
{
    Fraction f1{};
    std::cout << "Enter fraction 1: ";
    std::cin >> f1;

    Fraction f2{};
    std::cout << "Enter fraction 2: ";
    std::cin >> f2;

    std::cout << f1 << " * " << f2 << " is " << f1 * f2 << '\n'; // note: The result of f1 * f2 is an r-value

    return 0;
}
```

# 21.5 — 使用成员函数重载运算符

在课程[21.2 — 使用友元函数重载算术运算符](https://www.learncpp.com/cpp-tutorial/overloading-the-arithmetic-operators-using-friend-functions/)中，您学习了如何使用友元函数重载算术运算符。您还学习了可以将运算符重载为普通函数。许多运算符可以以不同的方式重载：作为成员函数。

使用成员函数重载运算符与使用友元函数重载运算符非常相似。使用成员函数重载运算符时：

- 必须将重载运算符添加为左操作数的成员函数。
- 左操作数成为隐式的 *this 对象
- 所有其他操作数都成为函数参数。