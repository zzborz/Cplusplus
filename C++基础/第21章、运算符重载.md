# 21.1 — 运算符重载简介

在课程[11.1 — 函数重载简介](https://www.learncpp.com/cpp-tutorial/introduction-to-function-overloading/)中，您了解了函数重载，它提供了一种机制来创建和解析对具有相同名称的多个函数的函数调用，只要每个函数都有唯一的函数原型。这允许您创建函数的变体以处理不同的数据类型，而不必为每个变体想出一个唯一的名称。

在 C++ 中，运算符以函数形式实现。通过在运算符函数上使用函数重载，您可以定义自己的运算符版本，以处理不同的数据类型（包括您编写的类）。使用函数重载来重载运算符称为**运算符重载**。

在本章中，我们将研究与运算符重载相关的主题。

## **运算符作为函数**

请考虑以下示例：

```cpp
int x { 2 };
int y { 3 };
std::cout << x + y << '\n';
```

编译器自带了用于整数操作数的加法运算符 (+) 的内置版本——此函数将整数 x 和 y 相加并返回整数结果。看到表达式时`x + y`，您可以在脑海中将其转换为函数调用`operator+(x, y)`（其中，operator+ 是函数的名称）。

现在考虑这个类似的代码片段：

```cpp
double z { 2.0 };
double w { 3.0 };
std::cout << w + z << '\n';
```

编译器还附带了用于双精度操作数的加法运算符 (+) 的内置版本。表达式 w + z 变为函数调用`operator+(w, z)`，函数重载用于确定编译器应调用此函数的双精度版本，而不是整数版本。

现在考虑一下如果我们尝试添加程序定义类的两个对象会发生什么：

```cpp
Mystring string1 { "Hello, " };
Mystring string2 { "World!" };
std::cout << string1 + string2 << '\n';
```

在这种情况下，你希望发生什么？直观的预期结果是字符串“Hello, World!”将打印在屏幕上。但是，由于 Mystring 是程序定义的类型，因此编译器没有可用于 Mystring 操作数的内置版本的加法运算符。因此在这种情况下，它会给我们一个错误。为了使其按我们想要的方式工作，我们需要编写一个重载函数来告诉编译器 + 运算符应如何与两个 Mystring 类型的操作数一起工作。我们将在下一课中讨论如何做到这一点。

## **解决重载运算符**

在评估包含运算符的表达式时，编译器使用以下规则：

- 如果*所有*操作数都是基本数据类型，则编译器将调用内置例程（如果存在）。如果不存在内置例程，则编译器将产生编译器错误。
- 如果*任何*操作数是程序定义类型（例如，您的某个类或枚举类型），则编译器将使用函数重载解析算法（在课程[11.3 -- 函数重载解析和模糊匹配](https://www.learncpp.com/cpp-tutorial/function-overload-resolution-and-ambiguous-matches/)中描述）来查看是否可以找到一个无歧义的最佳匹配重载运算符。这可能涉及隐式转换一个或多个操作数以匹配重载运算符的参数类型。它还可能涉及隐式将程序定义类型转换为基本类型（通过重载类型转换，我们将在本章后面介绍），以便它可以匹配内置运算符。如果找不到匹配项（或找到模糊匹配项），则编译器将出错。

## **运算符重载有哪些限制？**

首先，C++ 中几乎所有现有的运算符都可以重载。例外情况包括：条件 (?:)、sizeof、作用域 (::)、成员选择器 (.)、指针成员选择器 (.*)、typeid 和强制类型转换运算符。

其次，您只能重载现有的运算符。您不能创建新的运算符或重命名现有的运算符。例如，您不能创建一个`operator**`用于执行指数的运算符。

第三，重载运算符中的至少一个操作数必须是用户定义类型。这意味着你可以重载`operator+(int, Mystring)`，但不能重载`operator+(int, double)`。

由于标准库类被视为用户定义的，这意味着您可以定义`operator+(double, std::string)`。但是，这不是一个好主意，因为未来的语言标准可能会定义此重载，这可能会破坏使用您的重载的任何程序。因此，最佳做法是您的重载运算符应至少对一种程序定义的类型进行操作。这保证了未来的语言标准不会破坏您的程序。

**最佳实践**

**重载运算符应该至少对一种程序定义类型进行操作（作为函数的参数或隐式对象）。**

第四，无法改变运算符支持的操作数的数量。

最后，所有运算符都保留其默认优先级和结合性（无论其用于什么），并且无法改变。

一些新程序员尝试重载按位异或运算符 (^) 来执行幂运算。然而，在 C++ 中，运算符 ^ 的优先级低于基本算术运算符，这会导致表达式求值不正确。

在基础数学中，指数运算在基本算术之前解析，因此 4 + 3 ^ 2 解析为 4 + (3 ^ 2) => 4 + 9 => 13。
但是在 C++ 中，算术运算符的优先级高于运算符 ^，因此 4 + 3 ^ 2 解析为 (4 + 3) ^ 2 => 7 ^ 2 => 49。

每次使用时，您都需要明确地将指数部分（例如 4 + (3 ^ 2)）括起来以使其正常工作，这并不直观，并且容易出错。

由于这个优先级问题，通常最好仅以类似于其原始意图的方式使用运算符。

**最佳实践**

**在重载运算符的时候，最好让运算符的功能尽可能的接近运算符的原始意图。**

此外，由于运算符没有描述性名称，因此它们的用途并不总是很清楚。例如，对于字符串类来说，operator+ 可能是执行字符串连接的合理选择。但是 operator- 呢？你希望它做什么？这不清楚。

**最佳实践**

**如果重载运算符的含义不清晰且不直观，请改用命名函数。**

最后，重载运算符应以与原始运算符一致的方式返回值。不修改其操作数的运算符（例如算术运算符）通常应按值返回结果。修改其最左操作数的运算符（例如预增量、任何赋值运算符）通常应按引用返回最左操作数。

**最佳实践**

**不修改操作数的运算符（例如算术运算符）通常应按值返回结果。**

修改其最左边操作数的运算符（例如预增、任何赋值运算符）通常应通过引用返回最左边的操作数。

在这些限制内，您仍会发现许多有用的功能可以为您的自定义类重载！您可以重载 + 运算符来连接程序定义的字符串类，或将两个 Fraction 类对象加在一起。您可以重载 << 运算符，以便轻松地将您的类打印到屏幕（或文件）。您可以重载相等运算符 (==) 来比较两个类对象。这使得运算符重载成为 C++ 中最有用的功能之一——因为它允许您以更直观的方式处理类。

# 21.2 — 使用友元函数重载算术运算符

C++ 中最常用的运算符是算术运算符，即加法运算符 (+)、减法运算符 (-)、乘法运算符 (*) 和除法运算符 (/)。请注意，所有算术运算符都是二元运算符，这意味着它们需要两个操作数，即运算符两侧各一个。所有这四个运算符都以完全相同的方式重载。

事实证明，重载运算符有三种不同的方法：成员函数方法、友元函数方法和普通函数方法。在本课中，我们将介绍友元函数方法（因为它对于大多数二元运算符来说更直观）。下一课，我们将讨论普通函数方法。最后，在本章的后面一课中，我们将介绍成员函数方法。当然，我们还将更详细地总结何时使用每种方法。

## 使用友元函数重载运算符

考虑以下类：

```cpp
class Cents
{
private:
	int m_cents {};

public:
	Cents(int cents) : m_cents{ cents } { }
	int getCents() const { return m_cents; }
};
```

下面的例子展示了如何重载加号运算符 (+) 来将两个“Cents”对象加在一起：

```cpp
#include <iostream>

class Cents
{
private:
	int m_cents {};

public:
	Cents(int cents) : m_cents{ cents } { }

	// add Cents + Cents using a friend function
	friend Cents operator+(const Cents& c1, const Cents& c2);

	int getCents() const { return m_cents; }
};

// note: this function is not a member function!
Cents operator+(const Cents& c1, const Cents& c2)
{
	// use the Cents constructor and operator+(int, int)
	// we can access m_cents directly because this is a friend function
	return c1.m_cents + c2.m_cents;
}

int main()
{
	Cents cents1{ 6 };
	Cents cents2{ 8 };
	Cents centsSum{ cents1 + cents2 };
	std::cout << "I have " << centsSum.getCents() << " cents.\n";

	return 0;
}
```

得出的结果是：

```
I have 14 cents.
```

重载加法运算符（+）很简单，只需声明一个名为 operator+ 的函数，给它两个我们要添加的操作数类型的参数，选择一个合适的返回类型，然后编写该函数即可。

在我们的 Cents 对象中，实现我们的 operator+() 函数非常简单。首先，参数类型：在此版本的 operator+ 中，我们将把两个 Cents 对象相加，因此我们的函数将采用两个 Cents 类型的对象。其次，返回类型：我们的 operator+ 将返回 Cents 类型的结果，因此这就是我们的返回类型。

最后，实现：要将两个 Cents 对象相加，我们实际上需要从每个 Cents 对象中添加 m_cents 成员。由于我们的重载 operator+() 函数是类的友元，因此我们可以直接访问参数的 m_cents 成员。此外，由于 m_cents 是一个整数，并且 C++ 知道如何使用内置版本的加法运算符（适用于整数操作数）将整数相加，因此我们可以简单地使用 + 运算符进行加法。

重载减法运算符（-）也很简单：

```cpp
#include <iostream>

class Cents
{
private:
	int m_cents {};

public:
	explicit Cents(int cents) : m_cents{ cents } { }

	// add Cents + Cents using a friend function
	friend Cents operator+(const Cents& c1, const Cents& c2);

	// subtract Cents - Cents using a friend function
	friend Cents operator-(const Cents& c1, const Cents& c2);

	int getCents() const { return m_cents; }
};

// note: this function is not a member function!
Cents operator+(const Cents& c1, const Cents& c2)
{
	// use the Cents constructor and operator+(int, int)
	// we can access m_cents directly because this is a friend function
	return Cents { c1.m_cents + c2.m_cents };
}

// note: this function is not a member function!
Cents operator-(const Cents& c1, const Cents& c2)
{
	// use the Cents constructor and operator-(int, int)
	// we can access m_cents directly because this is a friend function
	return Cents { c1.m_cents - c2.m_cents };
}

int main()
{
	Cents cents1{ 6 };
	Cents cents2{ 2 };
	Cents centsSum{ cents1 - cents2 };
	std::cout << "I have " << centsSum.getCents() << " cents.\n";

	return 0;
}
```

`operator*`重载乘法运算符（*）和除法运算符（/）就像分别为和定义函数一样简单`operator/`。

## 友元函数可以在类内部定义

即使友元函数不是类的成员，但如果需要，它们仍然可以在类内部定义：

```cpp
#include <iostream>

class Cents
{
private:
	int m_cents {};

public:
	explicit Cents(int cents) : m_cents{ cents } { }

	// add Cents + Cents using a friend function
        // This function is not considered a member of the class, even though the definition is inside the class
	friend Cents operator+(const Cents& c1, const Cents& c2)
	{
		// use the Cents constructor and operator+(int, int)
		// we can access m_cents directly because this is a friend function
		return Cents { c1.m_cents + c2.m_cents };
	}

	int getCents() const { return m_cents; }
};

int main()
{
	Cents cents1{ 6 };
	Cents cents2{ 8 };
	Cents centsSum{ cents1 + cents2 };
	std::cout << "I have " << centsSum.getCents() << " cents.\n";

	return 0;
}
```

对于具有简单实现的重载运算符来说，这很好。

## 为不同类型的操作数重载运算符

通常情况下，您希望重载运算符能够处理不同类型的操作数。例如，如果我们有 Cents(4)，我们可能希望将整数 6 添加到其中以产生结果 Cents(10)。

当 C++ 计算表达式 时`x + y`，x 成为第一个参数，y 成为第二个参数。当 x 和 y 具有相同的类型时，无论添加 x + y 还是 y + x 都没有关系——无论哪种方式，都会调用相同版本的运算符 +。但是，当操作数具有不同的类型时，x + y 不会调用与 y + x 相同的函数。

例如，`Cents(4) + 6`将调用 operator+(Cents, int)，并将`6 + Cents(4)`调用 operator+(int, Cents)。因此，每当我们为不同类型的操作数重载二元运算符时，我们实际上都需要编写两个函数——每个案例一个。以下是一个例子：

```cpp
#include <iostream>

class Cents
{
private:
	int m_cents {};

public:
	explicit Cents(int cents) : m_cents{ cents } { }

	// add Cents + int using a friend function
	friend Cents operator+(const Cents& c1, int value);

	// add int + Cents using a friend function
	friend Cents operator+(int value, const Cents& c1);


	int getCents() const { return m_cents; }
};

// note: this function is not a member function!
Cents operator+(const Cents& c1, int value)
{
	// use the Cents constructor and operator+(int, int)
	// we can access m_cents directly because this is a friend function
	return Cents { c1.m_cents + value };
}

// note: this function is not a member function!
Cents operator+(int value, const Cents& c1)
{
	// use the Cents constructor and operator+(int, int)
	// we can access m_cents directly because this is a friend function
	return Cents { c1.m_cents + value };
}

int main()
{
	Cents c1{ Cents{ 4 } + 6 };
	Cents c2{ 6 + Cents{ 4 } };

	std::cout << "I have " << c1.getCents() << " cents.\n";
	std::cout << "I have " << c2.getCents() << " cents.\n";

	return 0;
}
```

请注意，两个重载函数具有相同的实现 - 这是因为它们执行相同的操作，只是以不同的顺序获取参数。

另一个例子

我们来看另一个例子：

```cpp
#include <iostream>

class MinMax
{
private:
	int m_min {}; // The min value seen so far
	int m_max {}; // The max value seen so far

public:
	MinMax(int min, int max)
		: m_min { min }, m_max { max }
	{ }

	int getMin() const { return m_min; }
	int getMax() const { return m_max; }

	friend MinMax operator+(const MinMax& m1, const MinMax& m2);
	friend MinMax operator+(const MinMax& m, int value);
	friend MinMax operator+(int value, const MinMax& m);
};

MinMax operator+(const MinMax& m1, const MinMax& m2)
{
	// Get the minimum value seen in m1 and m2
	int min{ m1.m_min < m2.m_min ? m1.m_min : m2.m_min };

	// Get the maximum value seen in m1 and m2
	int max{ m1.m_max > m2.m_max ? m1.m_max : m2.m_max };

	return MinMax { min, max };
}

MinMax operator+(const MinMax& m, int value)
{
	// Get the minimum value seen in m and value
	int min{ m.m_min < value ? m.m_min : value };

	// Get the maximum value seen in m and value
	int max{ m.m_max > value ? m.m_max : value };

	return MinMax { min, max };
}

MinMax operator+(int value, const MinMax& m)
{
	// calls operator+(MinMax, int)
	return m + value;
}

int main()
{
	MinMax m1{ 10, 15 };
	MinMax m2{ 8, 11 };
	MinMax m3{ 3, 12 };

	MinMax mFinal{ m1 + m2 + 5 + 8 + m3 + 16 };

	std::cout << "Result: (" << mFinal.getMin() << ", " <<
		mFinal.getMax() << ")\n";

	return 0;
}
```

MinMax 类会跟踪迄今为止所见的最小值和最大值。我们重载了 3 次 + 运算符，以便我们可以将两个 MinMax 对象相加，或者将整数添加到 MinMax 对象。

此示例产生的结果：

```
结果：（3，16）
```

您会注意到这是我们添加到 mFinal 的最小值和最大值。

让我们再多谈谈“MinMax mFinal { m1 + m2 + 5 + 8 + m3 + 16 }”如何求值。请记住，operator+ 从左到右求值，因此 m1 + m2 首先求值。这变为对 operator+(m1, m2) 的调用，它产生返回值 MinMax(8, 15)。然后 MinMax(8, 15) + 5 接下来求值。这变为对 operator+(MinMax(8, 15), 5) 的调用，它产生返回值 MinMax(5, 15)。然后 MinMax(5, 15) + 8 以相同的方式求值以产生 MinMax(5, 15)。然后 MinMax(5, 15) + m3 求值以产生 MinMax(3, 15)。最后，MinMax(3, 15) + 16 求值为 MinMax(3, 16)。然后，此最终结果用于初始化 mFinal。

换句话说，该表达式的计算结果为“MinMax mFinal = (((((m1 + m2) + 5) + 8) + m3) + 16)”，每个连续操作都会返回一个 MinMax 对象，该对象成为下一个运算符的左边操作数。

使用其他运算符实现运算符

在上面的例子中，请注意，我们通过调用 operator+(MinMax, int)（产生相同的结果）来定义 operator+(int, MinMax)。这使我们能够将 operator+(int, MinMax) 的实现缩减为一行，通过最大限度地减少冗余并使函数更易于理解，使我们的代码更易于维护。

通常可以通过调用其他重载运算符来定义重载运算符。如果这样做会产生更简单的代码，则应该这样做。在实现很简单（例如一行代码）的情况下，这样做可能值得，也可能不值得。

## 测验时间

### 问题 #1

a) 编写一个名为 Fraction 的类，该类具有整数分子和分母成员。编写一个 print() 函数打印出分数。

以下代码应该可以编译：

```cpp
#include <iostream>

int main()
{
    Fraction f1{ 1, 4 };
    f1.print();

    Fraction f2{ 1, 2 };
    f2.print();

    return 0;
}
```

这应该打印：

```
1/4 
1/2
```

```cpp
#include <iostream>

class Fraction
{
private:
	int m_numerator { 0 };
	int m_denominator { 1 };

public:
	explicit Fraction(int numerator, int denominator=1)
		: m_numerator{numerator}, m_denominator{denominator}
	{
	}

	void print() const
	{
		std::cout << m_numerator << '/' << m_denominator << '\n';
	}
};

int main()
{
	Fraction f1 {1, 4};
	f1.print();

	Fraction f2 {1, 2};
	f2.print();

	return 0;
}
```

b) 添加重载乘法运算符来处理分数与整数以及两个分数之间的乘法。使用友元函数方法。

提示：要将两个分数相乘，首先将两个分子相乘，然后将两个分母相乘。要将分数和整数相乘，将分数的分子乘以整数，分母保持不变。

以下代码应该可以编译：

```cpp
#include <iostream>

int main()
{
    Fraction f1{2, 5};
    f1.print();

    Fraction f2{3, 8};
    f2.print();

    Fraction f3{ f1 * f2 };
    f3.print();

    Fraction f4{ f1 * 2 };
    f4.print();

    Fraction f5{ 2 * f2 };
    f5.print();

    Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };
    f6.print();

    return 0;
}
```

这应该打印：

```
2/5 
3/8 
6/40 
4/5 
6/8 
6/24
```

```cpp
#include <iostream>

class Fraction
{
private:
	int m_numerator { 0 };
	int m_denominator { 1 };

public:
	explicit Fraction(int numerator, int denominator=1)
		: m_numerator{numerator}, m_denominator{denominator}
	{
	}

	// We don't want to pass by value, because copying is slow.
	// We can't and shouldn't pass by non-const reference, because then
	// our functions wouldn't work with r-values.
	friend Fraction operator*(const Fraction& f1, const Fraction& f2);
	friend Fraction operator*(const Fraction& f1, int value);
	friend Fraction operator*(int value, const Fraction& f1);

	void print() const
	{
		std::cout << m_numerator << '/' << m_denominator << '\n';
	}
};

Fraction operator*(const Fraction& f1, const Fraction& f2)
{
	return Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };
}

Fraction operator*(const Fraction& f1, int value)
{
	return Fraction { f1.m_numerator * value, f1.m_denominator };
}

Fraction operator*(int value, const Fraction& f1)
{
	return Fraction { f1 * value };
}

int main()
{
	Fraction f1{2, 5};
	f1.print();

	Fraction f2{3, 8};
	f2.print();

	Fraction f3{ f1 * f2 };
	f3.print();

	Fraction f4{ f1 * 2 };
	f4.print();

	Fraction f5{ 2 * f2 };
	f5.print();

	Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };
	f6.print();

	return 0;
}
```

c) 为什么如果我们使构造函数非显式化并且从以前的解决方案中删除整数乘法运算符，程序仍然能够正常工作？

```cpp
// Remove explicit from constructor
	Fraction(int numerator, int denominator=1)
		: m_numerator{numerator}, m_denominator{denominator}
	{
	}

// We can remove these operators, and the program continues to work
Fraction operator*(const Fraction& f1, int value);
Fraction operator*(int value, const Fraction& f1);
```



我们还有

```cpp
Fraction operator*(const Fraction& f1, const Fraction& f2)
```

例如，当我们将分数乘以整数时

```cpp
Fraction f5{ 2 * f2 };
```

非显式 Fraction(int, int) 构造函数将用于从 2 生成一个新的 Fraction，然后使用 Fraction * Fraction 运算符将这个新的 Fraction 与 f2 相乘。

因为这需要转换`2`为`Fraction`，所以这比使用整数乘法的重载运算符的实现稍微慢一些。



d) 如果我们把引用参数设为`operator*(Fraction, Fraction)`非常量，函数中的下面这一行`main`就不再起作用了。为什么？

```cpp
// The non-const multiplication operator looks like this
Fraction operator*(Fraction& f1, Fraction& f2)

// This doesn't work anymore
Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };
```

我们正在乘以临时的 Fraction 对象，但非常数引用不能绑定到临时对象。



e) 额外加分：分数 2/4 与 1/2 相同，但 2/4 不能化简为最简数。我们可以通过找到分子和分母之间的最大公约数 (GCD)，然后将分子和分母都除以 GCD，将任何给定分数化简为最简数。

`std::gcd()`已添加到 C++17 的标准库中（在 <numeric> 标头中）。

如果您使用的是较旧的编译器，则可以使用此函数来查找 GCD：

```cpp
#include <cmath> // for std::abs

int gcd(int a, int b) {
    return (b == 0) ? std::abs(a) : gcd(b, a % b);
}
```

编写一个名为 reduce() 的成员函数来减少分数。确保所有分数都正确减少。

以下内容应编译：

```cpp
#include <iostream>

int main()
{
    Fraction f1{2, 5};
    f1.print();

    Fraction f2{3, 8};
    f2.print();

    Fraction f3{ f1 * f2 };
    f3.print();

    Fraction f4{ f1 * 2 };
    f4.print();

    Fraction f5{ 2 * f2 };
    f5.print();

    Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };
    f6.print();

    Fraction f7{0, 6};
    f7.print();

    return 0;
}
```

并产生结果：

```
2/5 
3/8 
3/20 
4/5 
3/4 
1/4 
0/1
```

```cpp
#include <iostream>
#include <numeric> // for std::gcd

// This version of the Fraction class auto-reduces fractions
class Fraction
{
private:
	int m_numerator{ 0 };
	int m_denominator{ 1 };

public:
	explicit Fraction(int numerator, int denominator = 1)
		: m_numerator{ numerator }, m_denominator{ denominator }
	{
		// We put reduce() in the constructor to ensure any fractions we make get reduced!
		// Since all of the overloaded operators create new Fractions, we can guarantee this will get called here
		reduce();
	}

	void reduce()
	{
		int gcd{ std::gcd(m_numerator, m_denominator) };
		if (gcd) // Make sure we don't try to divide by 0
		{
			m_numerator /= gcd;
			m_denominator /= gcd;
		}
	}

	friend Fraction operator*(const Fraction& f1, const Fraction& f2);
	friend Fraction operator*(const Fraction& f1, int value);
	friend Fraction operator*(int value, const Fraction& f1);

	void print() const
	{
		std::cout << m_numerator << '/' << m_denominator << '\n';
	}
};

Fraction operator*(const Fraction& f1, const Fraction& f2)
{
	return Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };
}

Fraction operator*(const Fraction& f1, int value)
{
	return Fraction { f1.m_numerator * value, f1.m_denominator };
}

Fraction operator*(int value, const Fraction& f1)
{
	return Fraction { f1 * value };
}

int main()
{
	Fraction f1{ 2, 5 };
	f1.print();

	Fraction f2{ 3, 8 };
	f2.print();

	Fraction f3{ f1 * f2 };
	f3.print();

	Fraction f4{ f1 * 2 };
	f4.print();

	Fraction f5{ 2 * f2 };
	f5.print();

	Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };
	f6.print();

	Fraction f7{ 0, 6 };
	f7.print();

	return 0;
}
```

# 21.3 — 使用普通函数重载运算符

在上一课中，我们将 operator+ 重载为友元函数：

```cpp
#include <iostream>

class Cents
{
private:
  int m_cents{};

public:
  Cents(int cents)
    : m_cents{ cents }
  {}

  // add Cents + Cents using a friend function
  friend Cents operator+(const Cents& c1, const Cents& c2);

  int getCents() const { return m_cents; }
};

// note: this function is not a member function!
Cents operator+(const Cents& c1, const Cents& c2)
{
  // use the Cents constructor and operator+(int, int)
  // we can access m_cents directly because this is a friend function
  return { c1.m_cents + c2.m_cents };
}

int main()
{
  Cents cents1{ 6 };
  Cents cents2{ 8 };
  Cents centsSum{ cents1 + cents2 };
  std::cout << "I have " << centsSum.getCents() << " cents.\n";

  return 0;
}
```

使用友元函数重载运算符非常方便，因为它可以让您直接访问正在操作的类的内部成员。在上面的初始 Cents 示例中，我们的友元函数版本的 operator+ 直接访问了成员变量 m_cents。

但是，如果您不需要该访问权限，则可以将重载运算符编写为普通函数。请注意，上面的 Cents 类包含一个访问函数 (getCents())，它允许我们获取 m_cents，而无需直接访问私有成员。因此，我们可以将重载的 operator+ 编写为非友元：

```cpp
#include <iostream>

class Cents
{
private:
  int m_cents{};

public:
  Cents(int cents)
    : m_cents{ cents }
  {}

  int getCents() const { return m_cents; }
};

// note: this function is not a member function nor a friend function!
Cents operator+(const Cents& c1, const Cents& c2)
{
  // use the Cents constructor and operator+(int, int)
  // we don't need direct access to private members here
  return Cents{ c1.getCents() + c2.getCents() };
}

int main()
{
  Cents cents1{ 6 };
  Cents cents2{ 8 };
  Cents centsSum{ cents1 + cents2 };
  std::cout << "I have " << centsSum.getCents() << " cents.\n";

  return 0;
}
```

由于普通函数和友元函数的工作方式几乎相同（它们只是对私有成员的访问级别不同），因此我们通常不会区分它们。唯一的区别是类内部的友元函数声明也充当原型。对于普通函数版本，您必须提供自己的函数原型。

Cents.h：

```cpp
#ifndef CENTS_H
#define CENTS_H

class Cents
{
private:
  int m_cents{};

public:
  Cents(int cents)
    : m_cents{ cents }
  {}

  int getCents() const { return m_cents; }
};

// Need to explicitly provide prototype for operator+ so uses of operator+ in other files know this overload exists
Cents operator+(const Cents& c1, const Cents& c2);

#endif
```

Cents.cpp:

```cpp
#include "Cents.h"

// note: this function is not a member function nor a friend function!
Cents operator+(const Cents& c1, const Cents& c2)
{
  // use the Cents constructor and operator+(int, int)
  // we don't need direct access to private members here
  return { c1.getCents() + c2.getCents() };
}
```

main.cpp:

```cpp
#include "Cents.h"
#include <iostream>

int main()
{
  Cents cents1{ 6 };
  Cents cents2{ 8 };
  Cents centsSum{ cents1 + cents2 }; // without the prototype in Cents.h, this would fail to compile
  std::cout << "I have " << centsSum.getCents() << " cents.\n";

  return 0;
}
```

一般而言，如果可以利用现有的成员函数来实现这一点，则应优先使用普通函数而不是友元函数（接触类内部的函数越少越好）。但是，不要添加额外的访问函数，只是为了将运算符重载为普通函数而不是友元函数！

**最佳实践**

**如果可以在不添加额外函数的情况下实现这一点，则优先将运算符重载为普通函数而不是朋友函数。**

# 21.4 — 重载 I/O 操作符

对于具有多个成员变量的类，在屏幕上打印每个单独的变量很快就会变得令人厌烦。例如，考虑以下类：

```cpp
class Point
{
private:
    double m_x{};
    double m_y{};
    double m_z{};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
      : m_x{x}, m_y{y}, m_z{z}
    {
    }

    double getX() const { return m_x; }
    double getY() const { return m_y; }
    double getZ() const { return m_z; }
};
```

如果您想要将此类的一个实例打印到屏幕上，您必须执行以下操作：

```cpp
Point point { 5.0, 6.0, 7.0 };

std::cout << "Point(" << point.getX() << ", " <<
    point.getY() << ", " <<
    point.getZ() << ')';
```

当然，将其作为可重用函数更有意义。在前面的示例中，您已经看到我们创建了`print()`如下函数：

```cpp
class Point
{
private:
    double m_x{};
    double m_y{};
    double m_z{};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
      : m_x{x}, m_y{y}, m_z{z}
    {
    }

    double getX() const { return m_x; }
    double getY() const { return m_y; }
    double getZ() const { return m_z; }

    void print() const
    {
        std::cout << "Point(" << m_x << ", " << m_y << ", " << m_z << ')';
    }
};
```

虽然这要好得多，但它仍然有一些缺点。因为`print()`返回`void`，它不能在输出语句中间调用。相反，你必须这样做：

```cpp
int main()
{
    const Point point { 5.0, 6.0, 7.0 };

    std::cout << "My point is: ";
    point.print();
    std::cout << " in Cartesian space.\n";
}
```

如果你可以简单地输入以下内容，那就容易多了：

```cpp
Point point{5.0, 6.0, 7.0};
cout << "My point is: " << point << " in Cartesian space.\n";
```

并得到相同的结果。输出不会分散到多个语句中，也不必记住打印函数的名称。

幸运的是，通过超载`operator<<`，您可以！

## 重载`operator<<`

重载`operator<<`与重载 operator+ 类似（都是二元运算符），只是参数类型不同。

考虑表达式`std::cout << point`。如果运算符是`<<`，那么操作数是什么？左操作数是`std::cout`对象，右操作数是`Point`类对象。`std::cout`实际上是 类型的对象`std::ostream`。因此，我们的重载函数将如下所示：

```cpp
// std::ostream is the type for object std::cout
friend std::ostream& operator<< (std::ostream& out, const Point& point);
```

`operator<<`我们类的实现`Point`相当简单——因为 C++ 已经知道如何使用 输出双精度数`operator<<`，并且我们的成员都是双精度数，所以我们可以简单地使用`operator<<`输出我们的 的数据成员`Point`。以下是`Point`重载 的上述类`operator<<`。

```cpp
#include <iostream>

class Point
{
private:
    double m_x{};
    double m_y{};
    double m_z{};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
      : m_x{x}, m_y{y}, m_z{z}
    {
    }

    friend std::ostream& operator<< (std::ostream& out, const Point& point);
};

std::ostream& operator<< (std::ostream& out, const Point& point)
{
    // Since operator<< is a friend of the Point class, we can access Point's members directly.
    out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ')'; // actual output done here

    return out; // return std::ostream so we can chain calls to operator<<
}

int main()
{
    const Point point1 { 2.0, 3.0, 4.0 };

    std::cout << point1 << '\n';

    return 0;
}
```



这非常简单--注意我们的输出行与之前编写的`print()`函数中的输出行是多么相似。最显著的区别是，`std::cout` 变成了参数 `out`（调用函数时，参数`out`将是对`std::cout` 的引用）。

这里最棘手的部分是返回类型。通过算术运算符，我们计算并按值返回了一个答案（因为我们创建并返回了一个新结果）。但是，如果尝试按值返回`std::ostream`，就会出现编译器错误。这是因为 `std::ostream` 明确禁止复制。

在本例中，我们将左侧参数作为引用返回。这不仅可以防止复制 `std::ostream`，还允许我们将输出命令 "链 "在一起，例如 `std::cout << point << '\n'`。

考虑一下如果我们的`operator<<`返回`void`会发生什么。当编译器求值`std::cout << point << '\n'`时，由于优先级/关联性规则，它会将此表达式求值为`(std::cout << point) << '\n';`。`std::cout << point`将调用我们的返回 void 的重载`operator<<`函数，该函数返回`void`。然后部分评估的表达式变为：`void << '\n';`，这毫无意义！

通过将`out`参数作为返回类型返回，`(std::cout << point)`返回`std::cout`。然后我们的部分求值表达式变为：`std::cout << '\n';`，然后它自己被求值！

任何时候，我们希望重载的二元运算符以这种方式链接，左操作数应该被返回（通过引用）。在这种情况下，通过引用返回左侧参数是可以的——因为左侧参数是由调用函数传入的，所以当被调用函数返回时，它必须仍然存在。因此，我们不必担心引用的东西会超出范围并在运算符返回时被破坏。

为了证明它有效，请考虑以下示例，它使用了我们上面编写的重载的 Point 类`operator<<`：

```cpp
#include <iostream>

class Point
{
private:
    double m_x{};
    double m_y{};
    double m_z{};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
      : m_x{x}, m_y{y}, m_z{z}
    {
    }

    friend std::ostream& operator<< (std::ostream& out, const Point& point);
};

std::ostream& operator<< (std::ostream& out, const Point& point)
{
    // Since operator<< is a friend of the Point class, we can access Point's members directly.
    out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ')';

    return out;
}

int main()
{
    Point point1 { 2.0, 3.5, 4.0 };
    Point point2 { 6.0, 7.5, 8.0 };

    std::cout << point1 << ' ' << point2 << '\n';

    return 0;
}
```



其结果如下：

```
Point(2, 3.5, 4) Point(6, 7.5, 8)
```

在上面的例子中，`operator<<`是友元，因为它需要直接访问 的成员`Point`。但是，如果可以通过 getter 访问成员，则`operator<<`可以将其实现为非友元。

## 重载`operator>>`

还可以重载输入运算符。这与重载输出运算符的方式类似。您需要知道的关键是`std::cin`是 类型的对象`std::istream`。以下是添加了`Point`重载的类`operator>>`：

```cpp
#include <iostream>

class Point
{
private:
    double m_x{};
    double m_y{};
    double m_z{};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
      : m_x{x}, m_y{y}, m_z{z}
    {
    }

    friend std::ostream& operator<< (std::ostream& out, const Point& point);
    friend std::istream& operator>> (std::istream& out, Point& point);
};

std::ostream& operator<< (std::ostream& out, const Point& point)
{
    // Since operator<< is a friend of the Point class, we can access Point's members directly.
    out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ')';

    return out;
}

// note that point must be non-const so we can modify the object
std::istream& operator>> (std::istream& in, Point& point)
{
    // This version subject to partial extraction issues (see below)
    in >> point.m_x >> point.m_y >> point.m_z;

    return in;
}

int main()
{
    std::cout << "Enter a point: ";

    Point point{ 1.0, 2.0, 3.0 }; // non-zero test data
    std::cin >> point;

    std::cout << "You entered: " << point << '\n';

    return 0;
}
```

假设用户输入`4.0 5.6 7.26`，程序会产生以下结果：

```
You entered: Point(4, 5.6, 7.26)
```

现在让我们看看当用户输入时会发生什么`4.0b 5.6 7.26`（注意`b`后面的`4.0`）：

```
You entered: Point(4, 0, 3)
```

我们的点现在是一个奇怪的混合体，由一个来自用户输入的值 ( `4.0`)、一个已初始化为零的值 ( `0.0`) 和一个未受输入函数影响的值 ( `3.0`) 组成。这……不太好！

## 防止部分提取

当我们提取单个值时，只有两种可能的结果：提取失败或成功。但是，当我们在输入操作中提取多个值时，事情会变得稍微复杂一些。

上述操作符 >> 的实现可能会导致部分提取。这正是我们在输入`4.0b 5.6 7.26`时看到的情况。对 `x_y`的提取成功地从用户输入中提取出了`4.0`，在输入流中留下了`b 5.6 7.26`。向 `m_y`提取`b`失败，因此`m_y`被复制赋值为 `0.0`，输入流被设置为失败模式。由于我们还没有清除失败模式，对`m_z`的提取立即终止，m_z 在提取尝试之前的值仍然保留`3.0`。

在任何情况下，这都不是理想的结果。在某些情况下，这甚至可能非常危险。想象一下，我们`operator>>`为某个`Fraction`对象编写了一个。成功提取分子后，分母提取失败会将分母设置为`0.0`，这可能会导致除以零并导致应用程序崩溃。

那么我们如何避免这种情况呢？一种方法是让我们的操作具有事务性。**事务操作**必须完全成功或完全失败——不允许部分成功或失败。这有时被称为“全有或全无”。如果在事务期间的任何时候发生故障，则必须撤消操作所做的先前更改。

<u>关键见解</u>

<u>交易在现实生活中无时无刻不在发生。假设我想将钱从一个银行账户转到另一个银行账户。这需要两个步骤：首先必须先从一个账户中扣除这笔钱，然后必须将其存入另一个账户。在执行此操作时，有三种可能性：</u>

- <u>扣款步骤失败（例如资金不足）。交易失败，两个账户余额均未反映该笔转账。</u>
- <u>记账步骤失败（例如由于技术问题）。在这种情况下，必须撤销扣款（已成功）。交易失败，账户余额均未反映转账。</u>
- <u>两个步骤均成功。交易成功，两个账户余额均反映转账情况。</u>

<u>最终的结果是只有两种可能的结果：转账彻底失败，账户余额不变，或者转账成功，账户余额都发生变化。</u>

让我们将重载重新实现`Point` `operator>>`为事务操作：

```cpp
// note that point must be non-const so we can modify the object
// note that this implementation is a non-friend
std::istream& operator>> (std::istream& in, Point& point)
{
    double x{};
    double y{};
    double z{};

    if (in >> x >> y >> z)      // if all extractions succeeded
        point = Point{x, y, z}; // overwrite our existing point

    return in;
}
```

在此实现中，我们不会直接用用户的输入覆盖数据成员。相反，我们将用户的输入提取到临时变量（`x`、`y`和`z`）中。一旦所有提取尝试都完成，我们将检查所有提取是否都成功。如果成功，我们将一起更新 的所有成员`Point`。否则，我们不会更新任何成员。

**提示**

**`if (in >> x >> y >> z)`相当于`in >> x >> y >> z; if (in)`。请记住，每次提取都会返回，`in`因此可以将多个提取链接在一起。单语句版本使用`in`上次提取返回的作为 if 语句的条件，而多语句版本则`in`显式使用。**

<u>提示</u>

<u>事务操作可以使用多种不同的策略来实现。例如：</u>

- <u>成功时更改：存储每个子操作的结果。如果所有子操作都成功，则用存储的结果替换相关数据。这是我们在`Point`上面的示例中使用的策略。</u>
- <u>失败时恢复：复制任何可以更改的数据。如果任何子操作失败，可以使用复制的数据恢复先前子操作所做的更改。</u>
- <u>失败时回滚：如果任何子操作失败，则每个先前的子操作都会被撤销（使用相反的子操作）。此策略通常用于数据库，因为数据太大而无法备份，并且子操作的结果无法存储。</u>

虽然上述方法`operator>>`可以防止部分提取，但它与基本类型的工作方式不一致`operator>>`。当提取到具有基本类型的对象失败时，该对象不会保持不变——它会被复制赋值`0`（这可确保对象具有一些一致的值，以防在提取尝试之前未初始化）。因此，为了保持一致性，您可能希望在提取失败时将对象重置为其默认状态（至少在存在这种情况的情况下）。

这是替代版本，如果任何提取失败，`operator>>`则会重置`Point`为其默认状态：

```cpp
// note that point must be non-const so we can modify the object
// note that this implementation is a non-friend
std::istream& operator>> (std::istream& in, Point& point)
{
    double x{};
    double y{};
    double z{};

    in >> x >> y >> z;
    point = in ? Point{x, y, z} : Point{};

    return in;
}
```

**作者注**

**从技术上讲，这样的操作不再是事务性的（因为失败不会“什么都不做”）。似乎没有一个通用术语来描述不保证部分结果的操作。也许是“不可分割的操作”。**

## 处理语义上无效的输入

提取可能会因多种原因而失败。

如果`operator>>`无法将任何内容提取到变量中，`std::cin`则会自动进入故障模式（我们将在课程[9.5 中讨论 - std::cin 和处理无效输入]）。然后，此函数的调用者可以检查`std::cin`它是否失败并根据需要处理该情况。

但是，如果用户输入的值可提取但语义无效（例如，`Fraction`分母为`0`），该怎么办？因为`std::cin`确实提取了某些内容，所以它不会自动进入失败模式。然后调用者可能不会意识到出了问题。

为了解决这个问题，我们可以让重载`operator>>`确定提取的任何值是否在语义上无效，如果是，则手动将输入流置于故障模式。这可以通过调用来完成`std::cin.setstate(std::ios_base::failbit);`。

下面是一个事务重载的示例，如果用户输入可提取的负值，它将导致输入流进入故障模式`operator>>`：`Point`

```cpp
std::istream& operator>> (std::istream& in, Point& point)
{
    double x{};
    double y{};
    double z{};

    in >> x >> y >> z;
    if (x < 0.0 || y < 0.0 || z < 0.0)       // if any extractable input is negative
        in.setstate(std::ios_base::failbit); // set failure mode manually
    point = in ? Point{x, y, z} : Point{};

    return in;
}
```

## 结论

重载`operator<<`并`operator>>`轻松地将您的类输出到屏幕并从控制台接受用户输入。

## 测验时间

### 问题 #1

以下面的 Fraction 类为例，添加一个`operator>>`和`operator>>`。`operator>>`应避免部分提取，如果用户输入的分母为`0`，则操作失败。

下面的程序应该可以编译：

```cpp
int main()
{
	Fraction f1{};
	std::cout << "Enter fraction 1: ";
	std::cin >> f1;

	Fraction f2{};
	std::cout << "Enter fraction 2: ";
	std::cin >> f2;

	std::cout << f1 << " * " << f2 << " is " << f1 * f2 << '\n'; // note: The result of f1 * f2 is an r-value

	return 0;
}
```

并产生结果：

```
Enter fraction 1: 2/3
Enter fraction 2: 3/8
2/3 * 3/8 is 1/4
```

这是 Fraction 类：

```cpp
#include <iostream>
#include <numeric> // for std::gcd

class Fraction
{
private:
	int m_numerator{};
	int m_denominator{};

public:
	Fraction(int numerator=0, int denominator=1):
		m_numerator{numerator}, m_denominator{denominator}
	{
		// We put reduce() in the constructor to ensure any new fractions we make get reduced!
		// Any fractions that are overwritten will need to be re-reduced
		reduce();
	}

	void reduce()
	{
		int gcd{ std::gcd(m_numerator, m_denominator) };
		if (gcd)
		{
			m_numerator /= gcd;
			m_denominator /= gcd;
		}
	}

	friend Fraction operator*(const Fraction& f1, const Fraction& f2);
	friend Fraction operator*(const Fraction& f1, int value);
	friend Fraction operator*(int value, const Fraction& f1);

	void print() const
	{
		std::cout << m_numerator << '/' << m_denominator << '\n';
	}
};

Fraction operator*(const Fraction& f1, const Fraction& f2)
{
	return Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };
}

Fraction operator*(const Fraction& f1, int value)
{
	return Fraction { f1.m_numerator * value, f1.m_denominator };
}

Fraction operator*(int value, const Fraction& f1)
{
	return Fraction { f1.m_numerator * value, f1.m_denominator };
}
```

如果您使用的是 C++17 之前的编译器，则可以用此函数替换 std::gcd：

```cpp
#include <cmath>

int gcd(int a, int b) {
    return (b == 0) ? std::abs(a) : gcd(b, a % b);
}
```

```cpp
#include <iostream>
#include <limits>
#include <numeric> // for std::gcd

class Fraction
{
private:
    int m_numerator{ 0 };
    int m_denominator{ 1 };

public:
    Fraction(int numerator=0, int denominator = 1) :
        m_numerator{ numerator }, m_denominator{ denominator }
    {
        // We put reduce() in the constructor to ensure any new fractions we make get reduced!
        // Any fractions that are overwritten will need to be re-reduced
        reduce();
    }

    void reduce()
    {
        int gcd{ std::gcd(m_numerator, m_denominator) };
        if (gcd)
        {
            m_numerator /= gcd;
            m_denominator /= gcd;
        }
    }

    friend Fraction operator*(const Fraction& f1, const Fraction& f2);
    friend Fraction operator*(const Fraction& f1, int value);
    friend Fraction operator*(int value, const Fraction& f1);

    friend std::ostream& operator<<(std::ostream& out, const Fraction& f1);

    void print() const
    {
        std::cout << m_numerator << '/' << m_denominator << '\n';
    }
};

Fraction operator*(const Fraction& f1, const Fraction& f2)
{
    return Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };
}

Fraction operator*(const Fraction& f1, int value)
{
    return Fraction { f1.m_numerator * value, f1.m_denominator };
}

Fraction operator*(int value, const Fraction& f1)
{
    return Fraction { f1.m_numerator * value, f1.m_denominator };
}

std::ostream& operator<<(std::ostream& out, const Fraction& f1)
{
    out << f1.m_numerator << '/' << f1.m_denominator;
    return out;
}

std::istream& operator>>(std::istream& in, Fraction& f1)
{
    int numerator {};
    char ignore {};
    int denominator {};

    in >> numerator >> ignore >> denominator;
    if (denominator == 0)                       // if our denominator is semantically invalid
        in.setstate(std::ios_base::failbit);    // set failure mode manually
    if (in)                                     // if we're not in failure mode
        f1 = Fraction {numerator, denominator}; // update our object to the extracted values

    return in;
}

int main()
{
    Fraction f1{};
    std::cout << "Enter fraction 1: ";
    std::cin >> f1;

    Fraction f2{};
    std::cout << "Enter fraction 2: ";
    std::cin >> f2;

    std::cout << f1 << " * " << f2 << " is " << f1 * f2 << '\n'; // note: The result of f1 * f2 is an r-value

    return 0;
}
```

# 21.5 — 使用成员函数重载运算符

在课程[21.2 — 使用友元函数重载算术运算符](https://www.learncpp.com/cpp-tutorial/overloading-the-arithmetic-operators-using-friend-functions/)中，您学习了如何使用友元函数重载算术运算符。您还学习了可以将运算符重载为普通函数。许多运算符可以以不同的方式重载：作为成员函数。

使用成员函数重载运算符与使用友元函数重载运算符非常相似。使用成员函数重载运算符时：

- 必须将重载运算符添加为左操作数的成员函数。
- 左操作数成为隐式的 *this 对象
- 所有其他操作数都成为函数参数。

提醒一下，下面是我们如何使用友元函数重载 operator+ 的方法：

```cpp
#include <iostream>

class Cents
{
private:
    int m_cents {};

public:
    Cents(int cents)
        : m_cents { cents } { }

    // Overload Cents + int
    friend Cents operator+(const Cents& cents, int value);

    int getCents() const { return m_cents; }
};

// note: this function is not a member function!
Cents operator+(const Cents& cents, int value)
{
    return Cents(cents.m_cents + value);
}

int main()
{
	const Cents cents1 { 6 };
	const Cents cents2 { cents1 + 2 };
	std::cout << "I have " << cents2.getCents() << " cents.\n";

	return 0;
}
```

将友元(friend)重载运算符转换为成员(member)重载运算符很容易：

1. 重载运算符被定义为成员而不是朋友（Cents::operator+ 而不是friend operator+）
2. 左边的参数被删除，因为该参数现在变成了隐式的 *this 对象。
3. 在函数主体内部，可以删除对左侧参数的所有引用（例如 cents.m_cents 变成 m_cents，它隐式引用 *this 对象）。

现在，使用成员函数方法重载相同的运算符：

```cpp
#include <iostream>

class Cents
{
private:
    int m_cents {};

public:
    Cents(int cents)
        : m_cents { cents } { }

    // Overload Cents + int
    Cents operator+(int value) const;

    int getCents() const { return m_cents; }
};

// note: this function is a member function!
// the cents parameter in the friend version is now the implicit *this parameter
Cents Cents::operator+ (int value) const
{
    return Cents { m_cents + value };
}

int main()
{
	const Cents cents1 { 6 };
	const Cents cents2 { cents1 + 2 };
	std::cout << "I have " << cents2.getCents() << " cents.\n";

	return 0;
}
```

请注意，运算符的用法没有改变（在这两种情况下`cents1 + 2`），我们只是以不同的方式定义了函数。我们的双参数友元函数变成了单参数成员函数，友元版本中最左边的参数（cents）变成了成员函数版本中隐式的 *this 参数。

让我们仔细看看表达式是如何`cents1 + 2`求值的。

在友元函数版本中，表达式`cents1 + 2`变为函数调用运算符 + (cents1, 2)。请注意，有两个函数参数。这很简单。

在成员函数版本中，表达式`cents1 + 2`变为函数调用`cents1.operator+(2)`。请注意，现在只有一个显式函数参数，而 cents1 已成为对象前缀。但是，在[第 15.1 课——隐藏的“this”指针和成员函数链](https://www.learncpp.com/cpp-tutorial/the-hidden-this-pointer-and-member-function-chaining/)中，我们提到编译器会将对象前缀隐式转换为名为 *this 的隐藏最左参数。因此实际上，`cents1.operator+(2)`变为`operator+(&cents1, 2)`，这几乎与友元版本相同。

两种情况都会产生相同的结果，只是方式略有不同。

那么，如果我们可以将运算符重载为朋友或成员，我们应该使用哪一个？为了回答这个问题，您还需要了解一些事情。

## **并非所有东西都可以作为友元函数重载**

赋值（=）、下标（[]）、函数调用（()）和成员选择（->）运算符必须重载为成员函数，因为语言要求它们这样做。

## **并非所有东西都可以重载为成员函数**

在课程[21.4 -- 重载 I/O 运算符]中，我们使用友元函数方法为 Point 类重载了运算符<<。以下是我们如何做到这一点的回顾：

```cpp
#include <iostream>

class Point
{
private:
    double m_x {};
    double m_y {};
    double m_z {};

public:
    Point(double x=0.0, double y=0.0, double z=0.0)
        : m_x { x }, m_y { y }, m_z { z }
    {
    }

    friend std::ostream& operator<< (std::ostream& out, const Point& point);
};

std::ostream& operator<< (std::ostream& out, const Point& point)
{
    // Since operator<< is a friend of the Point class, we can access Point's members directly.
    out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ")";

    return out;
}

int main()
{
    Point point1 { 2.0, 3.0, 4.0 };

    std::cout << point1;

    return 0;
}
```

但是，我们不能将运算符<<重载为成员函数。为什么不能？因为必须将重载运算符添加为左操作数的成员。在这种情况下，左操作数是 std::ostream 类型的对象。std::ostream 是标准库的一部分。我们无法修改类声明以将重载添加为 std::ostream 的成员函数。

这就要求将 operator<< 重载为普通函数（首选）或友元。

类似地，虽然我们可以将 operator+(Cents, int) 重载为成员函数（如上面所做的那样），但我们不能将 operator+(int, Cents) 重载为成员函数，因为 int 不是我们可以添加成员的类。

通常，如果左操作数不是类（例如 int），或者是我们无法修改的类（例如 std::ostream），我们将无法使用成员重载。

## **何时使用普通函数、友元函数或成员函数重载**

在大多数情况下，语言会让您自行决定是否要使用重载的普通/友元或成员函数版本。但是，两者中的一个通常是比另一个更好的选择。

当处理不修改左操作数的二元运算符（例如，operator+）时，通常首选普通或友元函数版本，因为它适用于所有参数类型（即使左操作数不是类对象，或者是不可修改的类）。普通或友元函数版本具有“对称”的额外优势，因为所有操作数都成为显式参数（而不是左操作数成为 *this，右操作数成为显式参数）。

当处理会修改左操作数的二元运算符（例如，operator+=）时，通常首选成员函数版本。在这些情况下，最左边的操作数将始终是类类型，并且让被修改的对象成为 *this 指向的对象是很自然的。由于最右边的操作数成为显式参数，因此不会混淆谁被修改以及谁被求值。

一元运算符通常也被重载为成员函数，因为成员版本没有参数。

以下经验法则可以帮助您确定哪种形式最适合特定情况：

- 如果要重载赋值（=）、下标（[]）、函数调用（()）或成员选择（->），请将其作为成员函数执行。
- 如果要重载一元运算符，请将其作为成员函数来执行。
- 如果要重载不修改其左操作数的二元运算符（例如，operator+），请将其作为普通函数（首选）或友元函数执行。
- 如果要重载修改其左操作数的二元运算符，但不能将成员添加到左操作数的类定义中（例如，operator<<，其左操作数为 ostream 类型），则请将其作为普通函数（首选）或友元函数执行。
- 如果您重载了修改其左操作数的二元运算符（例如，operator+=），并且可以修改左操作数的定义，请将其作为成员函数来执行。

# 21.6 — 重载一元运算符 +、- 和！

## **重载一元运算符**

与您迄今为止看到的运算符不同，正运算符 (+)、负运算符 (-) 和逻辑非运算符 (!) 都是一元运算符，这意味着它们只对一个操作数进行操作。由于它们只对所应用的对象进行操作，因此一元运算符重载通常作为成员函数实现。这三个运算符的实现方式相同。

让我们看一下如何在前面的示例中使用的 Cents 类上实现运算符：

```cpp
#include <iostream>

class Cents
{
private:
    int m_cents {}
public:
    Cents(int cents): m_cents{cents} {}

    // Overload -Cents as a member function
    Cents operator-() const;

    int getCents() const { return m_cents; }
};

// note: this function is a member function!
Cents Cents::operator-() const
{
    return -m_cents; // since return type is a Cents, this does an implicit conversion from int to Cents using the Cents(int) constructor
}

int main()
{
    const Cents nickle{ 5 };
    std::cout << "A nickle of debt is worth " << (-nickle).getCents() << " cents\n";

    return 0;
}
```

这应该很简单。我们的重载负运算符 (-) 是一个作为成员函数实现的一元运算符，因此它不需要任何参数（它对 *this 对象进行操作）。它返回一个 Cents 对象，该对象是原始 Cents 值的负数。由于运算符 - 不会修改 Cents 对象，因此我们可以（并且应该）将其设为 const 函数（因此可以在 const Cents 对象上调用它）。

请注意，负运算符和减运算符之间不会混淆，因为它们的参数数量不同。

这是另一个例子。 ! 运算符是逻辑否定运算符——如果表达式求值为“真”，则运算符 ! 将返回 false，反之亦然。我们通常看到它应用于布尔变量以测试它们是否为真：

```cpp
if (!isHappy)
    std::cout << "I am not happy!\n";
else
    std::cout << "I am so happy!\n";
```

对于整数，0 的计算结果为 false，其他任何值都为 true，因此，当将运算符！应用于整数时，如果整数值为 0，则返回 true，否则返回 false。

扩展这个概念，我们可以说，如果对象的状态为“false”、“零”或任何默认初始化状态，则运算符！的计算结果应该为 true。

下面的示例显示了用户定义的 Point 类的 operator- 和 operator! 的重载：

```cpp
#include <iostream>

class Point
{
private:
    double m_x {};
    double m_y {};
    double m_z {};

public:
    Point(double x=0.0, double y=0.0, double z=0.0):
        m_x{x}, m_y{y}, m_z{z}
    {
    }

    // Convert a Point into its negative equivalent
    Point operator- () const;

    // Return true if the point is set at the origin
    bool operator! () const;

    double getX() const { return m_x; }
    double getY() const { return m_y; }
    double getZ() const { return m_z; }
};

// Convert a Point into its negative equivalent
Point Point::operator- () const
{
    return { -m_x, -m_y, -m_z };
}

// Return true if the point is set at the origin, false otherwise
bool Point::operator! () const
{
    return (m_x == 0.0 && m_y == 0.0 && m_z == 0.0);
}

int main()
{
    Point point{}; // use default constructor to set to (0.0, 0.0, 0.0)

    if (!point)
        std::cout << "point is set at the origin.\n";
    else
        std::cout << "point is not set at the origin.\n";

    return 0;
}
```

如果 Point 设置为坐标 (0.0, 0.0, 0.0) 处的默认值，则此类的重载运算符！将返回布尔值“true”。因此，上述代码产生结果：

```
point is set at the origin.
```

**测验时间**

1. `operator+`为 Point 类实现重载一元操作数。一元操作数`operator+`只返回其操作数（不会将负值变为正值）。

这是一个显而易见的解决方案：

```cpp
Point Point::operator+ () const
{
    return { m_x, m_y, m_z };
}
```

但是因为我们返回的 Point 与我们正在操作的 Point 完全相同，所以下面的方法也有效：

```cpp
Point Point::operator+ () const
{
    return *this;
}
```

请注意，我们在这里返回的是值副本，而不是 const 引用。这是因为此函数的用户可能希望返回的对象是可修改的。

# 21.7 — 重载比较运算符

在课程[6.7 — 关系运算符和浮点比较]3中，我们讨论了六个比较运算符。重载这些比较运算符相对简单（看看我做了什么？），因为它们遵循我们在重载其他运算符时看到的相同模式。

因为比较运算符都是不修改其左操作数的二元运算符，所以我们将把重载的比较运算符设为友元函数。

这是一个具有重载运算符 == 和运算符 != 的 Car 类示例。

```cpp
#include <iostream>
#include <string>
#include <string_view>

class Car
{
private:
    std::string m_make;
    std::string m_model;

public:
    Car(std::string_view make, std::string_view model)
        : m_make{ make }, m_model{ model }
    {
    }

    friend bool operator== (const Car& c1, const Car& c2);
    friend bool operator!= (const Car& c1, const Car& c2);
};

bool operator== (const Car& c1, const Car& c2)
{
    return (c1.m_make == c2.m_make &&
            c1.m_model == c2.m_model);
}

bool operator!= (const Car& c1, const Car& c2)
{
    return (c1.m_make != c2.m_make ||
            c1.m_model != c2.m_model);
}

int main()
{
    Car corolla{ "Toyota", "Corolla" };
    Car camry{ "Toyota", "Camry" };

    if (corolla == camry)
        std::cout << "a Corolla and Camry are the same.\n";

    if (corolla != camry)
        std::cout << "a Corolla and Camry are not the same.\n";

    return 0;
}
```

这里的代码应该很简单。

那么运算符<和运算符>呢？一辆汽车大于或小于另一辆汽车意味着什么？我们通常不会这样考虑汽车。由于运算符<和运算符>的结果不是立即直观的，因此最好不要定义这些运算符。

**最佳实践**

**仅定义对你的类具有直观意义的重载运算符。**

但是，上述建议有一个常见的例外。如果我们想对汽车列表进行排序怎么办？在这种情况下，我们可能希望重载比较运算符以返回您最有可能要排序的成员（或成员）。例如，汽车的重载运算符<可能根据品牌和型号按字母顺序排序。

标准库中的某些容器类（包含其他类集合的类）需要重载运算符<，以便它们可以保持元素排序。

下面是重载所有 6 个逻辑比较运算符的不同示例：

```cpp
#include <iostream>

class Cents
{
private:
    int m_cents;

public:
    Cents(int cents)
	: m_cents{ cents }
	{}

    friend bool operator== (const Cents& c1, const Cents& c2);
    friend bool operator!= (const Cents& c1, const Cents& c2);

    friend bool operator< (const Cents& c1, const Cents& c2);
    friend bool operator> (const Cents& c1, const Cents& c2);

    friend bool operator<= (const Cents& c1, const Cents& c2);
    friend bool operator>= (const Cents& c1, const Cents& c2);
};

bool operator== (const Cents& c1, const Cents& c2)
{
    return c1.m_cents == c2.m_cents;
}

bool operator!= (const Cents& c1, const Cents& c2)
{
    return c1.m_cents != c2.m_cents;
}

bool operator> (const Cents& c1, const Cents& c2)
{
    return c1.m_cents > c2.m_cents;
}

bool operator< (const Cents& c1, const Cents& c2)
{
    return c1.m_cents < c2.m_cents;
}

bool operator<= (const Cents& c1, const Cents& c2)
{
    return c1.m_cents <= c2.m_cents;
}

bool operator>= (const Cents& c1, const Cents& c2)
{
    return c1.m_cents >= c2.m_cents;
}

int main()
{
    Cents dime{ 10 };
    Cents nickel{ 5 };

    if (nickel > dime)
        std::cout << "a nickel is greater than a dime.\n";
    if (nickel >= dime)
        std::cout << "a nickel is greater than or equal to a dime.\n";
    if (nickel < dime)
        std::cout << "a dime is greater than a nickel.\n";
    if (nickel <= dime)
        std::cout << "a dime is greater than or equal to a nickel.\n";
    if (nickel == dime)
        std::cout << "a dime is equal to a nickel.\n";
    if (nickel != dime)
        std::cout << "a dime is not equal to a nickel.\n";

    return 0;
}
```

这也非常简单。

## 最小化比较冗余

在上面的例子中，请注意每个重载比较运算符的实现有多么相似。重载比较运算符往往具有高度的冗余，并且实现越复杂，冗余就会越多。

幸运的是，许多比较运算符可以使用其他比较运算符来实现：

- operator!= 可以实现为 !(operator==)
- 运算符> 可以实现为运算符<，并将参数的顺序翻转
- operator>= 可以实现为 !(operator<)
- operator<= 可以实现为 !(operator>)

这意味着我们只需要实现运算符==和运算符<的逻辑，然后其他四个比较运算符就可以根据这两个运算符来定义！下面是一个更新的Cents示例，说明了这一点：

```cpp
#include <iostream>

class Cents
{
private:
    int m_cents;

public:
    Cents(int cents)
        : m_cents{ cents }
    {}

    friend bool operator== (const Cents& c1, const Cents& c2) { return c1.m_cents == c2.m_cents; }
    friend bool operator!= (const Cents& c1, const Cents& c2) { return !(operator==(c1, c2)); }

    friend bool operator< (const Cents& c1, const Cents& c2) { return c1.m_cents < c2.m_cents; }
    friend bool operator> (const Cents& c1, const Cents& c2) { return operator<(c2, c1); }

    friend bool operator<= (const Cents& c1, const Cents& c2) { return !(operator>(c1, c2)); }
    friend bool operator>= (const Cents& c1, const Cents& c2) { return !(operator<(c1, c2)); }

};

int main()
{
    Cents dime{ 10 };
    Cents nickel{ 5 };

    if (nickel > dime)
        std::cout << "a nickel is greater than a dime.\n";
    if (nickel >= dime)
        std::cout << "a nickel is greater than or equal to a dime.\n";
    if (nickel < dime)
        std::cout << "a dime is greater than a nickel.\n";
    if (nickel <= dime)
        std::cout << "a dime is greater than or equal to a nickel.\n";
    if (nickel == dime)
        std::cout << "a dime is equal to a nickel.\n";
    if (nickel != dime)
        std::cout << "a dime is not equal to a nickel.\n";

    return 0;
}
```

这样，如果我们需要改变某些东西，我们只需要更新 operator== 和 operator< ，而不是所有六个比较运算符！

## **The spaceship operator** <=> C++20

C++20 引入了宇宙飞船运算符（`operator<=>`），这使得我们可以将需要编写的比较函数的数量减少到最多 2 个，有时只需 1 个！

作者注

我们打算很快增加一节有关这个主题的新课程。在那之前，请考虑一下这是否能激起你的兴趣——但你必须离开网站才能发现更多。

**测验时间**

1. 将六个比较运算符添加到 Fraction 类，以便编译以下程序：

```cpp
#include <iostream>
#include <numeric> // for std::gcd

class Fraction
{
private:
	int m_numerator{};
	int m_denominator{};

public:
	Fraction(int numerator = 0, int denominator = 1) :
		m_numerator{ numerator }, m_denominator{ denominator }
	{
		// We put reduce() in the constructor to ensure any new fractions we make get reduced!
		// Any fractions that are overwritten will need to be re-reduced
		reduce();
	}

	void reduce()
	{
		int gcd{ std::gcd(m_numerator, m_denominator) };
		if (gcd)
		{
			m_numerator /= gcd;
			m_denominator /= gcd;
		}
	}

	friend std::ostream& operator<<(std::ostream& out, const Fraction& f1);
};

std::ostream& operator<<(std::ostream& out, const Fraction& f1)
{
	out << f1.m_numerator << '/' << f1.m_denominator;
	return out;
}

int main()
{
	Fraction f1{ 3, 2 };
	Fraction f2{ 5, 8 };

	std::cout << f1 << ((f1 == f2) ? " == " : " not == ") << f2 << '\n';
	std::cout << f1 << ((f1 != f2) ? " != " : " not != ") << f2 << '\n';
	std::cout << f1 << ((f1 < f2) ? " < " : " not < ") << f2 << '\n';
	std::cout << f1 << ((f1 > f2) ? " > " : " not > ") << f2 << '\n';
	std::cout << f1 << ((f1 <= f2) ? " <= " : " not <= ") << f2 << '\n';
	std::cout << f1 << ((f1 >= f2) ? " >= " : " not >= ") << f2 << '\n';
	return 0;
}
```

如果您使用的是 C++17 之前的编译器，则可以用此函数替换 std::gcd：

```cpp
#include <cmath>

int gcd(int a, int b) {
    return (b == 0) ? std::abs(a) : gcd(b, a % b);
}
```

```cpp
#include <iostream>
#include <numeric> // for std::gcd

class Fraction
{
private:
	int m_numerator{};
	int m_denominator{};

public:
	Fraction(int numerator = 0, int denominator = 1) :
		m_numerator{ numerator }, m_denominator{ denominator }
	{
		// We put reduce() in the constructor to ensure any new fractions we make get reduced!
		// Any fractions that are overwritten will need to be re-reduced
		reduce();
	}

	void reduce()
	{
		int gcd{ std::gcd(m_numerator, m_denominator) };
		if (gcd)
		{
			m_numerator /= gcd;
			m_denominator /= gcd;
		}
	}

	friend bool operator== (const Fraction& f1, const Fraction& f2);
	friend bool operator!= (const Fraction& f1, const Fraction& f2);

	friend bool operator< (const Fraction& f1, const Fraction& f2);
	friend bool operator> (const Fraction& f1, const Fraction& f2);

	friend bool operator<= (const Fraction& f1, const Fraction& f2);
	friend bool operator>= (const Fraction& f1, const Fraction& f2);

	friend std::ostream& operator<<(std::ostream& out, const Fraction& f1);
};

std::ostream& operator<<(std::ostream& out, const Fraction& f1)
{
	out << f1.m_numerator << '/' << f1.m_denominator;
	return out;
}

bool operator== (const Fraction& f1, const Fraction& f2)
{
	return (f1.m_numerator == f2.m_numerator) && (f1.m_denominator == f2.m_denominator);
}

bool operator!= (const Fraction& f1, const Fraction& f2)
{
	return !(operator==(f1, f2));
}

bool operator< (const Fraction& f1, const Fraction& f2)
{
	return (f1.m_numerator * f2.m_denominator < f2.m_numerator * f1.m_denominator);
}

bool operator> (const Fraction& f1, const Fraction& f2)
{
	return operator<(f2, f1);
}

bool operator<= (const Fraction& f1, const Fraction& f2)
{
	return !(operator>(f1, f2));
}

bool operator>= (const Fraction& f1, const Fraction& f2)
{
	return !(operator<(f1, f2));
}

int main()
{
	Fraction f1{ 3, 2 };
	Fraction f2{ 5, 8 };

	std::cout << f1 << ((f1 == f2) ? " == " : " not == ") << f2 << '\n';
	std::cout << f1 << ((f1 != f2) ? " != " : " not != ") << f2 << '\n';
	std::cout << f1 << ((f1 < f2) ? " < " : " not < ") << f2 << '\n';
	std::cout << f1 << ((f1 > f2) ? " > " : " not > ") << f2 << '\n';
	std::cout << f1 << ((f1 <= f2) ? " <= " : " not <= ") << f2 << '\n';
	std::cout << f1 << ((f1 >= f2) ? " >= " : " not >= ") << f2 << '\n';

	return 0;
}
```

1. 在课程顶部向 Car 类添加重载的 operator<< 和 operator< ，以便编译以下程序：

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

int main()
{
  std::vector<Car> cars{
    { "Toyota", "Corolla" },
    { "Honda", "Accord" },
    { "Toyota", "Camry" },
    { "Honda", "Civic" }
  };

  std::sort(cars.begin(), cars.end()); // requires an overloaded operator<

  for (const auto& car : cars)
    std::cout << car << '\n'; // requires an overloaded operator<<

  return 0;
}
```



该程序应产生以下输出：



```
(Honda, Accord)
(Honda, Civic)
(Toyota, Camry)
(Toyota, Corolla)
```

如果您需要复习 std::sort，我们将在[第 18.1 课“使用选择排序对数组进行排序”]中讨论它。

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <string_view>
#include <vector>

class Car
{
private:
    std::string m_make;
    std::string m_model;

public:
    Car(std::string_view make, std::string_view model)
        : m_make{ make }, m_model{ model }
    {
    }

    friend bool operator==(const Car& c1, const Car& c2);
    friend bool operator!=(const Car& c1, const Car& c2);

    friend std::ostream& operator<<(std::ostream& out, const Car& c)
    {
        out << '(' << c.m_make << ", " << c.m_model << ')';
        return out;
    }

    // h/t to reader Olivier for the initial version of the function
    friend bool operator<(const Car& c1, const Car& c2)
    {
        if (c1.m_make != c2.m_make) // If the car is not the same make...
            return c1.m_make < c2.m_make; // ...then compare the make

        return c1.m_model < c2.m_model; // otherwise compare the model
    }
};

bool operator==(const Car& c1, const Car& c2)
{
    return c1.m_make == c2.m_make && c1.m_model == c2.m_model;
}

bool operator!= (const Car& c1, const Car& c2)
{
    return !operator==(c1, c2);
}

int main()
{
    std::vector<Car> cars{
      { "Toyota", "Corolla" },
      { "Honda", "Accord" },
      { "Toyota", "Camry" },
      { "Honda", "Civic" }
    };

    std::sort(cars.begin(), cars.end()); // requires an overloaded Car::operator<

    for (const auto& car : cars)
        std::cout << car << '\n'; // requires an overloaded Car::operator<<

    return 0;
}
```

# 21.8 — 重载增量和减量运算符

重载增量 ( `++`) 和减量 ( `--`) 运算符非常简单，只有一小点例外。增量和减量运算符实际上有两个版本：前缀增量和减量（例如`++x; --y;`）和后缀增量和减量（例如`x++; y--;`）。

由于增量和减量运算符都是一元运算符，并且它们会修改操作数，因此最好将它们重载为成员函数。我们将首先处理前缀版本，因为它们最直接。

## **重载前缀增量和减量**

前缀递增和递减的重载方式与任何普通一元运算符完全相同。我们通过以下示例来说明：

```cpp
#include <iostream>

class Digit
{
private:
    int m_digit{};
public:
    Digit(int digit=0)
        : m_digit{digit}
    {
    }

    Digit& operator++();
    Digit& operator--();

    friend std::ostream& operator<< (std::ostream& out, const Digit& d);
};

Digit& Digit::operator++()
{
    // If our number is already at 9, wrap around to 0
    if (m_digit == 9)
        m_digit = 0;
    // otherwise just increment to next number
    else
        ++m_digit;

    return *this;
}

Digit& Digit::operator--()
{
    // If our number is already at 0, wrap around to 9
    if (m_digit == 0)
        m_digit = 9;
    // otherwise just decrement to next number
    else
        --m_digit;

    return *this;
}

std::ostream& operator<< (std::ostream& out, const Digit& d)
{
	out << d.m_digit;
	return out;
}

int main()
{
    Digit digit { 8 };

    std::cout << digit;
    std::cout << ++digit;
    std::cout << ++digit;
    std::cout << --digit;
    std::cout << --digit;

    return 0;
}
```

我们的 Digit 类保存一个 0 到 9 之间的数字。我们已经重载了增量和减量，因此它们会增加/减少数字，如果数字的增加/减少超出范围，则会回绕。

此示例打印：

```
89098
```

注意我们返回的是 *this。重载的增量和减量运算符返回当前隐式对象，因此多个运算符可以“链接”在一起。

## **重载后缀增量和减量**

通常，当函数具有相同的名称但参数数量和/或类型不同时，它们可以重载。但是，请考虑前缀和后缀增量和减量运算符的情况。它们具有相同的名称（例如，operator++），都是一元的，并且采用相同类型的一个参数。那么在重载时如何区分这两者呢？

C++ 语言规范中有一个特殊情况可以给出答案：编译器会检查重载运算符是否具有 int 参数。如果重载运算符具有 int 参数，则该运算符为后缀重载。如果重载运算符没有参数，则该运算符为前缀重载。

这是上述具有前缀和后缀重载的 Digit 类：

```cpp
class Digit
{
private:
    int m_digit{};
public:
    Digit(int digit=0)
        : m_digit{digit}
    {
    }

    Digit& operator++(); // prefix has no parameter
    Digit& operator--(); // prefix has no parameter

    Digit operator++(int); // postfix has an int parameter
    Digit operator--(int); // postfix has an int parameter

    friend std::ostream& operator<< (std::ostream& out, const Digit& d);
};

// No parameter means this is prefix operator++
Digit& Digit::operator++()
{
    // If our number is already at 9, wrap around to 0
    if (m_digit == 9)
        m_digit = 0;
    // otherwise just increment to next number
    else
        ++m_digit;

    return *this;
}

// No parameter means this is prefix operator--
Digit& Digit::operator--()
{
    // If our number is already at 0, wrap around to 9
    if (m_digit == 0)
        m_digit = 9;
    // otherwise just decrement to next number
    else
        --m_digit;

    return *this;
}

// int parameter means this is postfix operator++
Digit Digit::operator++(int)
{
    // Create a temporary variable with our current digit 
    Digit temp{*this};

    // Use prefix operator to increment this digit 通过返回暂时变量同时用this自增加
    ++(*this); // apply operator

    // return temporary result
    return temp; // return saved state
}

// int parameter means this is postfix operator--
Digit Digit::operator--(int)
{
    // Create a temporary variable with our current digit
    Digit temp{*this};

    // Use prefix operator to decrement this digit
    --(*this); // apply operator

    // return temporary result
    return temp; // return saved state
}

std::ostream& operator<< (std::ostream& out, const Digit& d)
{
	out << d.m_digit;
	return out;
}

int main()
{
    Digit digit { 5 };

    std::cout << digit;
    std::cout << ++digit; // calls Digit::operator++();
    std::cout << digit++; // calls Digit::operator++(int);
    std::cout << digit;
    std::cout << --digit; // calls Digit::operator--();
    std::cout << digit--; // calls Digit::operator--(int);
    std::cout << digit;

    return 0;
}
```

```
5667665
```

这里有一些有趣的事情。首先，请注意，我们通过在后缀版本上提供一个整数虚拟参数来区分前缀和后缀运算符。其次，由于函数实现中未使用虚拟参数，因此我们甚至没有为其命名。这告诉编译器将此变量视为占位符，这意味着它不会警告我们声明了一个变量但从未使用过它。

第三，请注意前缀和后缀运算符的作用相同——它们都增加或减少对象。两者的区别在于它们返回的值。重载的前缀运算符在对象增加或减少后返回该对象。因此，重载这些运算符相当简单。我们只需增加或减少我们的成员变量，然后返回 *this。

另一方面，后缀运算符需要返回对象在增加或减少*之前*的状态。这导致了一些难题——如果我们增加或减少对象，我们将无法返回对象在增加或减少之前的状态。另一方面，如果我们在增加或减少对象之前返回对象的状态，则永远不会调用增加或减少。

解决这个问题的典型方法是使用一个临时变量来保存对象在增加或减少之前的值。然后对象本身可以增加或减少。最后，将临时变量返回给调用者。这样，调用者在对象增加或减少之前会收到对象的副本，但对象本身会增加或减少。请注意，这意味着重载运算符的返回值必须是非引用，因为我们不能返回对函数退出时将被销毁的局部变量的引用。还要注意，这意味着后缀运算符通常比前缀运算符效率低，因为实例化临时变量并按值而不是引用返回会增加开销。

最后，请注意，我们编写后置增量和后置减量时，会调用前置增量和前置减量来完成大部分工作。这减少了重复代码，并使我们的类在将来更容易修改。

# 21.9 — 重载下标运算符

使用数组时，我们通常使用下标运算符（[]）来索引数组的特定元素：

```cpp
myArray[0] = 7; // put the value 7 in the first element of the array
```

但是，请考虑以下`IntList`类，它有一个作为数组的成员变量：

```cpp
class IntList
{
private:
    int m_list[10]{};
};

int main()
{
    IntList list{};
    // how do we access elements from m_list?
    return 0;
}
```

由于 m_list 成员变量是私有的，因此我们无法直接从变量列表访问它。这意味着我们无法直接获取或设置 m_list 数组中的值。那么我们如何获取或将元素放入列表中呢？

如果没有运算符重载，典型的方法是创建访问函数：

```cpp
class IntList
{
private:
    int m_list[10]{};

public:
    void setItem(int index, int value) { m_list[index] = value; }
    int getItem(int index) const { return m_list[index]; }
};
```

虽然这种方法可行，但对用户来说并不友好。请考虑以下示例：

```cpp
int main()
{
    IntList list{};
    list.setItem(2, 3);

    return 0;
}
```

我们是将元素 2 设置为值 3，还是将元素 3 设置为值 2？如果不看 的定义`setItem()`，根本就不清楚。

您也可以只返回整个列表并使用 operator[] 来访问元素：

```cpp
class IntList
{
private:
    int m_list[10]{};

public:
    int* getList() { return m_list; }
};
```

虽然这也有效，但语法上很奇怪：

```cpp
int main()
{
    IntList list{};
    list.getList()[2] = 3;

    return 0;
}
```

## 重载运算符[]

但是，在这种情况下，更好的解决方案是重载下标运算符 ([])，以允许访问 m_list 的元素。下标运算符是必须作为成员函数重载的运算符之一。重载的 operator[] 函数始终采用一个参数：用户放置在硬括号之间的下标。在我们的 IntList 案例中，我们希望用户传入一个整数索引，我们将返回一个整数值作为结果。

```cpp
#include <iostream>

class IntList
{
private:
    int m_list[10]{};

public:
    int& operator[] (int index)
    {
        return m_list[index];
    }
};

/*
// Can also be implemented outside the class definition
int& IntList::operator[] (int index)
{
    return m_list[index];
}
*/

int main()
{
    IntList list{};
    list[2] = 3; // set a value
    std::cout << list[2] << '\n'; // get a value

    return 0;
}
```

现在，每当我们在类的对象上使用下标运算符 ([]) 时，编译器都会从 m_list 成员变量返回相应的元素！这使我们能够直接获取和设置 m_list 的值。

从语法和理解的角度来看，这都很简单。在`list[2]`评估时，编译器首先检查是否存在重载的 operator[] 函数。如果有，它会将硬括号内的值（在本例中为 2）作为参数传递给该函数。

请注意，虽然您可以为函数参数提供默认值，但实际上使用没有下标的 operator[] 不被视为有效语法，因此没有意义。

**提示**

**C++23 增加了对具有多个下标的重载运算符[]的支持。**

## 为什么 operator[] 返回引用

让我们仔细看看如何`list[2] = 3`求值。由于下标运算符的优先级高于赋值运算符，因此`list[2]`首先求值。`list[2]`调用运算符[]，我们已将其定义为返回对的引用`list.m_list[2]`。由于运算符[]返回引用，因此它返回实际的`list.m_list[2]`数组元素。我们的部分求值表达式变为`list.m_list[2] = 3`，这是一个简单的整数赋值。

在课程[12.2 — 值类别（左值和右值）]中，您了解到赋值语句左侧的任何值都必须是左值（即具有实际内存地址的变量）。由于运算符 [] 的结果可用于赋值语句的左侧（例如`list[2] = 3`），因此运算符 [] 的返回值必须是左值。事实证明，引用始终是左值，因为您只能获取具有内存地址的变量的引用。因此，通过返回引用，编译器会认为我们返回的是左值。

考虑一下如果 operator[] 按值而不是按引用返回整数会发生什么情况。`list[2]`将调用 operator[]，它将返回list.m_list[2]*的值*。 例如，如果 m_list[2] 的值为 6，则 operator[] 将返回值 6。`list[2] = 3`将部分计算为`6 = 3`，这毫无意义！ 如果您尝试这样做，C++ 编译器将发出警告：

```
C:VCProjectsTest.cpp(386) : 错误 C2106: ‘=’ : 左操作数必须是左值
C:VCProjectsTest.cpp(386) : error C2106: '=' : left operand must be l-value
```

## 为 const 对象重载运算符 []

在上面的 IntList 示例中，operator[] 是 non-const，我们可以将其用作左值来更改 non-const 对象的状态。但是，如果我们的 IntList 对象是 const，该怎么办？在这种情况下，我们将无法调用 operator[] 的非 const 版本，因为这将允许我们潜在地更改 const 对象的状态。

好消息是，我们可以分别定义一个 non-const 和一个 const 版本的 operator[]。non-const 版本将用于 non-const 对象，而 const 版本将用于 const 对象。

```cpp
#include <iostream>

class IntList
{
private:
    int m_list[10]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // give this class some initial state for this example

public:
    // For non-const objects: can be used for assignment
    int& operator[] (int index)
    {
        return m_list[index];
    }

    // For const objects: can only be used for access
    // This function could also return by value if the type is cheap to copy
    const int& operator[] (int index) const
    {
        return m_list[index];
    }
};

int main()
{
    IntList list{};
    list[2] = 3; // okay: calls non-const version of operator[]
    std::cout << list[2] << '\n';

    const IntList clist{};
    // clist[2] = 3; // compile error: clist[2] returns const reference, which we can't assign to
    std::cout << clist[2] << '\n';

    return 0;
}
```

## 删除 const 和非 const 重载之间的重复代码

`int& IntList::operator[](int)`在上面的例子中，请注意和的实现`const int& IntList::operator[](int) const`是相同的。唯一的区别是函数的返回类型。

如果实现很简单（例如只有一行代码），那么让两个函数使用相同的实现是可以的（也是首选）。这样引入的少量冗余不值得删除。

但是如果这些运算符的实现很复杂，需要很多语句怎么办？例如，也许我们需要验证索引是否有效，这需要在每个函数中添加许多冗余的代码行。

在这种情况下，由许多重复语句引入的冗余会更加成问题，因此最好有一个可以用于两个重载的单一实现。但是该怎么做呢？通常我们只是根据一个函数来实现另一个函数（例如让一个函数调用另一个函数）。但是在这种情况下这有点棘手。函数的 const 版本不能调用函数的非 const 版本，因为这需要丢弃 const 对象的 const。虽然函数的非 const 版本可以调用函数的 const 版本，但是当我们需要返回非 const 引用时，函数的 const 版本会返回 const 引用。幸运的是，有一种方法可以解决这个问题。

优选的解决方案如下：

- 实现函数的 const 版本的逻辑。
- 让非 const 函数调用 const 函数并用来`const_cast`删除 const。

最终的解决方案如下所示：

```cpp
#include <iostream>
#include <utility> // for std::as_const

class IntList
{
private:
    int m_list[10]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // give this class some initial state for this example

public:
    int& operator[] (int index)
    {
        // use std::as_const to get a const version of `this` (as a reference)
        // so we can call the const version of operator[]
        // then const_cast to discard the const on the returned reference
        return const_cast<int&>(std::as_const(*this)[index]);
    }

    const int& operator[] (int index) const
    {
        return m_list[index];
    }
};

int main()
{
    IntList list{};
    list[2] = 3; // okay: calls non-const version of operator[]
    std::cout << list[2] << '\n';

    const IntList clist{};
    // clist[2] = 3; // compile error: clist[2] returns const reference, which we can't assign to
    std::cout << clist[2] << '\n';

    return 0;
}
```

通常情况下，我们想要避免使用`const_cast`来移除 const，但在这种情况下，这是可以接受的。如果调用了 non-const 重载，那么我们就知道我们正在使用 non-const 对象。移除对 non-const 对象的 const 引用上的 const 是可以的。

<u>对于高级读者</u>

<u>在 C++23 中，我们可以利用本教程系列中尚未涉及的几个功能做得更好：</u>

```cpp
#include <iostream>

class IntList
{
private:
    int m_list[10]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; // give this class some initial state for this example

public:
    // Use an explicit object parameter (self) and auto&& to differentiate const vs non-const
    auto&& operator[](this auto&& self, int index)
    {
        // Complex code goes here
        return self.m_list[index];
    }
};

int main()
{
    IntList list{};
    list[2] = 3; // okay: calls non-const version of operator[]
    std::cout << list[2] << '\n';

    const IntList clist{};
    // clist[2] = 3; // compile error: clist[2] returns const reference, which we can't assign to
    std::cout << clist[2] << '\n';

    return 0;
}
```

## 检测指数有效性

重载下标运算符的另一个优点是，我们可以使其比直接访问数组更安全。通常，在访问数组时，下标运算符不会检查索引是否有效。例如，编译器不会抱怨以下代码：

```cpp
int list[5]{};
list[7] = 3; // index 7 is out of bounds!
```

但是，如果我们知道数组的大小，我们可以使用重载下标运算符检查以确保索引在界限内：

```cpp
#include <cassert> // for assert()
#include <iterator> // for std::size()

class IntList
{
private:
    int m_list[10]{};

public:
    int& operator[] (int index)
    {
        assert(index >= 0 && static_cast<std::size_t>(index) < std::size(m_list));

        return m_list[index];
    }
};
```

在上面的例子中，我们使用了 assert() 函数（包含在 cassert 标头中）来确保索引有效。如果 assert 中的表达式计算结果为 false（这意味着用户传入了无效索引），程序将终止并显示错误消息，这比其他方法（破坏内存）要好得多。这可能是进行此类错误检查的最常用方法。

如果你不想使用断言（它将从非调试版本中编译出来），你可以使用 if 语句和你最喜欢的错误处理方法（例如引发异常、调用`std::exit`等...）：

```cpp
#include <iterator> // for std::size()

class IntList
{
private:
    int m_list[10]{};

public:
    int& operator[] (int index)
    {
        if (!(index >= 0 && static_cast<std::size_t>(index) < std::size(m_list))
        {
            // handle invalid index here
        }

        return m_list[index];
    }
};
```

## 指向对象的指针和重载的运算符 [] 不能混合使用

如果您尝试在指向对象的指针上调用 operator[]，C++ 将假定您正在尝试索引该类型的对象数组。

请考虑以下示例：

```cpp
#include <cassert> // for assert()
#include <iterator> // for std::size()

class IntList
{
private:
    int m_list[10]{};

public:
    int& operator[] (int index)
    {
        return m_list[index];
    }
};

int main()
{
    IntList* list{ new IntList{} };
    list [2] = 3; // error: this will assume we're accessing index 2 of an array of IntLists
    delete list;

    return 0;
}
```

由于我们无法将整数赋值给 IntList，因此此代码无法编译。但是，如果赋值整数有效，则此代码可以编译并运行，但结果未定义。

**规则**

**确保您没有尝试在指向对象的指针上调用重载的运算符[]。**

正确的语法是首先取消引用指针（确保使用括号，因为运算符 [] 的优先级高于运算符 *），然后调用运算符 []：

```cpp
int main()
{
    IntList* list{ new IntList{} };
    (*list)[2] = 3; // get our IntList object, then call overloaded operator[]
    delete list;

    return 0;
}
```

这很丑陋，而且容易出错。更好的是，如果没有必要，不要设置指向对象的指针。

## 函数参数不需要是整数类型

如上所述，C++ 将用户在括号之间输入的内容作为参数传递给重载函数。在大多数情况下，这将是一个整数值。但是，这不是必需的——事实上，您可以定义重载的运算符[] 接受您想要的任何类型的值。您可以将重载的运算符[] 定义为接受 double、std::string 或任何其他您喜欢的类型。

举一个荒谬的例子，你就能看出它是有效的：

```cpp
#include <iostream>
#include <string_view> // C++17

class Stupid
{
private:

public:
	void operator[] (std::string_view index);
};

// It doesn't make sense to overload operator[] to print something
// but it is the easiest way to show that the function parameter can be a non-integer
void Stupid::operator[] (std::string_view index)
{
	std::cout << index;
}

int main()
{
	Stupid stupid{};
	stupid["Hello, world!"];

	return 0;
}
```

正如你所期望的，这将打印：

```
Hello, world!
```

在编写某些类型的类（例如使用单词作为索引的类）时，重载 operator[] 以采用 std::string 参数会很有用。

## 测验时间

### 问题 #1

映射是一种将元素存储为键值对的类。键必须是唯一的，用于访问关联的键值对。在这个测验中，我们将使用一个简单的映射类编写一个应用程序，让我们按姓名为学生分配成绩。学生的姓名将是键，成绩（作为字符）将是值。

a) 首先，编写一个名为的结构体`StudentGrade`，其中包含学生的姓名（作为 a `std::string`）和成绩（作为 a `char`）。

```cpp
#include <string>

struct StudentGrade
{
    std::string name{};
    char grade{};
};
```

b) 添加一个名为 的类`GradeMap`，其中包含一个名为`m_map` 的`StudentGrade`的`std::vector`类。

```cpp
#include <string>
#include <vector>

struct StudentGrade
{
	std::string name{};
	char grade{};
};

class GradeMap
{
private:
	std::vector<StudentGrade> m_map{};
};
```

c)为此类编写一个重载`operator[]`。此函数应接受一个`std::string`参数，并返回对 char 的引用。在函数主体中，首先查看学生姓名是否已存在（您可以使用`std::find_if`<algorithm>）。如果学生存在，则返回对成绩的引用，然后您就完成了。否则，使用`std::vector::emplace_back()`或`std::vector::push_back()`函数为这个新学生添加`StudentGrade`。当您执行此操作时，`std::vector`将添加您的副本`StudentGrade`添加到自身中（如果需要调整大小，使所有先前返回的引用无效）。最后，我们需要返回对我们刚刚添加到`std::vector`的学生的成绩的引用。我们可以使用`std::vector::back()`函数访问我们刚刚添加的学生。

应运行以下程序：

```cpp
#include <iostream>

// ...

int main()
{
	GradeMap grades{};

	grades["Joe"] = 'A';
	grades["Frank"] = 'B';

	std::cout << "Joe has a grade of " << grades["Joe"] << '\n';
	std::cout << "Frank has a grade of " << grades["Frank"] << '\n';

	return 0;
}
```

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <string_view>
#include <vector>

struct StudentGrade
{
	std::string name{};
	char grade{};
};

class GradeMap
{
private:
	std::vector<StudentGrade> m_map{};

public:
	char& operator[](std::string_view name);
};

char& GradeMap::operator[](std::string_view name)
{
	auto found{ std::find_if(m_map.begin(), m_map.end(),
				[name](const auto& student) { // this is a lambda that captures name from the surrounding scope
					return (student.name == name); // so we can use name here
				}) };

	if (found != m_map.end())
	{
		return found->grade;
	}

	// otherwise create a new StudentGrade for this student and add
	// it to the end of our vector.  Then return the grade.

	// emplace_back version (C++20 onward)
	// StudentGrade is an aggregate and emplace_back only works with aggregates as of C++20
	return m_map.emplace_back(std::string{name}).grade;

	// push_back version (C++17 or older)
	// m_map.push_back(StudentGrade{std::string{name}});
	// return m_map.back().grade;
}

int main()
{
	GradeMap grades{};

	grades["Joe"] = 'A';
	grades["Frank"] = 'B';

	std::cout << "Joe has a grade of " << grades["Joe"] << '\n';
	std::cout << "Frank has a grade of " << grades["Frank"] << '\n';

	return 0;
}
```

**提醒**

**有关 lambda 的更多信息，请参阅[20.6——lambda（匿名函数）简介。]**

<u>提示</u>

<u>由于映射很常见，标准库提供了[`std::map`](https://en.cppreference.com/w/cpp/container/map)，但目前 learncpp 尚未涵盖。使用`std::map`，我们可以将代码简化为</u>

```cpp
#include <iostream>
#include <map> // std::map
#include <string>

int main()
{
	// std::map can be initialized
	std::map<std::string, char> grades{
		{ "Joe", 'A' },
		{ "Frank", 'B' }
	};

	// and assigned
	grades["Susan"] = 'C';
	grades["Tom"] = 'D';

	std::cout << "Joe has a grade of " << grades["Joe"] << '\n';
	std::cout << "Frank has a grade of " << grades["Frank"] << '\n';

	return 0;
}
```

<u>优先使用`std::map`而不是编写自己的实现。</u>

### 问题 #2

额外加分 #1：我们编写的课程和示例程序由于多种原因而效率低下。描述一种可以改进课程`GradeMap`的方法。

`std::vector`本质上是未排序的。这意味着每次我们调用时`operator[]`，我们都有可能会遍历整个数组`std::vector`来查找我们的元素。如果元素很少，这不是问题，但随着我们继续添加名称，这会变得越来越慢。我们可以通过保持`m_map`排序并使用二分搜索来优化这一点，这样我们就可以最大限度地减少我们必须查找的元素数量，以找到我们感兴趣的元素。

### 问题 #3

额外提示#2：为什么这个程序可能无法按预期工作？

```cpp
#include <iostream>

int main()
{
	GradeMap grades{};

	char& gradeJoe{ grades["Joe"] }; // does an emplace_back
	gradeJoe = 'A';

	char& gradeFrank{ grades["Frank"] }; // does a emplace_back
	gradeFrank = 'B';

	std::cout << "Joe has a grade of " << gradeJoe << '\n';
	std::cout << "Frank has a grade of " << gradeFrank << '\n';

	return 0;
}
```

添加 Frank 后，`std::vector`可能需要增大内存才能容纳它。这需要动态分配新的内存块，将数组中的元素复制到新内存块，并删除旧内存块。发生这种情况时，对 std::vector 中现有元素的任何引用都将失效（这意味着它们将作为对已删除内存的悬空引用保留）。

换句话说，在我们之后`emplace_back("Frank")`，如果 std::vector 必须增大才能为 Frank 腾出空间，`gradeJoe`则引用将失效。`gradeJoe`然后访问打印 Joe 的成绩将导致未定义的结果。

std::vector 如何增长是特定于编译器的细节，因此我们可以预期上述程序在使用某些编译器编译时可以正常工作，而在其他编译器编译时则不能。

# 21.10 — 重载括号运算符

到目前为止，您看到的所有重载运算符都允许您定义运算符参数的类型，但不能定义参数的数量（根据运算符的类型固定）。例如，operator== 始终接受两个参数，而 operator! 始终接受一个参数。括号运算符 (operator()) 是一种特别有趣的运算符，因为它允许您同时改变其所接受的参数的类型和数量。

有两点需要注意：首先，括号运算符必须作为成员函数实现。其次，在非面向对象的 C++ 中，() 运算符用于调用函数。在类的情况下，operator() 只是一个普通运算符，它像任何其他重载运算符一样调用函数（名为 operator()）。

## 一个例子

让我们看一个适合重载该运算符的例子：

```cpp
class Matrix
{
private:
    double data[4][4]{};
};
```

矩阵是线性代数的重要组成部分，常用于几何建模和 3D 计算机图形学工作。在本例中，您只需认识到 Matrix 类是一个 4 x 4 的二维双精度数组。

[在重载下标运算符](https://www.learncpp.com/cpp-tutorial/98-overloading-the-subscript-operator/)的课程中，您了解到我们可以重载运算符[]以提供对私有一维数组的直接访问。但是，在这种情况下，我们想要访问私有二维数组。在 C++23 之前，运算符[] 仅限于单个参数，因此不足以让我们直接索引二维数组。

但是，由于 () 运算符可以接受任意数量的参数，因此我们可以声明一个接受两个整数索引参数的 operator() 版本，并使用它来访问我们的二维数组。以下是一个例子：

```cpp
#include <cassert> // for assert()

class Matrix
{
private:
    double m_data[4][4]{};

public:
    double& operator()(int row, int col);
    double operator()(int row, int col) const; // for const objects
};

double& Matrix::operator()(int row, int col)
{
    assert(row >= 0 && row < 4);
    assert(col >= 0 && col < 4);

    return m_data[row][col];
}

double Matrix::operator()(int row, int col) const
{
    assert(row >= 0 && row < 4);
    assert(col >= 0 && col < 4);

    return m_data[row][col];
}
```

现在我们可以声明一个矩阵并像这样访问其元素：

```cpp
#include <iostream>

int main()
{
    Matrix matrix;
    matrix(1, 2) = 4.5;
    std::cout << matrix(1, 2) << '\n';

    return 0;
}
```

其结果为：

```
4.5
```

现在，让我们再次重载 () 运算符，这次根本不采用任何参数：

```cpp
#include <cassert> // for assert()
class Matrix
{
private:
    double m_data[4][4]{};

public:
    double& operator()(int row, int col);
    double operator()(int row, int col) const;
    void operator()();
};

double& Matrix::operator()(int row, int col)
{
    assert(row >= 0 && row < 4);
    assert(col >= 0 && col < 4);

    return m_data[row][col];
}

double Matrix::operator()(int row, int col) const
{
    assert(row >= 0 && row < 4);
    assert(col >= 0 && col < 4);

    return m_data[row][col];
}

void Matrix::operator()()
{
    // reset all elements of the matrix to 0.0
    for (int row{ 0 }; row < 4; ++row)
    {
        for (int col{ 0 }; col < 4; ++col)
        {
            m_data[row][col] = 0.0;
        }
    }
}
```

这是我们的新示例：

```cpp
#include <iostream>

int main()
{
    Matrix matrix{};
    matrix(1, 2) = 4.5;
    matrix(); // erase matrix
    std::cout << matrix(1, 2) << '\n';

    return 0;
}
```

其结果为：

```
0
```

由于 () 运算符非常灵活，因此人们很容易将其用于许多不同的目的。但是，我们强烈反对这样做，因为 () 符号实际上并没有给出任何有关该运算符正在做什么的指示。在我们上面的例子中，最好将清除功能编写为名为 clear() 或 eras() 的函数，因为这样比(它可以做任何事情！)`matrix.erase()`更容易理解。`matrix()`

注意：从 C++23 开始，您可以使用`operator[]`多个索引。其工作原理与上面的一样`operator()`。

## 享受函子的乐趣

Operator() 也经常被重载以实现**函子**（或**函数对象**），函子是像函数一样运行的类。函子相对于普通函数的优势在于函子可以将数据存储在成员变量中（因为它们是类）。

这是一个简单的函子：

```cpp
#include <iostream>

class Accumulator
{
private:
    int m_counter{ 0 };

public:
    int operator() (int i) { return (m_counter += i); }

    void reset() { m_counter = 0; } // optional
};

int main()
{
    Accumulator acc{};
    std::cout << acc(1) << '\n'; // prints 1
    std::cout << acc(3) << '\n'; // prints 4

    Accumulator acc2{};
    std::cout << acc2(10) << '\n'; // prints 10
    std::cout << acc2(20) << '\n'; // prints 30

    return 0;
}
```

请注意，使用我们的 Accumulator 看起来就像进行普通函数调用一样，但是我们的 Accumulator 对象正在存储累积值。

函子的优点在于，我们可以根据需要实例化任意数量的单独函子对象，并同时使用它们。函子还可以有其他成员函数（例如`reset()`），用于执行方便的操作。

## 结论

Operator() 有时会使用两个参数进行重载，以便索引多维数组，或检索一维数组的子集（使用两个参数定义要返回的子集）。其他任何内容可能最好写成具有更具描述性名称的成员函数。

Operator() 也经常被重载来创建函子。虽然简单的函子（如上例）相当容易理解，但函子通常用于更高级的编程主题，值得单独上一课。

## 测验时间

### 问题 #1

编写一个名为 MyString 的类，该类包含`std::string`。重载`operator<<`以输出字符串。重载`operator()`以返回从第一个参数的索引开始的子字符串（作为`MyString`）。子字符串的长度应由第二个参数定义。

以下代码应该运行：

```cpp
int main()
{
    MyString s { "Hello, world!" };
    std::cout << s(7, 5) << '\n'; // start at index 7 and return 5 characters

    return 0;
}
```

这应该打印

```
world
```

提示：您可以使用它[`std::string::substr`](https://en.cppreference.com/w/cpp/string/basic_string/substr)来获取 std::string 的子字符串。

```cpp
#include <cassert>
#include <iostream>
#include <string>
#include <string_view>

class MyString
{
private:
	std::string m_string{};

public:
	MyString(std::string_view string = {})
		:m_string{ string }
	{
	}

	MyString operator()(int start, int length)
	{
		assert(start >= 0);
		assert(start + length <= static_cast<int>(m_string.length()) && "MyString::operator(int, int): Substring is out of range");

		return MyString { m_string.substr(
			static_cast<std::string::size_type>(start),
			static_cast<std::string::size_type>(length)
			)};
	}

	friend std::ostream& operator<<(std::ostream& out, const MyString& s)
	{
		out << s.m_string;

		return out;
	}
};

int main()
{
	MyString s{ "Hello, world!" };
	std::cout << s(7, 5) << '\n'; // start at index 7 and return 5 characters

	return 0;
}
```

### 问题 #2

这道测验题目是额外加分的。

#### \> 步骤#1

如果我们不需要修改返回的子字符串，为什么上述方法效率低下？

在我们的 中`operator()`，`std::string::substr`返回一个`std::string`，这意味着当我们调用它时，我们正在复制源字符串的一部分。我们的重载`operator()`使用它来构造一个新的`MyString`，它包含一个`std::string`成员，它会制作另一个副本。然后我们将其返回`MyString`给调用者，它会制作第三个副本。编译器可能会优化其中一些副本以使其不存在，但至少`std::string`必须保留一个（包含生成的子字符串）。

只有在我们打算修改子字符串或子字符串的寿命比原始字符串长的情况下，我们才需要子字符串的副本。通常情况下，情况并非如此，因此我们会制作通常不需要的昂贵副本。

#### \> 步骤#2

我们可以做什么呢？

```
std::string_view`能够查看现有字符串的子字符串而无需进行复制。如果我们`operator()`要返回一个`std::string_view`，那么调用者可以在`std::string_view`足够的情况下使用 ，或者在需要修改或保留子字符串时将其转换为`std::string`或`MyString'.	
```

#### 步骤#3         

从之前的测验解决方案更新`operator()`为返回子字符串`std::string_view`。

提示：`std::string::substr()`返回一个`std::string`。`std::string_view::substr()`返回一个`std::string_view`。一定要小心，不要返回悬垂的`std::string_view!`。

提示：不要创建任何`std::string`临时变量，因为这些临时变量将在函数结束时被销毁，并且`std::string_view`其中任何一个都`std::string`将处于悬空状态。

提示：创建`std::string_view`临时对象是可以的，只要它们是的视图即可`m_string`。

```cpp
#include <cassert>
#include <iostream>
#include <string>
#include <string_view>

class MyString
{
private:
	std::string m_string{};

public:
	MyString(std::string_view string = {})
		:m_string{ string }
	{
	}

	std::string_view operator()(int start, int length)
	{
		assert(start >= 0);
		assert(start + length <= static_cast<int>(m_string.length()) && "MyString::operator(int, int): Substring is out of range");

		// Create a std::string_view of m_string, so we can use std::string_view::substr() instead of std::string::substr()
		return std::string_view{ m_string }.substr(
			static_cast<std::string_view::size_type>(start),
			static_cast<std::string_view::size_type>(length)
		);
	}

	friend std::ostream& operator<<(std::ostream& out, const MyString& s)
	{
		out << s.m_string;

		return out;
	}
};

int main()
{
	MyString s{ "Hello, world!" };
	std::cout << s(7, 5) << '\n'; // start at index 7 and return 5 characters

	return 0;
}
```

让我们进一步探索`return std::string_view{ m_string }.substr();`。首先，我们为m_string创建一个临时`std::string_view`，它很便宜，可以让我们访问`std::string_view`成员函数。接下来，我们调用`std::string_view::substr`这个临时的来获取我们的子字符串（作为的非空终止视图`m_string`）。然后我们将这个视图返回给调用者。由于`std::string_view`我们返回给调用者的仍然是一个视图`m_string`（仍然在范围内），所以我们返回的`std::string_view`不是悬空的。

最终的结果是我们创建了 3`std::string_view`而不是 3 `std::string`，这更有效率。

# 21.11 — 重载类型转换

在课程[10.6 — 显式类型转换（强制类型转换）和 static_cast]中，您了解到 C++ 允许您将一种数据类型转换为另一种数据类型。以下示例显示了将 int 转换为 double：

```cpp
int n{ 5 };
auto d{ static_cast<double>(n) }; // int cast to a double
```

C++ 已经知道如何在内置数据类型之间进行转换。但是，它不知道如何转换任何用户定义的类。这就是重载类型转换运算符发挥作用的地方。

**用户定义的转换**允许我们将我们的类转换为另一种数据类型。看一下下面的类：

```cpp
class Cents
{
private:
    int m_cents{};
public:
    Cents(int cents=0)
        : m_cents{ cents }
    {
    }

    int getCents() const { return m_cents; }
    void setCents(int cents) { m_cents = 】cents; }
};
```

这个类非常简单：它以整数形式保存一定数量的美分，并提供访问函数来获取和设置美分数量。它还提供了一个构造函数，用于将 int 转换为 Cents。

如果我们可以将 int 转换为 Cents（通过构造函数），那么将 Cents 转换回 int 是否也有意义？在某些情况下，这可能不正确，但在这种情况下，这是有意义的。在下面的例子中，我们必须使用 getCents() 将 Cents 变量转换回整数，以便我们可以使用 printInt() 打印它：

```cpp
#include <iostream>

void printInt(int value)
{
    std::cout << value;
}

int main()
{
    Cents cents{ 7 };
    printInt(cents.getCents()); // print 7

    std::cout << '\n';

    return 0;
}
```

如果我们已经编写了许多以整数作为参数的函数，那么我们的代码中就会充斥着对 getCents() 的调用，这会使其变得比需要的更混乱。

为了简化操作，我们可以通过重载 int 类型转换来提供用户定义的转换。这将允许我们将 Cents 类直接转换为 int。以下示例显示了如何完成此操作：

```cpp
class Cents
{
private:
    int m_cents{};
public:
    Cents(int cents=0)
        : m_cents{ cents }
    {
    }

    // Overloaded int cast
    operator int() const { return m_cents; }

    int getCents() const { return m_cents; }
    void setCents(int cents) { m_cents = cents; }
};
```

有三点需要注意：

1. 为了重载将我们的类转换为 int 的函数，我们在类中编写了一个名为 的新函数`operator int()`。请注意，operator 一词和我们要转换为的类型之间有一个空格。此类函数必须是非静态成员。
2. 用户定义的转换没有参数，因为没有办法显式地向它们传递参数。它们仍然有一个隐藏的`*this`参数，指向隐式对象（即要转换的对象）
3. 用户定义的转换不声明返回类型。转换的名称（例如 int）用作返回类型，因为它是唯一允许的返回类型。这可以防止冗余。

现在在我们的示例中，我们可以像这样调用 printInt()：

```cpp
#include <iostream>

int main()
{
    Cents cents{ 7 };
    printInt(cents); // print 7

    std::cout << '\n';

    return 0;
}
```

编译器首先会注意到函数 printInt 接受一个整数参数。然后它会注意到变量 cents 不是 int。最后，它会查看我们是否提供了将 Cents 转换为 int 的方法。既然我们已经提供了，它会调用我们的 operator int() 函数，该函数返回一个 int，并且返回的 int 将被传递给 printInt()。

此类类型转换也可以通过以下方式显式调用`static_cast`：

```cpp
std::cout << static_cast<int>(cents);
```

您可以为任何您想要的数据类型提供用户定义的转换，包括您自己的程序定义的数据类型！

这是一个名为 Dollars 的新类，它提供了重载的 Cents 转换功能：

```cpp
class Dollars
{
private:
    int m_dollars{};
public:
    Dollars(int dollars=0)
        : m_dollars{ dollars }
    {
    }

     // Allow us to convert Dollars into Cents
     operator Cents() const { return Cents{ m_dollars * 100 }; }
};
```

这使我们能够将 Dollars 对象直接转换为 Cents 对象！这允许您执行如下操作：

```cpp
#include <iostream>

class Cents
{
private:
    int m_cents{};
public:
    Cents(int cents=0)
        : m_cents{ cents }
    {
    }

    // Overloaded int cast
    operator int() const { return m_cents; }

    int getCents() const { return m_cents; }
    void setCents(int cents) { m_cents = cents; }
};

class Dollars
{
private:
    int m_dollars{};
public:
    Dollars(int dollars=0)
        : m_dollars{ dollars }
    {
    }

    // Allow us to convert Dollars into Cents
    operator Cents() const { return Cents { m_dollars * 100 }; }
};

void printCents(Cents cents)
{
    std::cout << cents; // cents will be implicitly cast to an int here
}

int main()
{
    Dollars dollars{ 9 };
    printCents(dollars); // dollars will be implicitly cast to a Cents here

    std::cout << '\n';

    return 0;
}
```

因此，该程序将打印该值：

```cpp
which makes sense, since 9 dollars is 900 cents!
```

## 显式类型转换

就像我们可以将构造函数显式化，使其不能用于隐式转换一样，出于同样的原因，我们也可以将重载的类型转换显式化。显式类型转换只能显式调用（例如，在非复制初始化期间或通过使用类似 的显式转换`static_cast`）。

```cpp
#include <iostream>

class Cents
{
private:
    int m_cents{};
public:
    Cents(int cents=0)
        : m_cents{ cents }
    {
    }

    explicit operator int() const { return m_cents; } // now marked as explicit

    int getCents() const { return m_cents; }
    void setCents(int cents) { m_cents = cents; }
};

class Dollars
{
private:
    int m_dollars{};
public:
    Dollars(int dollars=0)
        : m_dollars{ dollars }
    {
    }

    operator Cents() const { return Cents { m_dollars * 100 }; }
};

void printCents(Cents cents)
{
    std::cout << static_cast<int>(cents); // must use explicit cast to invoke explicit typecast
}

int main()
{
    Dollars dollars{ 9 };
    printCents(dollars);

    std::cout << '\n';

    return 0;
}
```

类型转换通常应标记为显式。

如果转换以低成本转换为类似的用户定义类型，则可以例外。我们的`Dollars::operator Cents()`类型转换是非显式的，因为没有理由不允许在任何需要`Cents`的`Dollars`地方使用`Dollars`对象。

**最佳实践**

**类型转换应该标记为显式，除非要转换的类本质上是同义词。**

## 转换构造函数与重载类型转换

重载类型转换和转换构造函数执行类似的角色：重载类型转换允许我们定义一个函数，将某些程序定义的类型 A 转换为其他类型 B。转换构造函数允许我们定义一个函数，从某些其他类型 B 创建某些程序定义的类型 A。那么何时应该使用它们呢？

一般来说，转换构造函数应该优于重载类型转换，因为它允许构造的类型拥有构造。

在某些情况下，应该使用重载类型转换：

- 当提供到基本类型的转换时（因为您无法为这些类型定义构造函数）。最惯用的做法是，它们用于`bool`在条件语句中使用对象有意义的情况下提供到的转换。
- 当提供对类型的转换时，您不能添加成员（例如，转换为`std::vector`，因为您也不能为这些类型定义构造函数）。
- 当你不希望正在构造的类型知道正在转换的类型时。这有助于避免循环依赖。

举最后一个例子，`std::string`有一个构造函数来从`std::string_view`创建一个`std::string`。这意味着`<string>`必须包含`<string_view>`。如果`std::string_view`有一个构造函数可以从`std::string_view`创建一个`std::string`，那么`<string_view>`就需要包含`<string>`，这将导致标题之间的循环依赖。

相反，`std::string` 有一个重载的 `typecast`，可以处理从`std::string`到 `std::string_view`的转换（这很好，因为它已经包含了 `<string_view>`）。`std::string_view` 完全不了解 `std::string`，因此不需要包含 `<string>`。这样就避免了循环依赖。

# 21.12 — 重载赋值运算符

**复制赋值运算符**（operator=）用于将值从一个对象复制到另一个*已经存在的对象*。

**相关内容**

**从 C++11 开始，C++ 还支持“移动赋值”。我们将在课程[22.3 -- 移动构造函数和移动赋值]中讨论移动赋值。**

## 复制赋值与复制构造函数

复制构造函数和复制赋值运算符的作用几乎相同——都是将一个对象复制到另一个对象。不过，复制构造函数初始化新对象，而赋值运算符替换现有对象的内容。

复制构造函数和复制赋值运算符之间的区别让新程序员感到困惑，但其实并没有那么难。总结：

- 如果在进行复制之前必须创建一个新对象，则使用复制构造函数（注意：这包括通过值传递或返回对象）。

- 如果在复制之前不需要创建新对象，则使用赋值运算符。

  ## 重载赋值运算符

  重载复制赋值运算符 (operator=) 相当简单，但有一个特殊注意事项，我们将在后面讨论。复制赋值运算符必须作为成员函数重载。

  ```cpp
  #include <cassert>
  #include <iostream>
  
  class Fraction
  {
  private:
  	int m_numerator { 0 };
  	int m_denominator { 1 };
  
  public:
  	// Default constructor
  	Fraction(int numerator = 0, int denominator = 1 )
  		: m_numerator { numerator }, m_denominator { denominator }
  	{
  		assert(denominator != 0);
  	}
  
  	// Copy constructor
  	Fraction(const Fraction& copy)
  		: m_numerator { copy.m_numerator }, m_denominator { copy.m_denominator }
  	{
  		// no need to check for a denominator of 0 here since copy must already be a valid Fraction
  		std::cout << "Copy constructor called\n"; // just to prove it works
  	}
  
  	// Overloaded assignment
  	Fraction& operator= (const Fraction& fraction);
  
  	friend std::ostream& operator<<(std::ostream& out, const Fraction& f1);
  
  };
  
  std::ostream& operator<<(std::ostream& out, const Fraction& f1)
  {
  	out << f1.m_numerator << '/' << f1.m_denominator;
  	return out;
  }
  
  // A simplistic implementation of operator= (see better implementation below)
  Fraction& Fraction::operator= (const Fraction& fraction)
  {
      // do the copy
      m_numerator = fraction.m_numerator;
      m_denominator = fraction.m_denominator;
  
      // return the existing object so we can chain this operator
      return *this;
  }
  
  int main()
  {
      Fraction fiveThirds { 5, 3 };
      Fraction f;
      f = fiveThirds; // calls overloaded assignment
      std::cout << f;
  
      return 0;
  }
  ```

  这将打印：

```
5/3
```

现在一切都应该非常简单了。我们的重载运算符 = 返回 *this，这样我们就可以将多个赋值链接在一起：

```cpp
int main()
{
    Fraction f1 { 5, 3 };
    Fraction f2 { 7, 2 };
    Fraction f3 { 9, 5 };

    f1 = f2 = f3; // chained assignment

    return 0;
}
```

## 因自我分配而产生的问题

事情开始变得有趣起来。C++ 允许自我赋值：

```cpp
int main()
{
    Fraction f1 { 5, 3 };
    f1 = f1; // self assignment

    return 0;
}
```

这将调用 f1.operator=(f1)，在上述简单的实现下，所有成员都将被分配给自身。在此特定示例中，自我分配会导致每个成员被分配给自身，除了浪费时间外，这不会对整体产生任何影响。在大多数情况下，自我分配根本不需要做任何事情！

然而，在赋值运算符需要动态分配内存的情况下，自我赋值实际上可能是危险的：

```cpp
#include <algorithm> // for std::max and std::copy_n
#include <iostream>

class MyString
{
private:
	char* m_data {};
	int m_length {};

public:
	MyString(const char* data = nullptr, int length = 0 )
		: m_length { std::max(length, 0) }
	{
		if (length)
		{
			m_data = new char[static_cast<std::size_t>(length)];
			std::copy_n(data, length, m_data); // copy length elements of data into m_data
		}
	}
	~MyString()
	{
		delete[] m_data;
	}

	MyString(const MyString&) = default; // some compilers (gcc) warn if you have pointer members but no declared copy constructor

	// Overloaded assignment
	MyString& operator= (const MyString& str);

	friend std::ostream& operator<<(std::ostream& out, const MyString& s);
};

std::ostream& operator<<(std::ostream& out, const MyString& s)
{
	out << s.m_data;
	return out;
}

// A simplistic implementation of operator= (do not use)
MyString& MyString::operator= (const MyString& str)
{
	// if data exists in the current string, delete it
	if (m_data) delete[] m_data;

	m_length = str.m_length;
	m_data = nullptr;

	// allocate a new array of the appropriate length
	if (m_length)
		m_data = new char[static_cast<std::size_t>(str.m_length)];

	std::copy_n(str.m_data, m_length, m_data); // copies m_length elements of str.m_data into m_data

	// return the existing object so we can chain this operator
	return *this;
}

int main()
{
	MyString alex("Alex", 5); // Meet Alex
	MyString employee;
	employee = alex; // Alex is our newest employee
	std::cout << employee; // Say your name, employee

	return 0;
}
```

首先，按原样运行该程序。您将看到程序按预期打印“Alex”。

现在运行以下程序：

```cpp
int main()
{
    MyString alex { "Alex", 5 }; // Meet Alex
    alex = alex; // Alex is himself
    std::cout << alex; // Say your name, Alex

    return 0;
}
```

您可能会得到垃圾输出。发生了什么？

考虑一下当隐式对象和传入的参数 (str) 都是变量 alex 时，重载运算符 = 中会发生什么情况。在这种情况下，m_data 与 str.m_data 相同。首先发生的事情是函数检查隐式对象是否已经有字符串。如果是，则需要删除它，这样我们就不会出现内存泄漏。在这种情况下，m_data 已分配，因此函数会删除 m_data。但由于 str 与 *this 相同，我们想要复制的字符串已被删除，并且 m_data（和 str.m_data）处于悬空状态。

稍后，我们为 m_data（和 str.m_data）分配新内存。因此，当我们随后将数据从 str.m_data 复制到 m_data 时，我们复制的是垃圾，因为 str.m_data 从未初始化过。

## 检测并处理自我分配

幸运的是，我们可以检测何时发生自赋值。下面是 MyString 类的重载运算符 = 的更新实现：

```cpp
MyString& MyString::operator= (const MyString& str)
{
	// self-assignment check
	if (this == &str)
		return *this;

	// if data exists in the current string, delete it
	if (m_data) delete[] m_data;

	m_length = str.m_length;
	m_data = nullptr;

	// allocate a new array of the appropriate length
	if (m_length)
		m_data = new char[static_cast<std::size_t>(str.m_length)];

	std::copy_n(str.m_data, m_length, m_data); // copies m_length elements of str.m_data into m_data

	// return the existing object so we can chain this operator
	return *this;
}
```

通过检查隐式对象的地址是否与作为参数传入的对象的地址相同，我们可以让赋值运算符立即返回而无需执行任何其他工作。

因为这只是一个指针比较，所以它应该很快，并且不需要重载 operator==。

## 何时不处理自我分配

通常，对于复制构造函数，会跳过自赋值检查。由于复制构造的对象是新创建的，因此新创建的对象与被复制的对象相等的唯一情况是当您尝试用其自身初始化新定义的对象时：

```cpp
someClass c { c };
```

在这种情况下，您的编译器应该警告您这`c`是一个未初始化的变量。

其次，在可以自然处理自赋值的类中，可以省略自赋值检查。考虑这个具有自赋值保护的 Fraction 类赋值运算符：

```cpp
// A better implementation of operator=
Fraction& Fraction::operator= (const Fraction& fraction)
{
    // self-assignment guard
    if (this == &fraction)
        return *this;

    // do the copy
    m_numerator = fraction.m_numerator; // can handle self-assignment
    m_denominator = fraction.m_denominator; // can handle self-assignment

    // return the existing object so we can chain this operator
    return *this;
}
```

如果不存在自分配保护，则该函数在自分配期间仍会正常运行（因为该函数执行的所有操作都可以正确处理自分配）。

由于自赋值是一种罕见事件，一些著名的 C++ 专家建议即使在能从中受益的类中也省略自赋值保护。我们不建议这样做，因为我们认为更好的做法是先防御性地编写代码，然后再有选择地进行优化。

## 复制和交换习惯用法

处理自赋值问题的更好方法是通过所谓的复制和交换习语。Stack [Overflow 上](https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom)有一篇关于此习语如何工作的精彩文章。

## 隐式复制赋值运算符

与其他运算符不同，如果您未提供用户定义的运算符，则编译器将为您的类提供隐式公共复制赋值运算符。此赋值运算符执行成员赋值（本质上与默认复制构造函数执行的成员初始化相同）。

就像其他构造函数和运算符一样，您可以通过将复制赋值运算符设为私有或使用 delete 关键字来防止进行赋值：

```cpp
#include <cassert>
#include <iostream>

class Fraction
{
private:
	int m_numerator { 0 };
	int m_denominator { 1 };

public:
    // Default constructor
    Fraction(int numerator = 0, int denominator = 1)
        : m_numerator { numerator }, m_denominator { denominator }
    {
        assert(denominator != 0);
    }

	// Copy constructor
	Fraction(const Fraction &copy) = delete;

	// Overloaded assignment
	Fraction& operator= (const Fraction& fraction) = delete; // no copies through assignment!

	friend std::ostream& operator<<(std::ostream& out, const Fraction& f1);

};

std::ostream& operator<<(std::ostream& out, const Fraction& f1)
{
	out << f1.m_numerator << '/' << f1.m_denominator;
	return out;
}

int main()
{
    Fraction fiveThirds { 5, 3 };
    Fraction f;
    f = fiveThirds; // compile error, operator= has been deleted
    std::cout << f;

    return 0;
}
```

请注意，如果您的类有 const 成员，编译器将改为将隐式定义`operator=`为已删除。这是因为 const 成员无法分配，因此编译器将假定您的类不应可分配。

如果您希望具有 const 成员的类可分配（对于所有非 const 成员），则需要明确重载`operator=`并手动分配每个非常量成员。

# 21.13 — 浅复制与深复制

## **浅复制**

由于 C++ 对您的类了解不多，因此它提供的默认复制构造函数和默认赋值运算符使用一种称为成员逐一复制（也称为**浅复制**）的复制方法。这意味着 C++ 分别复制类的每个成员（对重载的 operator= 使用赋值运算符，对复制构造函数使用直接初始化）。当类很简单（例如不包含任何动态分配的内存）时，这种方法非常有效。

例如，让我们看一下 Fraction 类：

```cpp
#include <cassert>
#include <iostream>

class Fraction
{
private:
    int m_numerator { 0 };
    int m_denominator { 1 };

public:
    // Default constructor
    Fraction(int numerator = 0, int denominator = 1)
        : m_numerator{ numerator }
        , m_denominator{ denominator }
    {
        assert(denominator != 0);
    }

    friend std::ostream& operator<<(std::ostream& out, const Fraction& f1);
};

std::ostream& operator<<(std::ostream& out, const Fraction& f1)
{
	out << f1.m_numerator << '/' << f1.m_denominator;
	return out;
}
```

编译器为该类提供的默认复制构造函数和默认赋值运算符如下所示：

```cpp
#include <cassert>
#include <iostream>

class Fraction
{
private:
    int m_numerator { 0 };
    int m_denominator { 1 };

public:
    // Default constructor
    Fraction(int numerator = 0, int denominator = 1)
        : m_numerator{ numerator }
        , m_denominator{ denominator }
    {
        assert(denominator != 0);
    }

    // Possible implementation of implicit copy constructor
    Fraction(const Fraction& f)
        : m_numerator{ f.m_numerator }
        , m_denominator{ f.m_denominator }
    {
    }

    // Possible implementation of implicit assignment operator
    Fraction& operator= (const Fraction& fraction)
    {
        // self-assignment guard
        if (this == &fraction)
            return *this;

        // do the copy
        m_numerator = fraction.m_numerator;
        m_denominator = fraction.m_denominator;

        // return the existing object so we can chain this operator
        return *this;
    }

    friend std::ostream& operator<<(std::ostream& out, const Fraction& f1)
    {
	out << f1.m_numerator << '/' << f1.m_denominator;
	return out;
    }
};
```

请注意，由于这些默认版本非常适合复制此类，因此在这种情况下实际上没有理由编写我们自己的这些函数的版本。

然而，在设计处理动态分配内存的类时，成员（浅）复制会给我们带来很多麻烦！这是因为指针的浅拷贝只复制指针的地址——它不分配任何内存或复制指向的内容！

让我们来看一个例子：

```cpp
#include <cstring> // for strlen()
#include <cassert> // for assert()

class MyString
{
private:
    char* m_data{};
    int m_length{};

public:
    MyString(const char* source = "" )
    {
        assert(source); // make sure source isn't a null string

        // Find the length of the string
        // Plus one character for a terminator
        m_length = std::strlen(source) + 1;

        // Allocate a buffer equal to this length
        m_data = new char[m_length];

        // Copy the parameter string into our internal buffer
        for (int i{ 0 }; i < m_length; ++i)
            m_data[i] = source[i];
    }

    ~MyString() // destructor
    {
        // We need to deallocate our string
        delete[] m_data;
    }

    char* getString() { return m_data; }
    int getLength() { return m_length; }
};
```

上面是一个简单的字符串类，它分配内存来保存我们传入的字符串。请注意，我们没有定义复制构造函数或重载赋值运算符。因此，C++ 将提供执行浅拷贝的默认复制构造函数和默认赋值运算符。复制构造函数将如下所示：

```cpp
MyString::MyString(const MyString& source)
    : m_length { source.m_length }
    , m_data { source.m_data }
{
}
```

请注意，m_data 只是 source.m_data 的浅指针副本，这意味着它们现在都指向同一个东西。

现在，考虑以下代码片段：

```cpp
#include <iostream>

int main()
{
    MyString hello{ "Hello, world!" };
    {
        MyString copy{ hello }; // use default copy constructor
    } // copy is a local variable, so it gets destroyed here.  The destructor deletes copy's string, which leaves hello with a dangling pointer

    std::cout << hello.getString() << '\n'; // this will have undefined behavior

    return 0;
}
```

虽然这段代码看起来无害，但它包含一个隐蔽的问题，会导致程序表现出未定义的行为！

让我们逐行分析一下这个例子：

```cpp
MyString hello{ "Hello, world!" };
```

这行代码没什么害处。它调用 MyString 构造函数，该构造函数分配一些内存，将 hello.m_data 设置为指向它，然后将字符串“Hello, world!”复制到其中。

```cpp
MyString copy{ hello }; // use default copy constructor
```

这行代码看起来也没什么害处，但它实际上是问题的根源！当评估这行代码时，C++ 将使用默认的复制构造函数（因为我们没有提供自己的构造函数）。此复制构造函数将执行浅拷贝，将 copy.m_data 初始化为 hello.m_data 的相同地址。因此，copy.m_data 和 hello.m_data 现在都指向同一块内存！

```cpp
} // copy gets destroyed here
```

当 copy 超出范围时，MyString 析构函数会在 copy 上被调用。析构函数会删除 copy.m_data 和 hello.m_data 指向的动态分配的内存！因此，通过删除 copy，我们也（无意中）影响了 hello。变量 copy 随后被销毁，但 hello.m_data 仍指向已删除的（无效）内存！

```cpp
std::cout << hello.getString() << '\n'; // this will have undefined behavior
```

现在您可以看到为什么该程序具有未定义的行为。我们删除了 hello 指向的字符串，现在我们尝试打印不再分配的内存的值。

这个问题的根源在于复制构造函数所做的浅复制——在复制构造函数或重载赋值运算符中对指针值进行浅复制几乎总是会带来麻烦。

## 深度复制

解决此问题的一个方法是对要复制的任何非空指针进行深度复制。**深度复制**会为副本分配内存，然后复制实际值，这样副本就位于与源不同的内存中。这样，副本和源就不同，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。

让我们继续展示如何为 MyString 类完成此操作：

```cpp
// assumes m_data is initialized
void MyString::deepCopy(const MyString& source)
{
    // first we need to deallocate any value that this string is holding!
    delete[] m_data;

    // because m_length is not a pointer, we can shallow copy it
    m_length = source.m_length;

    // m_data is a pointer, so we need to deep copy it if it is non-null
    if (source.m_data)
    {
        // allocate memory for our copy
        m_data = new char[m_length];

        // do the copy
        for (int i{ 0 }; i < m_length; ++i)
            m_data[i] = source.m_data[i];
    }
    else
        m_data = nullptr;
}

// Copy constructor
MyString::MyString(const MyString& source)
{
    deepCopy(source);
}
```

如您所见，这比简单的浅拷贝要复杂得多！首先，我们必须检查以确保源确实有一个字符串（第 11 行）。如果有，那么我们分配足够的内存来保存该字符串的副本（第 14 行）。最后，我们必须手动复制字符串（第 17 行和第 18 行）。

现在让我们来做重载赋值运算符。重载赋值运算符稍微有点棘手：

```cpp
// Assignment operator
MyString& MyString::operator=(const MyString& source)
{
    // check for self-assignment
    if (this != &source)
    {
        // now do the deep copy
        deepCopy(source);
    }

    return *this;
}
```

请注意，我们的赋值运算符与我们的复制构造函数非常相似，但有三个主要区别：

- 我们添加了自我分配检查。
- 我们返回 *this 以便我们可以链接赋值运算符。
- 我们需要明确释放字符串中已经持有的任何值（这样当 m_data 稍后重新分配时就不会发生内存泄漏）。这在 deepCopy() 中处理。

当调用重载赋值运算符时，被赋值的项可能已经包含先前的值，我们需要确保在为新值分配内存之前清理该值。对于非动态分配的变量（固定大小），我们不必担心，因为新值只会覆盖旧值。但是，对于动态分配的变量，我们需要在分配任何新内存之前明确释放任何旧内存。如果我们不这样做，代码不会崩溃，但每次进行赋值时都会发生内存泄漏，这会消耗掉我们的可用内存！

## 三法则

还记得三的规则吗？如果一个类需要用户定义的析构函数、复制构造函数或复制赋值运算符，那么它可能需要这三个。这就是原因。如果我们用户定义这些函数中的任何一个，可能是因为我们正在处理动态内存分配。我们需要复制构造函数和复制赋值来处理深度复制，以及析构函数来释放内存。

## 更好的解决方案

标准库中处理动态内存的类（例如 std::string 和 std::vector）负责处理所有内存管理，并具有重载的复制构造函数和赋值运算符，可进行正确的深度复制。因此，您无需自己进行内存管理，只需像普通的基本变量一样初始化或分配它们即可！这使得这些类更易于使用、更不容易出错，而且您不必花时间编写自己的重载函数！

## 概括

- 默认复制构造函数和默认赋值运算符执行浅复制，这对于不包含动态分配变量的类来说没有问题。
- 具有动态分配变量的类需要具有执行深度复制的复制构造函数和赋值运算符。
- 与自行进行内存管理相比，优先使用标准库中的类。

# 21.14 — 重载运算符和函数模板

在课程[11.7 — 函数模板实例化](https://www.learncpp.com/cpp-tutorial/function-template-instantiation/)中，我们讨论了编译器如何使用函数模板实例化函数，然后对其进行编译。我们还注意到，如果函数模板中的代码尝试执行实际类型不支持的某些操作（例如将整数值添加`1`到 a `std::string`），这些函数可能无法编译。

在本课中，我们将看几个例子，其中我们的实例化函数无法编译，因为我们的实际类类型不支持这些运算符，并展示如何定义这些运算符，以便实例化函数可以编译。

## **运算符、函数调用和函数模板**

首先，让我们创建一个简单的类：

```cpp
class Cents
{
private:
    int m_cents{};
public:
    Cents(int cents)
        : m_cents { cents }
    {
    }

    friend std::ostream& operator<< (std::ostream& ostr, const Cents& c)
    {
        ostr << c.m_cents;
        return ostr;
    }
};
```

并定义一个`max`函数模板：

```cpp
template <typename T>
const T& max(const T& x, const T& y)
{
    return (x < y) ? y : x;
}
```

现在，让我们看看当我们尝试调用`max()`类型的对象时会发生什么`Cents`：

```cpp
#include <iostream>

class Cents
{
private:
    int m_cents{};
public:
    Cents(int cents)
        : m_cents { cents }
    {
    }

    friend std::ostream& operator<< (std::ostream& ostr, const Cents& c)
    {
        ostr << c.m_cents;
        return ostr;
    }
};

template <typename T>
const T& max(const T& x, const T& y)
{
    return (x < y) ? y : x;
}

int main()
{
    Cents nickel{ 5 };
    Cents dime{ 10 };

    Cents bigger { max(nickel, dime) };
    std::cout << bigger << " is bigger\n";

    return 0;
}
```

C++ 将为 max() 创建一个如下所示的模板实例：

```cpp
template <>
const Cents& max(const Cents& x, const Cents& y)
{
    return (x < y) ? y : x;
}
```

然后它将尝试编译此函数。看到这里的问题了吗？C++ 不知道如何计算x < y当`x`和`y`为`Cents`类型时！因此，这将产生编译错误。

为了解决这个问题，只需`operator<`对我们希望使用`max`的任何类进行重载：

```cpp
#include <iostream>

class Cents
{
private:
    int m_cents {};
public:
    Cents(int cents)
        : m_cents { cents }
    {
    }

    friend bool operator< (const Cents& c1, const Cents& c2)
    {
        return (c1.m_cents < c2.m_cents);
    }

    friend std::ostream& operator<< (std::ostream& ostr, const Cents& c)
    {
        ostr << c.m_cents;
        return ostr;
    }
};

template <typename T>
const T& max(const T& x, const T& y)
{
    return (x < y) ? y : x;
}

int main()
{
    Cents nickel{ 5 };
    Cents dime { 10 };

    Cents bigger { max(nickel, dime) };
    std::cout << bigger << " is bigger\n";

    return 0;
}
```

它按预期工作并打印：

```
10 is bigger
```

## 另一个例子

让我们再举一个例子，说明由于缺少重载运算符而导致函数模板无法工作。

以下函数模板将计算数组中多个对象的平均值：

```cpp
#include <iostream>

template <typename T>
T average(const T* myArray, int numValues)
{
    T sum { 0 };
    for (int count { 0 }; count < numValues; ++count)
        sum += myArray[count];

    sum /= numValues;
    return sum;
}

int main()
{
    int intArray[] { 5, 3, 2, 1, 4 };
    std::cout << average(intArray, 5) << '\n';

    double doubleArray[] { 3.12, 3.45, 9.23, 6.34 };
    std::cout << average(doubleArray, 4) << '\n';

    return 0;
}
```

这会产生以下值：

```
3 
5.535
```

正如您所见，它对于内置类型非常有用！

现在让我们看看当我们在`Cents`类上调用此函数时会发生什么：

```cpp
#include <iostream>

template <typename T>
T average(const T* myArray, int numValues)
{
    T sum { 0 };
    for (int count { 0 }; count < numValues; ++count)
        sum += myArray[count];

    sum /= numValues;
    return sum;
}

class Cents
{
private:
    int m_cents {};
public:
    Cents(int cents)
        : m_cents { cents }
    {
    }
};

int main()
{
    Cents centsArray[] { Cents { 5 }, Cents { 10 }, Cents { 15 }, Cents { 14 } };
    std::cout << average(centsArray, 4) << '\n';

    return 0;
}
```

编译器会失控并产生大量错误消息！第一个错误消息将是这样的：

```
错误 C2679：二进制 <<：未找到采用 Cents 类型右侧操作数的运算符（或没有可接受的转换）
error C2679: binary << : no operator found which takes a right-hand operand of type Cents (or there is no acceptable conversion)
```

请记住，average() 返回一个 Cents 对象，而我们正试图使用`operator<<`将该对象流式传输到`std::cout`。 不过，我们还没有为 `Cents`类定义`operator<<`。让我们开始吧：

```cpp
#include <iostream>

template <typename T>
T average(const T* myArray, int numValues)
{
    T sum { 0 };
    for (int count { 0 }; count < numValues; ++count)
        sum += myArray[count];

    sum /= numValues;
    return sum;
}

class Cents
{
private:
    int m_cents {};
public:
    Cents(int cents)
        : m_cents { cents }
    {
    }

    friend std::ostream& operator<< (std::ostream& out, const Cents& cents)
    {
        out << cents.m_cents << " cents ";
        return out;
    }
};

int main()
{
    Cents centsArray[] { Cents { 5 }, Cents { 10 }, Cents { 15 }, Cents { 14 } };
    std::cout << average(centsArray, 4) << '\n';

    return 0;
}
```

如果我们再次编译，我们将会得到另一个错误：

```
错误 C2676：二进制 +=：Cents 未定义此运算符或转换为预定义运算符可接受的类型
error C2676: binary += : Cents does not define this operator or a conversion to a type acceptable to the predefined operator
```

此错误实际上是由调用`average(const Cents*, int)`时创建的函数模板实例引起的。请记住，当我们调用模板函数时，编译器会“模板化”出该函数的副本，其中模板类型参数（占位符类型）已被函数调用中的实际类型替换。以下是`average()`当`T`为`Cents`对象时的函数模板实例：

```cpp
template <>
Cents average(const Cents* myArray, int numValues)
{
    Cents sum { 0 };
    for (int count { 0 }; count < numValues; ++count)
        sum += myArray[count];

    sum /= numValues;
    return sum;
}
```

我们收到错误消息的原因是由于以下行：

```cpp
sum += myArray[count];
```

在这种情况下，`sum`是一个`Cents`对象，但我们还没有定义`operator+=`对象`Cents`！我们需要定义此函数以便`average()`能够使用`Cents`。展望未来，我们可以看到`average()`也使用`operator/=`，所以我们将继续定义它：

```cpp
#include <iostream>

template <typename T>
T average(const T* myArray, int numValues)
{
    T sum { 0 };
    for (int count { 0 }; count < numValues; ++count)
        sum += myArray[count];

    sum /= numValues;
    return sum;
}

class Cents
{
private:
    int m_cents {};
public:
    Cents(int cents)
        : m_cents { cents }
    {
    }

    friend std::ostream& operator<< (std::ostream& out, const Cents& cents)
    {
        out << cents.m_cents << " cents ";
        return out;
    }

    Cents& operator+= (const Cents &cents)
    {
        m_cents += cents.m_cents;
        return *this;
    }

    Cents& operator/= (int x)
    {
        m_cents /= x;
        return *this;
    }
};

int main()
{
    Cents centsArray[] { Cents { 5 }, Cents { 10 }, Cents { 15 }, Cents { 14 } };
    std::cout << average(centsArray, 4) << '\n';

    return 0;
}
```

最后，我们的代码将编译并运行！结果如下：

```
11cents
```

请注意，我们根本不需要修改`average()`它就可以使其与类型的对象一起工作`Cents`。我们只需定义用于实现`average()`该类的`Cents`运算符，编译器会处理其余的事情！



# 21.x — 第 21 章总结和测验

在本章中，我们探讨了与运算符重载相关的主题，以及重载类型转换相关的主题，以及与复制构造函数相关的主题。

## 概括

运算符重载是函数重载的一种变体，可让您为类重载运算符。重载运算符时，运算符的意图应尽可能接近运算符的原始意图。如果运算符在应用于自定义类时含义不明确且不直观，请改用命名函数。

运算符可以重载为普通函数、友元函数或成员函数。以下经验法则可帮助您确定哪种形式最适合特定情况：

- 如果要重载赋值（=）、下标（[]）、函数调用（()）或成员选择（->），请将其作为成员函数执行。
- 如果要重载一元运算符，请将其作为成员函数来执行。
- 如果要重载修改其左操作数的二元运算符（例如，operator+=），请尽可能将其作为成员函数执行。
- 如果要重载不修改其左操作数的二元运算符（例如，operator+），请将其作为普通函数或友元函数来执行。

类型转换可以重载以提供转换函数，可用于显式或隐式地将您的类转换为另一种类型。

复制构造函数是一种特殊类型的构造函数，用于从同类型的另一个对象初始化一个对象。复制构造函数用于从同类型的对象进行直接/统一初始化、复制初始化 (Fraction f = Fraction(5,3))，以及通过值传递或返回参数。

如果您不提供复制构造函数，编译器将为您创建一个。编译器提供的复制构造函数将使用成员初始化，这意味着副本的每个成员都从原始成员初始化。复制构造函数可能会出于优化目的而被省略，即使它有副作用，因此不要依赖您的复制构造函数实际执行。

构造函数默认被视为转换构造函数，这意味着编译器将使用它们将其他类型的对象隐式转换为类的对象。您可以通过在构造函数前面使用显式关键字来避免这种情况。您还可以删除类中的函数，包括复制构造函数和重载赋值运算符（如果需要）。如果调用已删除的函数，这将导致编译器错误。

赋值运算符可以重载，以便对类进行赋值。如果您未提供重载赋值运算符，编译器将为您创建一个。重载赋值运算符应始终包含自赋值检查（除非它自然处理，或者您使用复制和交换习语）。

新程序员经常会混淆赋值运算符和复制构造函数，但这其实相当简单：

- 如果在进行复制之前必须创建一个新对象，则使用复制构造函数（注意：这包括通过值传递或返回对象）。
- 如果在复制之前不需要创建新对象，则使用赋值运算符。

默认情况下，编译器提供的复制构造函数和赋值运算符会逐个成员地进行初始化或赋值，这是一种浅拷贝。如果您的类动态分配内存，这可能会导致问题，因为多个对象最终会指向同一块分配的内存。在这种情况下，您需要明确定义这些才能进行深拷贝。更好的做法是，如果可以的话，避免自己进行内存管理，而是使用标准库中的类。

## 测验时间

### 问题 #1

1. 假设`Point`是一个类并且`point`是该类的一个实例，您是否应该对以下运算符使用普通/友元或成员函数重载？

a）`point + point`

二进制`operator+`最好作为普通/友元函数来实现。

b)`-point`

一元函数`operator-`最好作为成员函数来实现。

c)`std::cout << point`

`operator<<`必须作为普通/友元函数来实现。

d)`point = 5;`

`operator=`必须作为成员函数来实现。

### 问题 #2

编写一个名为 Average 的类，用于跟踪传递给它的所有整数的平均值。使用两个成员：第一个应该是类型`std::int32_t`，用于跟踪迄今为止看到的所有数字的总和。第二个应该跟踪迄今为止看到的数字数量。您可以将它们相除以找到平均值。

a) 编写以下程序运行所需的所有函数：

```cpp
int main()
{
	Average avg{};
	std::cout << avg << '\n';

	avg += 4;
	std::cout << avg << '\n'; // 4 / 1 = 4

	avg += 8;
	std::cout << avg << '\n'; // (4 + 8) / 2 = 6

	avg += 24;
	std::cout << avg << '\n'; // (4 + 8 + 24) / 3 = 12

	avg += -10;
	std::cout << avg << '\n'; // (4 + 8 + 24 - 10) / 4 = 6.5

	(avg += 6) += 10; // 2 calls chained together
	std::cout << avg << '\n'; // (4 + 8 + 24 - 10 + 6 + 10) / 6 = 7

	Average copy{ avg };
	std::cout << copy << '\n';

	return 0;
}
```

并产生结果：

```
0
4
6
12
6.5
7
7
```

```cpp
#include <iostream>
#include <cstdint> // for fixed width integers

class Average
{
private:
	std::int32_t m_total{ 0 }; // the sum of all numbers we've seen so far
	int m_numbers{ 0 }; // the count of numbers we've seen so far

public:
	Average()
	{
	}

	friend std::ostream& operator<<(std::ostream& out, const Average& average)
	{
        // Handle case where we haven't seen any numbers yet
		if (average.m_numbers == 0)
		{
			out << 0;
			return out;
		}

		// Our average is the sum of the numbers we've seen divided by the count of the numbers we've seen
		// We need to remember to do a floating point division here, not an integer division
		out << static_cast<double>(average.m_total) / average.m_numbers;

		return out;
	}

	// Because operator+= modifies its left operand, we'll write it as a member
	Average& operator+=(std::int32_t num)
	{
		// Increment our total by the new number
		m_total += num;
		// And increase the count by 1
		++m_numbers;

		// return *this in case someone wants to chain +='s together
		return *this;
	}
};

int main()
{
	Average avg{};
	std::cout << avg << '\n';

	avg += 4;
	std::cout << avg << '\n';

	avg += 8;
	std::cout << avg << '\n';

	avg += 24;
	std::cout << avg << '\n';

	avg += -10;
	std::cout << avg << '\n';

	(avg += 6) += 10; // 2 calls chained together
	std::cout << avg << '\n';

	Average copy{ avg };
	std::cout << copy << '\n';

	return 0;
}
```

b) 您是否应该为此类提供用户定义的复制构造函数或赋值运算符？

不可以。因为这里使用成员初始化/复制是可以的，所以使用编译器提供的默认值是可以接受的。

c) 为什么使用`std::int32_t`而不是`int`？

`int`在某些平台上可能是 16 位，这意味着我们的`Average`对象的最大分子值只能是 32,767。使用`std::int32_t`可保证 32 位整数值，这为我们提供了更大的工作范围。

### 问题 #3

从头开始编写自己的整数数组类`IntArray`（不要使用 std::array 或 std::vector）。用户应在创建数组时传入数组的大小，并且数组应动态分配。使用 assert 语句来防止出现错误数据。创建使以下程序正常运行所需的任何构造函数或重载运算符：

```cpp
#include <iostream>

IntArray fillArray()
{
	IntArray a(5);

	a[0] = 5;
	a[1] = 8;
	a[2] = 2;
	a[3] = 3;
	a[4] = 6;

	return a;
}

int main()
{
	IntArray a{ fillArray() };

	std::cout << a << '\n';

	auto& ref{ a }; // we're using this reference to avoid compiler self-assignment errors
	a = ref;

	IntArray b(1);
	b = a;

	a[4] = 7;

	std::cout << b << '\n';

	return 0;
}
```

该程序应该打印：

```
5 8 2 3 6
5 8 2 3 6
```

```cpp
#include <iostream>
#include <cassert> // for assert

class IntArray
{
private:
	int m_length{ 0 };
	int* m_array{ nullptr };

public:
	explicit IntArray(int length)
		: m_length{ length }
	{
		assert(length > 0 && "IntArray length should be a positive integer");

		m_array = new int[static_cast<std::size_t>(m_length)] {};
	}

	// Copy constructor that does a deep copy
	IntArray(const IntArray& array)
		: m_length{ array.m_length }
	{
		// Allocate a new array
		m_array = new int[static_cast<std::size_t>(m_length)] {};

		// Copy elements from original array to new array
		for (int count{ 0 }; count < array.m_length; ++count)
			m_array[count] = array.m_array[count];
	}

	~IntArray()
	{
		delete[] m_array;
	}

	// If you're getting crazy values here you probably forgot to do a deep copy in your copy constructor
	friend std::ostream& operator<<(std::ostream& out, const IntArray& array)
	{
		for (int count{ 0 }; count < array.m_length; ++count)
		{
			out << array.m_array[count] << ' ';
		}
		return out;
	}

	int& operator[] (const int index)
	{
		assert(index >= 0);
		assert(index < m_length);
		return m_array[index];
	}

	// Assignment operator that does a deep copy
	IntArray& operator= (const IntArray& array)
	{
		// self-assignment guard
		if (this == &array)
			return *this;

		// If this array already exists, delete it so we don't leak memory
		delete[] m_array;

		m_length = array.m_length;

		// Allocate a new array
		m_array = new int[static_cast<std::size_t>(m_length)] {};

		// Copy elements from original array to new array
		for (int count{ 0 }; count < array.m_length; ++count)
			m_array[count] = array.m_array[count];

		return *this;
	}

};

IntArray fillArray()
{
	IntArray a(5);
	a[0] = 5;
	a[1] = 8;
	a[2] = 2;
	a[3] = 3;
	a[4] = 6;

	return a;
}

int main()
{
	IntArray a{ fillArray() };

	// If you're getting crazy values here you probably forgot to do a deep copy in your copy constructor
	std::cout << a << '\n';

	auto& ref{ a }; // we're using this reference to avoid compiler self-assignment errors
	a = ref;

	IntArray b(1);
	b = a;

	a[4] = 7; // change value in a, b should not change

	// If you're getting crazy values here you probably forgot to do self-assignment check
	// If b ends in 7, you probably forgot to do a deep copy in your copy assignment
	std::cout << b << '\n';

	return 0;
}
```

### 问题 #4

额外加分：这个有点棘手。

浮点数是带有小数的数，小数点后的位数可以变化。定点数是带有小数部分的数，小数部分的位数是固定的。

在这个测验中，我们将编写一个类来实现具有两个小数位的定点数（例如 12.34、3.00 或 1278.99）。假设该类的范围应为 -32768.99 到 32767.99，小数部分应包含任意两位数，我们不希望出现精度错误，并且我们希望节省空间。

#### \> 步骤#1

您认为我们应该使用哪种类型的成员变量来实现小数点后有 2 位的定点数？（在继续回答下一个问题之前，请务必阅读答案）

实现定点数的方法有很多种。由于定点数本质上是浮点数的子集（小数点后的位数是固定的而不是可变的），因此使用浮点数似乎是显而易见的选择。但浮点数存在精度问题。使用固定数量的小数，我们可以合理地枚举所有可能的分数值（在我们的例子中是 .00 到 .99），因此使用存在精度问题的数据类型并不是最佳选择。

更好的解决方案是使用 16 位有符号整数来保存数字的非小数部分，并使用 8 位有符号整数来保存小数部分。

#### \> 步骤#2

编写一个名为的类`FixedPoint2`，实现上一个问题推荐的解决方案。如果数字的非小数部分和小数部分（或两者）为负数，则应将该数字视为负数。提供以下程序运行所需的重载运算符和构造函数。现在，不必担心小数部分超出范围（>99 或 <-99）。

```cpp
#include <cassert>
#include <iostream>

int main()
{
	FixedPoint2 a{ 34, 56 };
	std::cout << a << '\n';
	std::cout << static_cast<double>(a) << '\n';
	assert(static_cast<double>(a) == 34.56);

	FixedPoint2 b{ -2, 8 };
	assert(static_cast<double>(b) == -2.08);

	FixedPoint2 c{ 2, -8 };
	assert(static_cast<double>(c) == -2.08);

	FixedPoint2 d{ -2, -8 };
	assert(static_cast<double>(d) == -2.08);

	FixedPoint2 e{ 0, -5 };
	assert(static_cast<double>(e) == -0.05);

	FixedPoint2 f{ 0, 10 };
	assert(static_cast<double>(f) == 0.1);

	return 0;
}
```

该程序应产生以下结果：

```
34.56
34.56
```

提示：要输出您的数字，请将其 static_cast 为双精度型。

```cpp
#include <cassert>
#include <cstdint> // for fixed width integers
#include <iostream>

class FixedPoint2
{
private:
	std::int16_t m_base{}; // here's our non-fractional part
	std::int8_t m_decimal{}; // here's our factional part

public:
	FixedPoint2(std::int16_t base = 0, std::int8_t decimal = 0)
		: m_base{ base }, m_decimal{ decimal }
	{
		// If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative
		if (m_base < 0 || m_decimal < 0)
		{
			// Make sure base is negative
			if (m_base > 0)
				m_base = -m_base;
			// Make sure decimal is negative
			if (m_decimal > 0)
				m_decimal = -m_decimal;
		}
	}

	explicit operator double() const
	{
		return m_base + (static_cast<double>(m_decimal) / 100);
	}
};

// This doesn't require access to the internals of the class, so it can be defined outside the class
std::ostream& operator<<(std::ostream& out, const FixedPoint2& fp)
{
	out << static_cast<double>(fp);
	return out;
}

int main()
{
	FixedPoint2 a{ 34, 56 };
	std::cout << a << '\n';
	std::cout << static_cast<double>(a) << '\n';
	assert(static_cast<double>(a) == 34.56);

	FixedPoint2 b{ -2, 8 };
	assert(static_cast<double>(b) == -2.08);

	FixedPoint2 c{ 2, -8 };
	assert(static_cast<double>(c) == -2.08);

	FixedPoint2 d{ -2, -8 };
	assert(static_cast<double>(d) == -2.08);

	FixedPoint2 e{ 0, -5 };
	assert(static_cast<double>(e) == -0.05);

	FixedPoint2 f{ 0, 10 };
	assert(static_cast<double>(f) == 0.1);

	return 0;
}
```

#### \> 步骤#3

现在让我们处理小数部分超出范围的情况。我们这里有两个合理的策略：

- 限制分数部分（如果 >99，则设置为 99）。
- 将溢出视为相关（如果 > 99，则减少 100 并在基数上加 1）。

在这个练习中，我们将把十进制溢出视为相关的，因为这在下一步中很有用。

应该运行以下命令：

```cpp
#include <cassert>
#include <iostream>

// You will need to make testDecimal a friend of FixedPoint2
// so the function can access the private members of FixedPoint2
bool testDecimal(const FixedPoint2 &fp)
{
    if (fp.m_base >= 0)
        return fp.m_decimal >= 0 && fp.m_decimal < 100;
    else
        return fp.m_decimal <= 0 && fp.m_decimal > -100;
}

int main()
{
	FixedPoint2 a{ 1, 104 };
	std::cout << a << '\n';
	std::cout << static_cast<double>(a) << '\n';
	assert(static_cast<double>(a) == 2.04);
	assert(testDecimal(a));

	FixedPoint2 b{ 1, -104 };
	assert(static_cast<double>(b) == -2.04);
	assert(testDecimal(b));

	FixedPoint2 c{ -1, 104 };
	assert(static_cast<double>(c) == -2.04);
	assert(testDecimal(c));

	FixedPoint2 d{ -1, -104 };
	assert(static_cast<double>(d) == -2.04);
	assert(testDecimal(d));

	return 0;
}
```

并产生输出：

```
2.04
2.04
```

```cpp
#include <cassert>
#include <cstdint> // for fixed width integers
#include <iostream>

class FixedPoint2
{
private:
	std::int16_t m_base{}; // here's our non-fractional part
	std::int8_t m_decimal{}; // here's our factional part

public:
	FixedPoint2(std::int16_t base = 0, std::int8_t decimal = 0)
		: m_base{ base }, m_decimal{ decimal }
	{
		// If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative
		if (m_base < 0 || m_decimal < 0)
		{
			// Make sure base is negative
			if (m_base > 0)
				m_base = -m_base;
			// Make sure decimal is negative
			if (m_decimal > 0)
				m_decimal = -m_decimal;
		}

		// If decimal is out of bounds (in either direction),
		// adjust the decimal so it's in bounds,
		// and adjust base to account for the number of units removed from the decimal
		// h/t to reader David Pinheiro for simplifying this
		m_base += m_decimal / 100;    // integer division
		m_decimal = m_decimal % 100;  // integer remainder
	}

	explicit operator double() const
	{
		return m_base + (static_cast<double>(m_decimal) / 100);
	}

	friend bool testDecimal(const FixedPoint2 &fp);
};

// This doesn't require access to the internals of the class, so it can be defined outside the class
std::ostream& operator<<(std::ostream& out, const FixedPoint2& fp)
{
	out << static_cast<double>(fp);
	return out;
}

// You will need to make testDecimal a friend of FixedPoint2
// so the function can access the private members of FixedPoint2
bool testDecimal(const FixedPoint2 &fp)
{
	if (fp.m_base >= 0)
		return fp.m_decimal >= 0 && fp.m_decimal < 100;
	else
		return fp.m_decimal <= 0 && fp.m_decimal > -100;
}

int main()
{
	FixedPoint2 a{ 1, 104 };
	std::cout << a << '\n';
	std::cout << static_cast<double>(a) << '\n';
	assert(static_cast<double>(a) == 2.04);
	assert(testDecimal(a));

	FixedPoint2 b{ 1, -104 };
	assert(static_cast<double>(b) == -2.04);
	assert(testDecimal(b));

	FixedPoint2 c{ -1, 104 };
	assert(static_cast<double>(c) == -2.04);
	assert(testDecimal(c));

	FixedPoint2 d{ -1, -104 };
	assert(static_cast<double>(d) == -2.04);
	assert(testDecimal(d));

	return 0;
}
```

#### \> 步骤#4

现在添加一个接受 double 的构造函数。以下程序应运行：

```cpp
#include <cassert>
#include <iostream>

int main()
{
	FixedPoint2 a{ 0.01 };
	assert(static_cast<double>(a) == 0.01);

	FixedPoint2 b{ -0.01 };
	assert(static_cast<double>(b) == -0.01);

	FixedPoint2 c{ 1.9 }; // make sure we handle single digit decimal
	assert(static_cast<double>(c) == 1.9);

	FixedPoint2 d{ 5.01 }; // stored as 5.0099999... so we'll need to round this
	assert(static_cast<double>(d) == 5.01);

	FixedPoint2 e{ -5.01 }; // stored as -5.0099999... so we'll need to round this
	assert(static_cast<double>(e) == -5.01);

	// Handle case where the argument's decimal rounds to 100 (need to increase base by 1)
	FixedPoint2 f { 106.9978 }; // should be stored with base 107 and decimal 0
	assert(static_cast<double>(f) == 107.0);

	// Handle case where the argument's decimal rounds to -100 (need to decrease base by 1)
	FixedPoint2 g { -106.9978 }; // should be stored with base -107 and decimal 0
	assert(static_cast<double>(g) == -107.0);

	return 0;
}
```

建议：这个有点棘手。分三步完成。首先，解决 double 参数可直接表示的情况（上面的变量）。然后，更新代码以处理 double 参数有舍入误差的情况（变量`a`& ）。变量和应该由我们在上一步中添加的溢出处理来处理。`c``d``e``f``g`

对于所有情况：

提示：乘以 10 即可将小数点右边的数字移动到小数点左边。乘以 100 即可移动两位。

对于变量`a`通过`c`：

提示：您可以通过将双精度数静态转换为整数来获取双精度数的非小数部分。要获取小数部分，您可以减去底数部分。

对于变量`d`& `e`：

`std::round()`提示：您可以使用函数（包含在标题中）对数字（小数点左边）进行四舍五入`<cmath>`，然后使用 对该数字（朝向零）取底数`std::trunc()`。

```cpp
#include <cassert>
#include <cmath>
#include <cstdint> // for fixed width integers
#include <iostream>

class FixedPoint2
{
private:
	std::int16_t m_base{}; // here's our non-fractional part
	std::int8_t m_decimal{}; // here's our factional part

public:
	FixedPoint2(std::int16_t base = 0, std::int8_t decimal = 0)
		: m_base{ base }, m_decimal{ decimal }
	{
		// If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative
		if (m_base < 0 || m_decimal < 0)
		{
			// Make sure base is negative
			if (m_base > 0)
				m_base = -m_base;
			// Make sure decimal is negative
			if (m_decimal > 0)
				m_decimal = -m_decimal;
		}

		// If decimal is out of bounds (in either direction),
		// adjust the decimal so it's in bounds,
		// and adjust base to account for the number of units removed from the decimal
		// h/t to reader David Pinheiro for simplifying this
		m_base += m_decimal / 100;    // integer division
		m_decimal = m_decimal % 100;  // integer remainder
	}

	// We'll delegate to the prior constructor so we don't have to duplicate the negative number and overflow handling logic
	FixedPoint2(double d) :
		FixedPoint2(
			static_cast<std::int16_t>(std::trunc(d)),
			static_cast<std::int8_t>(std::round(d * 100) - std::trunc(d) * 100)
		)
	{
	}

	explicit operator double() const
	{
		return m_base + (static_cast<double>(m_decimal) / 100);
	}
};

// This doesn't require access to the internals of the class, so it can be defined outside the class
std::ostream& operator<<(std::ostream& out, const FixedPoint2& fp)
{
	out << static_cast<double>(fp);
	return out;
}

int main()
{
	FixedPoint2 a{ 0.01 };
	std::cout << a << '\n';
	assert(static_cast<double>(a) == 0.01);

	FixedPoint2 b{ -0.01 };
	assert(static_cast<double>(b) == -0.01);

	FixedPoint2 c{ 1.9 }; // make sure we handle single digit decimal
	assert(static_cast<double>(c) == 1.9);

	FixedPoint2 d{ 5.01 }; // stored as 5.0099999... so we'll need to round this
	assert(static_cast<double>(d) == 5.01);

	FixedPoint2 e{ -5.01 }; // stored as -5.0099999... so we'll need to round this
	assert(static_cast<double>(e) == -5.01);

	// Handle case where the argument's decimal rounds to 100 (need to increase base by 1)
	FixedPoint2 f { 106.9978 }; // should be stored with base 107 and decimal 0
	assert(static_cast<double>(f) == 107.0);

	// Handle case where the argument's decimal rounds to -100 (need to decrease base by 1)
	FixedPoint2 g { -106.9978 }; // should be stored with base -107 and decimal 0
	assert(static_cast<double>(g) == -107.0);

	return 0;
}
```

#### \> 步骤#5

重载`operator==`、`operator>>`、`operator-`（一元）和`operator+`（二进制）。

应运行以下程序：

```cpp
#include <cassert>
#include <iostream>

int main()
{
	assert(FixedPoint2{ 0.75 } == FixedPoint2{ 0.75 });    // Test equality true
	assert(!(FixedPoint2{ 0.75 } == FixedPoint2{ 0.76 })); // Test equality false

	// Test additional cases -- h/t to reader Sharjeel Safdar for these test cases
	assert(FixedPoint2{ 0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 1.98 });    // both positive, no decimal overflow
	assert(FixedPoint2{ 0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 2.25 });    // both positive, with decimal overflow
	assert(FixedPoint2{ -0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -1.98 }); // both negative, no decimal overflow
	assert(FixedPoint2{ -0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -2.25 }); // both negative, with decimal overflow
	assert(FixedPoint2{ 0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -0.48 });  // second negative, no decimal overflow
	assert(FixedPoint2{ 0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -0.75 });  // second negative, possible decimal overflow
	assert(FixedPoint2{ -0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 0.48 });   // first negative, no decimal overflow
	assert(FixedPoint2{ -0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 0.75 });   // first negative, possible decimal overflow

	FixedPoint2 a{ -0.48 };
	assert(static_cast<double>(a) == -0.48);
	assert(static_cast<double>(-a) == 0.48);

	std::cout << "Enter a number: "; // enter 5.678
	std::cin >> a;
	std::cout << "You entered: " << a << '\n';
	assert(static_cast<double>(a) == 5.68);

	return 0;
}
```

`FixedPoint2`提示：利用双重转换将两个数字相加，将结果相加，然后转换回`FixedPoint2`。这可以优雅地处理小数溢出。

提示：对于`operator>>`，使用双构造函数创建类型的匿名对象`FixedPoint2`，并将其分配给`FixedPoint2`函数参数。

```cpp
#include <cassert>
#include <cmath>
#include <cstdint> // for fixed width integers
#include <iostream>

class FixedPoint2
{
private:
	std::int16_t m_base{}; // here's our non-fractional part
	std::int8_t m_decimal{}; // here's our factional part

public:
	FixedPoint2(std::int16_t base = 0, std::int8_t decimal = 0)
		: m_base{ base }, m_decimal{ decimal }
	{
		// If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative
		if (m_base < 0 || m_decimal < 0)
		{
			// Make sure base is negative
			if (m_base > 0)
				m_base = -m_base;
			// Make sure decimal is negative
			if (m_decimal > 0)
				m_decimal = -m_decimal;
		}

		// If decimal is out of bounds (in either direction),
		// adjust the decimal so it's in bounds,
		// and adjust base to account for the number of units removed from the decimal
		// h/t to reader David Pinheiro for simplifying this
		m_base += m_decimal / 100;    // integer division
		m_decimal = m_decimal % 100;  // integer remainder
	}

	FixedPoint2(double d) :
		FixedPoint2(
			static_cast<std::int16_t>(std::trunc(d)),
			static_cast<std::int8_t>(std::round(d * 100) - std::trunc(d) * 100)
		)
	{
	}

	explicit operator double() const
	{
		return m_base + (static_cast<double>(m_decimal) / 100);
	}

	friend bool operator==(const FixedPoint2& fp1, const FixedPoint2& fp2)
	{
		return fp1.m_base == fp2.m_base && fp1.m_decimal == fp2.m_decimal;
	}

	FixedPoint2 operator-() const
	{
		// Cast to double, make the double negative, then convert back to FixedPoint2
		// h/t to reader EmtyC for this version
		return FixedPoint2{ -static_cast<double>(*this) };
	}
};

// This doesn't require access to the internals of the class, so it can be defined outside the class
std::ostream& operator<<(std::ostream& out, const FixedPoint2& fp)
{
	out << static_cast<double>(fp);
	return out;
}

std::istream& operator>>(std::istream& in, FixedPoint2& fp)
{
	double d{};
	in >> d;
	fp = FixedPoint2{ d };

	return in;
}

FixedPoint2 operator+(const FixedPoint2& fp1, const FixedPoint2& fp2)
{
	return FixedPoint2{ static_cast<double>(fp1) + static_cast<double>(fp2) };
}

int main()
{
	assert(FixedPoint2{ 0.75 } == FixedPoint2{ 0.75 });    // Test equality true
	assert(!(FixedPoint2{ 0.75 } == FixedPoint2{ 0.76 })); // Test equality false

	// Test additional cases -- h/t to reader Sharjeel Safdar for these test cases
	assert(FixedPoint2{ 0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 1.98 });    // both positive, no decimal overflow
	assert(FixedPoint2{ 0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 2.25 });    // both positive, with decimal overflow
	assert(FixedPoint2{ -0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -1.98 }); // both negative, no decimal overflow
	assert(FixedPoint2{ -0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -2.25 }); // both negative, with decimal overflow
	assert(FixedPoint2{ 0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -0.48 });  // second negative, no decimal overflow
	assert(FixedPoint2{ 0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -0.75 });  // second negative, possible decimal overflow
	assert(FixedPoint2{ -0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 0.48 });   // first negative, no decimal overflow
	assert(FixedPoint2{ -0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 0.75 });   // first negative, possible decimal overflow

	FixedPoint2 a{ -0.48 };
	assert(static_cast<double>(a) == -0.48);
	assert(static_cast<double>(-a) == 0.48);

	std::cout << "Enter a number: "; // enter 5.678
	std::cin >> a;
	std::cout << "You entered: " << a << '\n';
	assert(static_cast<double>(a) == 5.68);

	return 0;
```