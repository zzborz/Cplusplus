# 链表

```cPP
//链表定义
typedef struct Lnode {
	int data;//节点的数据域
	struct Lnode* next;//节点的指针域
}Lnode, *LinkList;
//链表初始化
bool InitList(LinkList& L) {
	L = new Lnode;//堆区开辟一个新结点作为链表的头节点（head），同时作为头指针指向头节点
	L->next = NULL;
	return true;
}
//判断链表是否为空
int IsEmpty(LinkList& L) {
	if (L->next == NULL) return TRUE;
	return FALSE;
}
//销毁单链表
int DestoryList(LinkList& L) {
	LinkList p;//创建一个指针
	while (L != NULL) {
		p = L;
		L = L->next;
		delete p;//L移动到下一个指针，删除p指向的节点。
	}
	return OK;
}
//清空链表
int ClearList(LinkList& L) {
	LinkList p;
	LinkList q;//创建两个指针，用于依次释放节点
	p = L->next;//将指针p指向首元节点处
	while (L != NULL) {
		q = p->next;//将p指向的那个节点的指针域赋给q,实际上就是让q指向p的下一个节点。
		delete p;//释放p指向的节点
		p = q;//将q赋给p，实际上就是让p指向q指向的节点	
	}
	L->next = NULL;//���头节点的指针域置空
	return OK;
}
//获取单链表的表长只要统计表长，不改变链表元素，因此不用&
int GetLength(LinkList L) //这里
{
	LinkList p;
	p = L->next;//将头节点的next阈值赋给p
	int i = 0;
	while (p!= NULL) {
		i++;
		p = p->next;

	}
	return i;
}
//获取链表中第i个元素的值
int GetElem(LinkList L, int i, int& e)
{
	LinkList p;
	p = L->next;//p指向首元节点
	int j = 1;//因为p已经在首元节点了，所以这里赋值直接使j=1
	while (p != NULL && j < i)//依次向后扫描，直到p指向第i个元素或者p指向空
	{
		p = p->next;
		j++;
	}
	if (!p || j > i)
	{
		cout << "out of range" << endl;
		return ERROR;
	}
	e = p->data;
	return OK;
}
//查找---按值查找，返回地址 --地址要用 指针形式返回
Lnode* LocateElem(LinkList L, int e)
{
	LinkList p;
	p = L->next;//p指向首元节点
	while (p != NULL && p->data)
	{
		p = p->next;
	}
	return p;//不管找没找到都返回地址，只是没找到时p指向空处
}
//查找-按值查找，返回位置序号
int LocateElem_L(LinkList L, int e)
{
	LinkList p;
	p = L->next;//p指向首元结点
	int j = 1;
	while (p != NULL && p->data != e)
	{
		p = p->next;
		j++;
	}
	if (p != NULL)//如果p不为空，说明找到了，返回j的位置
	{
		return j;
	}
	else//否则返回0
	{
		return 0;
	}
}
//在链表第i个位置插入新结点e
bool InsertList(LinkList& L, int i, int e) {
	LinkList p;
	p = L;//p指向头节点
	int j = 0;//j从0开始
	while (p != NULL && j < i - 1) {//寻找第i-1个节点，让指针p指向第i-1个节点位置
		p = p->next;
		++j;
	}
	if(!p||j>i-1){//i大于表长+1或者小于1，插入位置违法
		return ERROR;
	}
	Lnode* s = new Lnode;//创建一个新节点	
	s->data = e;//将新节点的数据域赋值为e
	s->next = p->next;//将新节点的指针域指向p的下一个节点
	p->next = s;//将p的指针域指向新节点
	return true;
}
//删除链表第i个位置的元素
int DeletLnode(LinkList& L, int i, int& e) {
	LinkList p;//创建一个指针,指向第i-1个节点的位置，不能直接指向第i个节点，因为删除时需要找到第i-1个节点
	p = L;
	int j = 0;
	while (p->next != NULL && j < i - 1) {//寻找第i-1个节点,并令p指向第i-1个节点
		p = p->next;
		++j;
	}
	if (!p->next || j > i - 1) {//i大于表长+1或者小于1，删除位置违法
		return ERROR;
	}
	LinkList q = p->next;//创建一个指针q，指向第i个节点
	p->next = q->next;//将第i-1个节点的指针域指向第i+1个节点
	e = q->data;//将第i个节点的数据域赋值给e
	//释放删除节点的空间，另外说明：这里不特定删除指针去，因为指针q不是在堆区开辟的，即不是new出来的，所以局部
	//变量执行完毕后，还给栈区了。
	delete q;
	return OK;
}
//输出链表 打印链表所有数据域的数据
void PrintList(LinkList L) {
	LinkList p;
	p = L->next;//p指向首元节点
	while (p != NULL) {
		cout << p->data << " ";
		p = p->next;
	}
	cout << endl;
}
```

# 单链表头插法

```cPP
//单链表的建立——头插法
void CreateListHead(LinkList& L, int n) {
	L = new Lnode;//创建一个头节点;在堆区开辟；注意这里new过之后才是结点，否则就是一个指针
	L->next = nullptr;//头节点的指针域置空 c++11写法
	for(int i=n;i>0;--i){
		Lnode* p = new Lnode;//创建新节点
		cin >> p->data;//输入新节点的数据
		//解释：第一次把p的结点的next域指针置为NULL，意思是最后一个结点的next域指针指向NULL,而后来的
		//结点的next域指针指向前一个结点，这样就形成了一个链表
		p->next = L->next;//将新节点的指针域指向头节点的指针域
		L->next = p;//将头节点的指针域指向新节点
	}
}
```

# 单链表尾插法

```cpp
//单链表的建立——尾插法
void CreateListTail(LinkList& L,int n){//通过&返回链表
	L = new Lnode;//创建一个头节点;在堆区开辟；���意这里new过之后才是结点，否则就是一个指针
	L->next = nullptr;//头节点的指针域置空 c++11写法
	LinkList r = L;//创建一个尾指针，尾指针指向头节点
	for (int i = n; i > 0; --i) {
		Lnode* p = new Lnode;//创建新节点
		cin >> p->data;//输入新节点的数据
		r->next = p;//将尾指针的指针域指向新节点,插入到尾部
		r = p;//将尾指针指向新节点，每连接上一个新结点，就把尾指针后移到新结点上，所以称之为尾指针
	}
}
```

# 单链表删除节点

```cpp
//删除链表第i个位置的元素
int DeletLnode(LinkList& L, int i, int& e) {
	LinkList p;//创建一个指针,指向第i-1个节点的位置，不能直接指向第i个节点，因为删除时需要找到第i-1个节点
	p = L;
	int j = 0;
	while (p->next != NULL && j < i - 1) {//寻找第i-1个节点,并令p指向第i-1个节点
		p = p->next;
		++j;
	}
	if (!p->next || j > i - 1) {//i大于表长+1或者小于1，删除位置违法
		return ERROR;
	}
	LinkList q = p->next;//创建一个指针q，指向第i个节点
	p->next = q->next;//将第i-1个节点的指针域指向第i+1个节点
	e = q->data;//将第i个节点的数据域赋值给e
	//释放删除节点的空间，另外说明：这里不特定删除指针去，因为指针q不是在堆区开辟的，即不是new出来的，所以局部
	//变量执行完毕后，还给栈区了。
	delete q;
	return OK;
}
```

# 单链表逆序1问题

```cPP
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev=nullptr;
        ListNode* curr=head;
        while(curr){
            ListNode* next=curr->next;//将下一个节点的指针指向当前节点
            curr->next=prev;//将当前节点的指针域置空
            prev=curr;//prev记住当前节点位置
            curr=next;//curr变成下一个结点的位置
        }
        return prev;      
    }
};
```

# 删除链表的倒数第N个节点

[leetcode19](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=problem-list-v2&envId=linked-list)

思路：生成一个虚拟头节点，与题目中的 *n* 保持一致，节点的编号从 1 开始，头节点为编号 1 的节点。删除链表中倒数第N个节点意味要找到这个节点的前面一个节点。目前链表长度为L，则此时要删除的节点的前一个结点为L-N+1(因为我添加了一个虚拟头节点，所以找的时候往前推移了一个结点位置)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    int getLength(ListNode* head){
        int length=0;
        while(head){
            ++length;
            head=head->next;
        }
        return length;
    }
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy =new ListNode(0,head);
        int length=getLength(head);//这里是从头节点位置开始数，并不是我加的虚拟结点。
        ListNode* cur=dummy;
        for(int i=1;i<length-n+1;++i){//从1开始计数到length-n+1
            cur=cur->next;
        }
        cur->next=cur->next->next;
        ListNode* ans=dummy->next;
        delete dummy;
        return ans;
    }
};
```

# 合并两个有序的单链表

[LeetCode链接](https://leetcode.cn/problems/merge-two-sorted-lists/submissions/595015634/?envType=problem-list-v2&envId=linked-list)

此题解法考虑双指针从头开始循环遍历往下进行排查

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dum=new ListNode(0);//先生成一个头结点
        ListNode* cur=dum;//返回头结点的下一个结点
        while(list1!=nullptr && list2!=nullptr){
            if(list1->val <list2->val){
                cur->next=list1;
                list1=list1->next;
            }
            else{
                cur->next=list2;
                list2=list2->next;
            }
            cur=cur->next;
        }
        cur->next=list1!=nullptr?list1:list2;//如果list1不为空为真的话输出list1
        return dum->next;

        
    }
};
```



# 判断两个链表是否有环以及入口节点

[LeetCode链接1](https://leetcode.cn/problems/linked-list-cycle/description/?envType=problem-list-v2&envId=linked-list)

使用快慢指针的方法

如果有环快指针会先进入环内，一直循环，而慢指针会后入环内最终被追上，所以逻辑如下

![img](./assets/5.png)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head==nullptr||head->next==nullptr){
            return false;
        }
        ListNode*slow=head;
        ListNode*fast=head->next;
        while(slow!=fast){
            if(fast==nullptr||fast->next==nullptr){
                return false;
            }
            slow=slow->next;
            fast=fast->next->next;
        }
        return true;
        
    }
};
```

[除了找到环还需要返还入口处](https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=problem-list-v2&envId=linked-list)
思路与算法

我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。

如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc。

![fig1](./assets/142_fig1.png)

根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有

a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)
有了 a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。

因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow=head,*fast=head;
        while(fast!=nullptr){
            slow=slow->next;
            if(fast->next==nullptr){
                return nullptr;
            }
            fast=fast->next->next;
            if(fast==slow){
                ListNode *ptr=head;
                while(ptr!=slow){
                    ptr=ptr->next;
                    slow=slow->next;
                }
                return ptr;
            }
        }
        return nullptr;
        
    }
};

```

# 判断两个链表是否相交



# 旋转链表

0

