# 冒泡排序

## **冒泡排序的基本原理**

冒泡排序的基本原理是通过多次遍历待排序的数组，比较相邻的两个元素并交换它们的位置，使得较大的元素逐渐“冒泡”到数组的末尾，从而实现排序。具体步骤如下：

1. **比较相邻元素**：从数组的第一个元素开始，依次比较相邻的两个元素，如果前一个元素大于后一个元素，则交换它们的位置。
2. **重复遍历**：每一轮遍历结束后，最大的元素会被移动到数组的末尾。因此，下一轮遍历可以忽略最后一个元素，继续比较剩余的元素。
3. **终止条件**：当某一轮遍历中没有发生任何交换时，说明数组已经有序，排序完成。

冒泡排序的特点是简单直观，但效率较低，时间复杂度为O(n^2)，适用于小规模数据的排序

## 冒泡排序的C++实现代码示例

以下是冒泡排序的C++实现代码示例：

```cpp
#include <iostream>
using namespace std;

// 交换元素
void swap(int *num1, int *num2) {
    int temp = *num1;
    *num1 = *num2;
    *num2 = temp;
}

// 冒泡排序实现
void bubbleSort(int arr[], int len) {
    for (int i = 0; i < len - 1; i++) {
        bool sorted = true;
        for (int j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(&arr[j], &arr[j + 1]);
                sorted = false;
            }
        }
        if (sorted) break; // 如果没有发生交换,则表示已排好序,跳出
    }
}

// 测试
int main(void) {
    int girl[] = {21, 32, 17, 33, 20, 34, 28, 27, 33};
    int len = sizeof(girl) / sizeof(girl[0]); // 获取元素个数
    bubbleSort(girl, len);
    for (int i = 0; i < len; i++) {
        cout << girl[i] << "\t";
    }
    cout << endl;

    system("pause");
    return 0;
}
```

这段代码定义了一个`bubbleSort`函数来实现冒泡排序，并在`main`函数中进行了测试。通过两层循环，外层循环控制趟数，内层循环进行冒泡排序。当内层循环结束时，输出排序后的结果

## **冒泡排序的时间复杂度分析**

冒泡排序的时间复杂度分析如下：

1. **最好情况**：当输入数组已经是有序的时，冒泡排序只需要进行一次遍历来确认数组是否已经排序。此时的时间复杂度为 O(n)。
2. **最坏情况**：当输入数组是逆序的时，冒泡排序需要进行 n−1 轮比较和交换操作，每一轮都需要遍历整个数组。因此，最坏情况下的时间复杂度为 O(n2) 。
3. **平均情况**：在平均情况下，冒泡排序的时间复杂度同样为 O(n2)，因为每次比较和交换的次数与数组长度的平方成正比 。
4. **优化情况**：通过引入标志位（flag）来检测在某一轮遍历中是否发生了交换，如果某一轮没有发生交换，则说明数组已经有序，可以提前结束排序。这种优化可以将最好情况的时间复杂度降低到 O(n)，但最坏和平均情况的时间复杂度仍为 O(n2)。

总结：冒泡排序的时间复杂度在最好情况下为 O(n)，在最坏和平均情况下为 O(n2)。



冒泡排序的空间复杂度分析

冒泡排序的空间复杂度为 O(1)。这是因为冒泡排序是一种原地排序算法，除了输入数组外，仅需要常数级别的额外空间来存储临时变量和循环计数器等辅助变量。

## LeetCode中涉及冒泡排序的题目列表及链接

1. **LeetCode 912 - 排序数组**
   - 题目描述：将整数数组升序排列。
   - 解题思路：虽然冒泡排序可以解决此问题，但其时间复杂度为 O(n2)，通常不推荐使用冒泡排序，因为更高效的算法（如快速排序）可以达到 O(nlog⁡n)的时间复杂度。
   - 链接：[LeetCode 912 - 排序数组](https://leetcode.com/problems/sort-an-array/) 
2. **LeetCode 3011 - 判断一个数组是否可以变为有序**
   - 题目描述：通过交换操作实现排序，本质上是冒泡排序的做法。
   - 解题思路：模拟冒泡排序过程，判断是否可以通过交换相邻元素的二进制位数来实现排序。
   - 链接：[LeetCode 3011 - 判断一个数组是否可以变为有序](https://leetcode.cn/problems/find-if-array-can-be-sorted/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china) 
3. **LeetCode 148 - 排序链表**
   - 题目描述：对链表进行排序。
   - 解题思路：虽然冒泡排序可以用于链表排序，但效率较低，通常推荐使用更高效的算法（如归并排序）。
   - 链接：[LeetCode 148 - 排序链表](https://leetcode.cn/problems/sort-list/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china) 
4. **LeetCode 707 - 设计链表**
   - 题目描述：设计一个链表类，并实现插入、删除等操作。
   - 解题思路：虽然题目本身与冒泡排序无直接关系，但可以通过链表排序算法（如冒泡排序）来实现链表的排序功能。
   - 链接：[LeetCode 707 - 设计链表](https://leetcode.cn/problems/design-linked-list/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
5. **LeetCode 347 - 前 K 个高频元素**
   - 题目描述：找出数组中出现频率最高的前 K 个元素。
   - 解题思路：通过排序后选择前 K 个高频元素，冒泡排序可以用于初步排序，但效率较低。
   - 链接：[LeetCode 347 - 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china) 

# 选择排序

## 选择排序的原理

选择排序（Selection Sort）是一种简单直观的排序算法。其核心思想是：**通过不断选择未排序序列中的最小（或最大）元素，将其与未排序序列的起始位置元素交换，逐步构建有序序列**。具体步骤如下：

1. **初始化**：将整个数组分为两部分，左侧为已排序序列（初始为空），右侧为未排序序列（初始为整个数组）。
2. **查找最小值**：遍历未排序序列，找到最小元素的索引。
3. **交换元素**：将找到的最小元素与未排序序列的起始位置元素交换。
4. **边界右移**：将已排序序列的右边界向右移动一位，扩大已排序序列范围。
5. **重复操作**：重复上述步骤，直到未排序序列仅剩一个元素。

**示例**：以数组 `{38, 65, 97, 76, 13, 27, 49}` 为例，每一趟排序结果如下：

- 第一趟：`13` 被选出并交换到首位 → `13, 65, 97, 76, 38, 27, 49`
- 第二趟：`27` 被选出 → `13, 27, 97, 76, 38, 65, 49`
- 后续依次类推，最终得到有序数组。

## 选择排序的C++实现

以下为选择排序的标准C++实现代码：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        swap(arr[i], arr[minIndex]);
    }
}

int main() {
    int a[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    int n = sizeof(a) / sizeof(a[0]);
    selectionSort(a, n);
    for (int i = 0; i < n; i++) {
        cout << a[i] << " ";
    }
    return 0;
}
```

**代码解析**：

- 外层循环控制已排序序列的边界（`i`从0到`n-1`）。
- 内层循环遍历未排序序列，找到最小元素的索引`minIndex`。
- 每次外层循环结束时，交换`arr[i]`与`arr[minIndex]`，将最小元素归位。

## 时间复杂度与空间复杂度分析

### 时间复杂度

选择排序的时间复杂度在所有情况下均为 **O(n²)** ，具体分析如下：

- **比较次数**：总比较次数为 (n−1)+(n−2)+⋯+1=n(n−1)2(*n*−1)+(*n*−2)+⋯+1=2*n*(*n*−1)，即近似于 O(n2)。
- **交换次数**：每次外层循环仅需一次交换，共 n−1次，即 O(n)。
- **稳定性**：无论输入是否有序，算法均需执行相同次数的比较，因此最佳、平均、最坏情况下时间复杂度一致。

### 空间复杂度

选择排序的 **空间复杂度为 O(1)** ，因为仅需常数级别的额外空间（如`minIndex`和交换时的临时变量）。

------

### 选择排序的优缺点

| **优点**               | **缺点**                             |
| ---------------------- | ------------------------------------ |
| 实现简单，逻辑清晰。   | 时间复杂度高，不适合大规模数据。     |
| 原地排序，空间效率高。 | 不稳定排序（可能改变相同元素顺序）。 |
| 交换次数少（O(n)）。   | 无法利用输入序列的已有有序性。       |

## LeetCode相关题目

虽然选择排序在实际应用中较少直接使用（因效率低），但以下题目可帮助理解其思想或作为练习：

1. **[LeetCode 912. 排序数组](https://leetcode.cn/problems/sort-an-array/)**
   - **要求**：对整数数组升序排序。
   - **选择排序实现**：直接应用上述代码，但由于时间复杂度为 O(n2)，可能无法通过大规模测试用例（如 n>104*n*>104 时会超时）。
2. **[LeetCode 143. 排序链表](https://leetcode.cn/problems/sort-list/)**
   - **要求**：对链表进行 O(nlog⁡n)时间复杂度和 O(1)空间复杂度的排序。
   - **选择排序的限制**：链表版选择排序的时间复杂度仍为 O(n2)*O*(*n*2)，不满足题目要求，但可作为练习理解链表操作。
3. **[LeetCode 80. 删除排序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)**
   - **要求**：原地删除有序数组中重复项，使每个元素最多出现两次。
   - **关联性**：虽不直接使用选择排序，但涉及原地操作和双指针技巧，与选择排序的空间优化思想相关。

# 插入排序

## 插入排序的原理

插入排序是一种基于逐个元素插入的简单排序算法，其核心思想是将未排序元素依次插入到已排序序列的正确位置中。具体步骤如下：

1. **初始状态**：将数组第一个元素视为已排序序列，剩余元素为未排序序列。
2. **逐步插入**：从未排序序列中取出第一个元素，与已排序序列从后向前比较，找到合适的位置插入。例如，若当前元素为 `arr[i]`，则比较 `arr[i]` 与 `arr[0...i-1]`，找到第一个比 `arr[i]` 小的元素 `arr[j]`，将 `arr[i]` 插入到 `arr[j+1]` 的位置。
3. **重复操作**：直至所有未排序元素均被插入到已排序序列中，完成排序。

**类比场景**：类似于整理扑克牌的过程，每次从牌堆中取一张牌，插入到手中已排序牌的正确位置。

## C++实现

以下为插入排序的C++实现代码，采用原地排序（in-place）方式，仅需常数级额外空间：

```cpp
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {  // 外层循环处理未排序元素
        int key = arr[i];          // 当前待插入元素
        int j = i - 1;
        // 内层循环：将比key大的元素后移，腾出插入位置
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;          // 插入key到正确位置
    }
}
```

**优化点**：

- **提前终止**：若当前元素已大于有序序列末尾元素，无需继续比较。
- **减少交换操作**：先记录待插入元素，再移动数据，最后一次性插入，减少赋值次数。

## 时间复杂度与空间复杂度分析

### 时间复杂度

- **最优情况**：数组已完全有序。此时每次仅需比较一次，总比较次数为 O(n)。
- **最坏情况**：数组完全逆序。每个元素需与所有已排序元素比较，总比较次数为 1+2+⋯+(n−1)=n(n−1)21+2+⋯+(*n*−1)=2*n*(*n*−1)，时间复杂度为 O(n2)。
- **平均情况**：时间复杂度为 O(n2)，适用于随机排列的数组。

### 空间复杂度

- **原地排序**：仅需常数级额外空间存储临时变量（如 `key` 和索引），空间复杂度为 O(1)。

**稳定性**：插入排序是稳定的算法，相同元素的相对位置不会改变。

## LeetCode相关题目

#### 1. [142. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)

- **题意**：对单链表实现插入排序。

- **难点**：链表无法直接向前遍历，需从头开始查找插入位置。

- 示例代码

  ：

  ```cpp
  ListNode* insertionSortList(ListNode* head) {
      if (!head || !head->next) return head;
      ListNode dummy(0);        // 哑节点简化头插入
      ListNode *cur = head;
      while (cur) {
          ListNode *prev = &dummy;
          while (prev->next && prev->next->val <= cur->val) {
              prev = prev->next;
          }
          ListNode *next = cur->next;
          cur->next = prev->next;
          prev->next = cur;
          cur = next;
      }
      return dummy.next;
  }
  ```

#### 2. [913. 排序数组](https://leetcode.cn/problems/sort-an-array/)

- **题意**：对整数数组进行升序排序。
- **适用场景**：数据量较小时（如 n≤1000*n*≤1000），插入排序可接受。
- **优化建议**：结合其他算法（如快速排序）处理大规模数据。

#### 3. [34. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

- **关联点**：插入排序中的“查找插入位置”操作，可借助二分查找优化时间复杂度至 O(log⁡n)*O*(log*n*)。

#### 4. [55. 插入区间](https://leetcode.cn/problems/insert-interval/)

- **扩展应用**：插入操作在处理有序区间时的应用，需合并重叠区间。

------

## 插入排序的优缺点及适用场景

#### 优点

- **简单直观**：代码实现容易理解，适合教学和小规模数据排序。
- **高效场景**：对基本有序的数组或数据量小时性能较好。
- **稳定性**：保持相等元素的原始顺序。

#### 缺点

- **低效性**：大规模乱序数据下时间复杂度为 O(n2)*O*(*n*2)，性能较差。

#### 适用场景

- 数据规模较小（如 n≤1000*n*≤1000）。
- 输入数据基本有序或部分有序。
- 需要稳定排序且空间受限的场景。

------

## 总结

插入排序通过逐步构建有序序列实现排序，核心在于元素的逐个插入与位置调整。其简单性使其在小规模数据场景下具有优势，但时间复杂度较高限制了其在大规模数据中的应用。在LeetCode中，插入排序常用于链表排序或与其他算法结合优化性能。实际应用中，需根据数据规模与特性选择合适的排序算法。

# 希尔排序

## 希尔排序的基本原理

希尔排序的基本原理是通过将待排序的数组分成若干个子序列，每个子序列的元素间隔一定的增量（gap），然后对每个子序列分别进行直接插入排序。随着排序的进行，增量逐渐减小，直到增量为1，此时整个数组被分为一个子序列，再进行一次直接插入排序，最终完成排序。

具体步骤如下：

1. **选择增量序列**：通常选择一个递减的增量序列，如初始增量为数组长度的一半，然后每次减半，直到增量为1。
2. **分组插入排序**：根据当前的增量，将数组分成若干个子序列，每个子序列中的元素间隔为当前增量。对每个子序列分别进行直接插入排序。
3. **逐步缩小增量**：每次排序后，增量减小，重复上述过程，直到增量为1。
4. **最终直接插入排序**：当增量为1时，整个数组被分为一个子序列，再进行一次直接插入排序，完成排序。

希尔排序是一种改进的插入排序算法，通过分组和跳跃式分组逐步使数组有序，从而提高了排序效率。

## **具体示例讲解**

以数组 `{80, 30, 60, 40, 20, 10, 50, 70}` 为例，演示希尔排序过程。此处选择 **希尔增量（gap = n/2逐次折半）** 作为增量序列。

#### **1. 初始状态**

数组长度 `n = 8`，初始增量 `gap = 8/2 = 4`。

**分组方式**：

- 每个子序列由间隔为4的元素组成。例如，索引0、4为一组，索引1、5为一组，依此类推。
- 子序列分组结果：
  - 组1：80, 20
  - 组2：30, 10
  - 组3：60, 50
  - 组4：40, 70

**插入排序过程**：

- **组1**：80和20比较 → 交换 → 结果：20, 80
- **组2**：30和10比较 → 交换 → 结果：10, 30
- **组3**：60和50比较 → 交换 → 结果：50, 60
- **组4**：40和70有序 → 不交换

**第一趟排序后数组**：
`{20, 10, 50, 40, 80, 30, 60, 70}` 

------

#### **2. 缩小增量至 gap = 2**

**分组方式**：

- 间隔为2，分为2个子序列。例如，索引0、2、4、6为一组，索引1、3、5、7为一组。
- 子序列分组结果：
  - 组1：20, 50, 80, 60
  - 组2：10, 40, 30, 70

**插入排序过程**：

- 组1：
  - 20和50有序 → 不交换
  - 80和60比较 → 交换 → 结果：20, 50, 60, 80
- 组2：
  - 10和40有序 → 不交换
  - 30和70有序 → 不交换
  - 40和30比较 → 交换 → 最终结果：10, 30, 40, 70

**第二趟排序后数组**：
`{20, 10, 50, 30, 60, 40, 80, 70}` 

------

#### **3. 缩小增量至 gap = 1**

此时相当于执行普通插入排序。数组已接近有序，只需少量调整。

**插入排序过程**：

- 从第二个元素开始，依次与前序元素比较并插入合适位置。
- 最终数组变为完全有序：
  `{10, 20, 30, 40, 50, 60, 70, 80}`



## 希尔排序的C++实现代码示例

以下是希尔排序的C++实现代码示例：

```cpp
#include <iostream>
#include <vector>

void shellSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int gap = n / 2; gap > 0; gap /= 2) {//控制组数
        for (int i = gap; i < n; i++) {//对每组操作
            int temp = arr[i];
            int j;
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {//每组交换
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
    }
}

int main() {
    std::vector<int> arr = {12, 34, 54, 2, 3};
    shellSort(arr);
    std::cout << "Sorted array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

### 输出结果：

```cpp
Sorted array: 2 3 12 34 54
```

- 外层循环控制增量逐步缩小。
- 中层循环遍历每个子序列的起始位置。
- 内层循环执行插入排序，将元素插入正确位置

该代码首先定义了一个`shellSort`函数，该函数接受一个整数向量作为参数，并通过逐步减小增量`gap`来对数组进行排序。在`main`函数中，创建了一个示例数组并调用`shellSort`函数对其进行排序，最后输出排序后的数组。

## 希尔排序的时间复杂度分析

希尔排序的时间复杂度分析较为复杂，主要取决于所选择的增量序列。根据不同的增量序列，其时间复杂度可能有所不同。

1. ### **增量序列的影响**：

   - 使用原始的希尔增量（如每次将增量减半，从 n/2 开始），时间复杂度在最坏情况下可以达到 O(n^2) 。
   - 使用优化的增量序列（如Hibbard增量或Sedgewick增量），时间复杂度可以显著降低。例如，Hibbard增量的时间复杂度为 O(n3/2)，平均时间复杂度约为 O(n) ；Sedgewick增量的时间复杂度为 O(n4/3)，平均时间复杂度约为 O(n) 。

2. ### **理论分析的困难**：

   - 目前尚无统一的数学证明来确定希尔排序的时间复杂度，特别是对于增量序列的选择 。
   - 大量研究基于实验和观察得出结论，希尔排序的平均时间复杂度通常介于 O(nlog⁡n)和 O(n2)*O*(*n*2) 之间 。

3. ### **具体增量序列的时间复杂度**：

   - 在某些特定增量序列下，时间复杂度可以达到 O(nlog⁡n)。
   - 使用Shell增量序列时，时间复杂度为 O(n1.3)左右 。

4. ### **总结**：

   - 希尔排序的时间复杂度范围较广，从 O(n)到 O(n^2)不等，具体取决于增量序列的选择 。
   - 尽管没有精确的数学证明，但通过实验和观察，希尔排序在某些情况下比插入排序更高效 。

综上，希尔排序的时间复杂度分析依赖于增量序列的选择，具体时间复杂度范围较广，通常在 O(n)到 O(n^2)之间。

## 希尔排序的空间复杂度分析

希尔排序的空间复杂度为O(1)。这是因为希尔排序是一种原地排序算法，不需要额外的内存空间来存储临时数据或辅助数组。它仅使用常数级别的额外空间来存储增量序列和临时变量，因此无论输入数据的规模如何增长，所使用的额外空间保持不变。

## LeetCode中涉及希尔排序的题目列表

LeetCode中涉及希尔排序的题目列表如下：

1. **[LeetCode 912. 排序数组](https://leetcode.cn/problems/sort-an-array/description/)**

   - 题目描述：给定一个整数数组，实现希尔排序算法对数组进行排序。
   - 解题思路：希尔排序是一种改进的插入排序，通过逐步缩小增量来实现排序。具体实现方法包括选择增量序列、分组插入排序等步骤。
   - 难度：中等 

   

2. **[LeetCode 315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)**

   - 题目描述：计算数组中每个元素右侧小于该元素的个数，可以使用希尔排序对数组进行预排序。
   - 解题思路：希尔排序可以用于处理需要多次局部排序的场景，如计算右侧小于当前元素的个数。
   - 难度：困难

   

3. **[LeetCode 451. 根据字符频率排序字符串](https://leetcode.cn/problems/sort-characters-by-frequency/description/)**

   - 题目描述：根据字符频率对字符串进行排序，可以使用希尔排序对字符频率进行排序。
   - 解题思路：希尔排序可以用于处理需要多次局部排序的场景，如根据字符频率排序字符串。
   - 难度：中等 

### LeetCode 912. 排序数组是否明确要求使用希尔排序？

LeetCode 912. 排序数组并没有明确要求使用希尔排序。虽然有部分文章和博客提到了希尔排序的实现和优化，但这些内容主要是为了展示希尔排序的算法思想和性能特点，并未表明该题目必须使用希尔排序来解决。

从证据来看：

1. 多篇文章和博客提到希尔排序的实现和优化，但并未明确指出LeetCode 912题要求使用希尔排序。
2. LeetCode 912题的官方描述和解法中，也没有提到必须使用希尔排序。
3. 其他解法如快速排序、归并排序、堆排序等也被广泛讨论和实现，且这些解法在时间复杂度和空间复杂度上各有优势。

因此，LeetCode 912题并没有明确要求使用希尔排序，考生可以根据题目要求选择合适的排序算法。

### LeetCode 315. 计算右侧小于当前元素的个数是否明确要求使用希尔排序？

LeetCode 315. 计算右侧小于当前元素的个数并没有明确要求使用希尔排序。相反，搜索结果中提到了多种解法，包括插入排序、树状数组、归并排序、线段树和分块算法等。因此，希尔排序并不是解决该问题的必需方法。



# 冒泡&选择&插入&希尔性能比较

## **1. 时间复杂度对比**

| 算法         | 最好情况 | 平均情况       | 最坏情况 |
| ------------ | -------- | -------------- | -------- |
| **冒泡排序** | O(n)     | O(n²)          | O(n²)    |
| **选择排序** | O(n²)    | O(n²)          | O(n²)    |
| **插入排序** | O(n)     | O(n²)          | O(n²)    |
| **希尔排序** | O(n)     | O(n^1.3)~O(n²) | O(n²)    |

**关键说明**：

- **冒泡排序**在数据完全有序时仅需一次遍历即可完成（比较次数为n-1），但在逆序时需完整执行两层循环，导致O(n²)复杂度。
- **选择排序**无论数据是否有序，均需遍历所有未排序元素寻找最小值，因此时间复杂度恒为O(n²)。
- **插入排序**在数据有序时仅需线性时间，但在逆序时需频繁后移元素，复杂度升至O(n²)。
- **希尔排序**的时间复杂度取决于增量序列的选择。使用希尔增量（n/2递减）时最坏为O(n²)，但优化后的增量（如Hibbard序列）可达到O(n^1.5)或更低

## **2. 空间复杂度对比**

| 算法         | 空间复杂度 | 是否原地排序 |
| ------------ | ---------- | ------------ |
| **冒泡排序** | O(1)       | 是           |
| **选择排序** | O(1)       | 是           |
| **插入排序** | O(1)       | 是           |
| **希尔排序** | O(1)       | 是           |

**结论**：四者均为原地排序算法，仅需常数级别额外空间，适合内存敏感场景。

------

## **3. 稳定性分析**

| 算法         | 是否稳定 | 原因说明                   |
| ------------ | -------- | -------------------------- |
| **冒泡排序** | 是       | 相邻元素比较，相等时不交换 |
| **选择排序** | 否       | 跳跃式交换可能破坏顺序     |
| **插入排序** | 是       | 元素逐一插入有序序列       |
| **希尔排序** | 否       | 分组插入导致元素跨越式移动 |

**应用建议**：若需保持相等元素的相对顺序（如按多字段排序），优先选择冒泡或插入排序。

## **4. 实际性能与适用场景**

### **数据规模影响**

- 小规模数据（n ≤ 1000）：四者差异不大，但插入排序通常最优（因常数因子小）。
  - 实验数据：对1000个随机数，冒泡耗时约5ms，插入排序约30ms，希尔排序仅0.05ms。
- **中等规模数据（1000 < n ≤ 10^4）** ：希尔排序优势明显，其他三者为O(n²)，耗时显著增加。
- **大规模数据（n > 10^4）** ：均不适用，需采用O(n log n)算法（如快速排序、归并排序）。

### **数据特性影响**

| 场景             | 推荐算法      | 原因说明                      |
| ---------------- | ------------- | ----------------------------- |
| **数据基本有序** | 插入排序      | 比较次数接近O(n)              |
| **数据完全逆序** | 希尔排序      | 其他三者为O(n²)，希尔效率更高 |
| **交换成本高**   | 选择排序      | 仅需O(n)次交换                |
| **内存严格受限** | 冒泡/插入排序 | 代码简单，实现风险低          |

------

## **5. 综合对比与总结**

| 维度           | 冒泡排序       | 选择排序         | 插入排序         | 希尔排序       |
| -------------- | -------------- | ---------------- | ---------------- | -------------- |
| **时间复杂度** | 平均O(n²)      | 恒O(n²)          | 平均O(n²)        | 平均O(n^1.3)   |
| **空间复杂度** | O(1)           | O(1)             | O(1)             | O(1)           |
| **稳定性**     | 稳定           | 不稳定           | 稳定             | 不稳定         |
| **最佳场景**   | 小规模有序数据 | 小规模低交换需求 | 小规模或局部有序 | 中等规模通用   |
| **最差场景**   | 大规模逆序数据 | 任何大规模数据   | 大规模逆序数据   | 增量序列不佳时 |

# 快速排序

## 一、快速排序的原理

快速排序是一种基于**分治思想**的高效排序算法，由Tony Hoare于1960年提出。其核心原理是通过选择一个基准元素（pivot），将数组划分为两个子数组：**左边所有元素小于等于基准，右边所有元素大于等于基准**，再递归地对子数组进行排序，最终合并得到有序序列。

#### 具体步骤：

1. **选择基准元素**：通常选择第一个元素（如所述）或随机元素（优化方式）。
2. 分区操作（Partitioning）：
   - 定义两个指针（i和j），分别从数组两端向中间扫描。
   - 将小于基准的元素移到左侧，大于基准的元素移到右侧（中提到的双指针法）。
3. **递归排序**：对左右子数组重复上述过程，直到子数组长度为1或0时终止递归。

#### 示例分析（以数列14,11,25,37,9,28为例）：

- 选择首元素14为基准。
- 分区后得到左子数组[11,9]，右子数组[25,37,28]。
- 递归对左右子数组排序，最终合并为有序序列。

**关键特性**：

- **原地排序**：无需额外存储空间。
- **不稳定性**：相同元素可能因交换操作改变相对顺序

## 二、C++代码实现

以下是基于双指针法的快速排序实现，包含随机化基准选择以优化性能：

```cpp
#include <iostream>
#include <vector>
#include <cstdlib>
using namespace std;

// 分区函数：返回基准元素的最终位置
int partition(vector<int>& nums, int left, int right) {
    // 随机选择基准元素（优化最坏情况）
    int pivot_idx = left + rand() % (right - left + 1);
    swap(nums[left], nums[pivot_idx]);
    int pivot = nums[left];
    
    int i = left, j = right;
    while (i < j) {
        while (i < j && nums[j] >= pivot) j--;
        nums[i] = nums[j];
        while (i < j && nums[i] <= pivot) i++;
        nums[j] = nums[i];
    }
    nums[i] = pivot;
    return i;
}

// 递归排序函数
void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    int pos = partition(nums, left, right);
    quickSort(nums, left, pos - 1);
    quickSort(nums, pos + 1, right);
}

int main() {
    vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
    quickSort(nums, 0, nums.size() - 1);
    for (int num : nums) cout << num << " ";
    return 0;
}
```

**代码说明**：

- **随机基准选择**：通过`rand()`减少对已排序数组的最坏时间复杂度。
- **双指针法**：i从左向右扫描，j从右向左扫描，确保原地交换。

## 三、复杂度分析

#### 时间复杂度：

| 情况      | 复杂度     | 说明                                               |
| --------- | ---------- | -------------------------------------------------- |
| 最佳/平均 | O(n log n) | 每次分区将数组均匀划分为两部分                     |
| 最坏      | O(n²)      | 每次分区极不平衡（如数组已排序且选择首元素为基准） |

#### 空间复杂度：

| 情况 | 复杂度   | 原因                                       |
| ---- | -------- | ------------------------------------------ |
| 平均 | O(log n) | 递归栈深度与树的高度相关                   |
| 最坏 | O(n)     | 递归深度退化为线性（如每次仅划分一个元素） |

**优化策略**：

- 随机化基准选择（如上述代码所示）。
- 三数取中法（Median-of-Three）选择基准。
- 尾递归优化减少栈空间。

------

## 四、LeetCode练习题

#### 1. 直接应用快速排序

- 912. [排序数组](https://leetcode.cn/problems/sort-an-array/)

  - 题目要求：对整数数组升序排序。
  - 解法：直接实现快速排序。
  - 注意：需处理大量重复元素时，可结合三向切分（Dijkstra's 3-way Partition）。

#### 2. 快速排序思想扩展

- **[215. 数组中的第K个最大元素](https://leetcode.cn/problems/sort-an-array/)**
  - 题目要求：找到第K大的元素。
  - 解法：快速选择算法（QuickSelect），平均时间复杂度O(n)。
  - 关键代码：仅递归处理包含目标元素的子数组。
- **[148. 排序链表](https://leetcode.cn/problems/sort-list/)**
  - 题目要求：O(n log n)时间、常数空间排序链表。
  - 解法：快速排序变种（以头节点为基准，拆分链表为左右部分递归）。
  - 注意：链表操作需谨慎处理指针，归并排序更稳定。

#### 3. 综合应用

- **[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)**
  - 题目要求：将包含0、1、2的数组原地排序。
  - 解法：三向切分快速排序（荷兰国旗问题）。
  - 关键代码：双指针划分0、1、2的区域。
- **[179. 最大数](https://leetcode.cn/problems/sort-list/)**
  - 题目要求：将非负整数数组拼接成最大数。
  - 解法：自定义排序规则（结合快速排序的Comparator）。

# 归并排序

## 一、归并排序的原理

归并排序（Merge Sort）是一种基于**分治思想**的高效排序算法，其核心流程分为**分割**和**合并**两个阶段，通过递归实现稳定排序。

1. ### **分治思想**：

   - **分割**：将数组递归地分成两个长度近似相等的子数组，直到每个子数组仅包含一个元素（此时视为有序）。
   - **合并**：将两个有序子数组合并为一个有序数组。合并时，通过双指针从左到右遍历，选择较小元素依次放入临时数组，最后将剩余元素追加到结果中。

2. **稳定性保证**：

   - 在合并过程中，若两个子数组的首元素相等，优先选择前段元素，从而保持原始顺序的稳定性。

3. ### **关键步骤**：

   ```plaintext
   1. 分割数组：mid = (left + right) / 2
   2. 递归排序左子数组和右子数组
   3. 合并两个有序子数组
   ```

## 二、C++代码实现

以下是归并排序的典型C++实现，包含递归分割与合并操作：

```cpp
#include <vector>
using namespace std;

void merge(vector<int>& nums, int left, int mid, int right) {
    vector<int> tmp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    
    // 合并两个有序子数组
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j]) tmp[k++] = nums[i++]; // 保证稳定性
        else tmp[k++] = nums[j++];
    }
    
    // 处理剩余元素
    while (i <= mid) tmp[k++] = nums[i++];
    while (j <= right) tmp[k++] = nums[j++];
    
    // 将临时数组复制回原数组
    for (int p = 0; p < tmp.size(); p++) {
        nums[left + p] = tmp[p];
    }
}

void mergeSort(vector<int>& nums, int left, int right) {
    if (left >= right) return; // 递归终止条件：子数组长度为1
    int mid = left + (right - left) / 2;
    mergeSort(nums, left, mid);      // 递归排序左半部分
    mergeSort(nums, mid + 1, right); // 递归排序右半部分
    merge(nums, left, mid, right);   // 合并操作
}

// 示例用法：
vector<int> arr = {7, 8, 6, 4, 5, 4, 3};
mergeSort(arr, 0, arr.size() - 1);
```

**代码解析**：

- **merge函数**：负责合并两个有序子数组，使用双指针遍历并比较元素。
- **mergeSort函数**：递归分割数组，直至子数组长度为1，再合并排序后的子数组。
- **稳定性**：通过`nums[i] <= nums[j]`的判断保持相等元素的顺序。

#### 1. 临时数组的创建

```cpp
vector<int> tmp(right - left + 1);
```

- **作用**：创建一个大小为 `right-left+1` 的临时数组，用于存储合并后的有序结果。此大小正好覆盖原数组中从 `left` 到 `right` 的区间。
- **必要性**：避免直接在原数组上操作导致数据覆盖问题。

#### 2. 合并两个有序子数组

```cpp
while (i <= mid && j <= right) {
    if (nums[i] <= nums[j]) tmp[k++] = nums[i++]; // 保证稳定性
    else tmp[k++] = nums[j++];
}
```

- **指针逻辑**：`i` 和 `j` 分别指向左子数组（`[left, mid]`）和右子数组（`[mid+1, right]`）的当前元素，`k` 为临时数组索引。
- **稳定性实现**：比较时使用 `<=` 而非 `<`，确保当元素相等时优先保留左子数组元素的原始顺序，这是稳定排序的关键。

#### 3. 处理剩余元素

```cpp
while (i <= mid) tmp[k++] = nums[i++];
while (j <= right) tmp[k++] = nums[j++];
```

- **必要性**：当某一子数组遍历完成后，另一子数组可能仍有剩余元素需直接复制到临时数组。例如，左子数组未遍历完时，剩余元素已有序，可直接追加到 `tmp` 末尾。

#### 4. 数据回写原数组

```cpp
for (int p = 0; p < tmp.size(); p++) {
    nums[left + p] = tmp[p];
}
```

- **意义**：将合并后的有序数据从临时数组复制回原数组的 `[left, right]` 区间，完成该区间的排序。

------

## 三、时间复杂度与空间复杂度

1. **时间复杂度**：
   - **最优/最坏/平均情况**均为 **O(n log n)**。分割过程形成递归树，深度为 log n，每层合并操作的总时间复杂度为 O(n)。
   - 公式推导：T(n) = 2T(n/2) + O(n)，通过主定理可得 O(n log n)。
2. **空间复杂度**：
   - 主要来自临时数组，为 **O(n)**。递归调用栈的空间复杂度为 O(log n)，但通常以临时数组为主。

------

## 四、LeetCode练习题

以下是涉及归并排序的典型LeetCode题目及解题思路：

### 142.排序链表（Sort List）

**题目要求**：对链表进行 O(n log n) 时间复杂度的排序，且空间复杂度为 O(1)。

**归并排序应用**：

- 分割链表：快慢指针找到中点，断开链表为前后两部分。

- 递归排序左右子链表。

- 合并两个有序链表（类似合并两个有序数组）

  **代码关键点**：快慢指针分割链表、合并操作避免额外空间。

### **23. 合并K个升序链表**（Merge k Sorted Lists）

**题目要求**：合并K个有序链表为一个有序链表。

**归并排序应用**：分治策略两两合并链表，时间复杂度 O(kn log k)，优于逐次合并的 O(k²n)。

**优化点**：递归分治或使用优先队列（最小堆）。

### **314. 计算右侧小于当前元素的个数**（Count of Smaller Numbers After Self）

**题目要求**：统计数组中每个元素右侧比它小的元素数量。

**归并排序应用**：在合并过程中统计逆序对数量，利用排序后的有序性优化计算。

### **剑指 Offer 25. 合并两个排序的链表**

**题目要求**：合并两个递增链表为一个递增链表。

**归并排序应用**：双指针遍历链表，按顺序拼接节点。

------

## 五、归并排序的优缺点

| **优点**                     | **缺点**                     |
| ---------------------------- | ---------------------------- |
| 时间复杂度稳定为 O(n log n)  | 空间复杂度 O(n)，非原地排序  |
| 稳定排序，保持相等元素顺序   | 递归实现可能导致栈溢出风险   |
| 适合链表排序（空间复杂度低） | 对小规模数据效率不如插入排序 |

------

## 六、扩展思考

1. **非递归实现**：通过迭代自底向上合并子数组，避免递归栈空间。
2. **并行优化**：分治策略天然适合多线程，可并行处理子数组排序。
3. **外部排序应用**：处理超大规模数据时，归并排序常用于磁盘文件的多路归并。

# 堆排序

## 二叉堆、大根堆、小跟堆

## 堆的上浮和下沉调整

## 基于堆的优先级队列代码实现



# 快排&归并&希尔&堆排序性能比较

# 基数排序（桶排序）