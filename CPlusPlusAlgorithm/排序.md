# 冒泡排序

## **冒泡排序的基本原理**

冒泡排序的基本原理是通过多次遍历待排序的数组，比较相邻的两个元素并交换它们的位置，使得较大的元素逐渐“冒泡”到数组的末尾，从而实现排序。具体步骤如下：

1. **比较相邻元素**：从数组的第一个元素开始，依次比较相邻的两个元素，如果前一个元素大于后一个元素，则交换它们的位置。
2. **重复遍历**：每一轮遍历结束后，最大的元素会被移动到数组的末尾。因此，下一轮遍历可以忽略最后一个元素，继续比较剩余的元素。
3. **终止条件**：当某一轮遍历中没有发生任何交换时，说明数组已经有序，排序完成。

冒泡排序的特点是简单直观，但效率较低，时间复杂度为O(n^2)，适用于小规模数据的排序

## 冒泡排序的C++实现代码示例

以下是冒泡排序的C++实现代码示例：

```cpp
#include <iostream>
using namespace std;

// 交换元素
void swap(int *num1, int *num2) {
    int temp = *num1;
    *num1 = *num2;
    *num2 = temp;
}

// 冒泡排序实现
void bubbleSort(int arr[], int len) {
    for (int i = 0; i < len - 1; i++) {
        bool sorted = true;
        for (int j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(&arr[j], &arr[j + 1]);
                sorted = false;
            }
        }
        if (sorted) break; // 如果没有发生交换,则表示已排好序,跳出
    }
}

// 测试
int main(void) {
    int girl[] = {21, 32, 17, 33, 20, 34, 28, 27, 33};
    int len = sizeof(girl) / sizeof(girl[0]); // 获取元素个数
    bubbleSort(girl, len);
    for (int i = 0; i < len; i++) {
        cout << girl[i] << "\t";
    }
    cout << endl;

    system("pause");
    return 0;
}
```

这段代码定义了一个`bubbleSort`函数来实现冒泡排序，并在`main`函数中进行了测试。通过两层循环，外层循环控制趟数，内层循环进行冒泡排序。当内层循环结束时，输出排序后的结果

## **冒泡排序的时间复杂度分析**

冒泡排序的时间复杂度分析如下：

1. **最好情况**：当输入数组已经是有序的时，冒泡排序只需要进行一次遍历来确认数组是否已经排序。此时的时间复杂度为 O(n)。
2. **最坏情况**：当输入数组是逆序的时，冒泡排序需要进行 n−1 轮比较和交换操作，每一轮都需要遍历整个数组。因此，最坏情况下的时间复杂度为 O(n2) 。
3. **平均情况**：在平均情况下，冒泡排序的时间复杂度同样为 O(n2)，因为每次比较和交换的次数与数组长度的平方成正比 。
4. **优化情况**：通过引入标志位（flag）来检测在某一轮遍历中是否发生了交换，如果某一轮没有发生交换，则说明数组已经有序，可以提前结束排序。这种优化可以将最好情况的时间复杂度降低到 O(n)，但最坏和平均情况的时间复杂度仍为 O(n2)。

总结：冒泡排序的时间复杂度在最好情况下为 O(n)，在最坏和平均情况下为 O(n2)。



冒泡排序的空间复杂度分析

冒泡排序的空间复杂度为 O(1)。这是因为冒泡排序是一种原地排序算法，除了输入数组外，仅需要常数级别的额外空间来存储临时变量和循环计数器等辅助变量。

## LeetCode中涉及冒泡排序的题目列表及链接

1. **LeetCode 912 - 排序数组**
   - 题目描述：将整数数组升序排列。
   - 解题思路：虽然冒泡排序可以解决此问题，但其时间复杂度为 O(n2)，通常不推荐使用冒泡排序，因为更高效的算法（如快速排序）可以达到 O(nlog⁡n)的时间复杂度。
   - 链接：[LeetCode 912 - 排序数组](https://leetcode.com/problems/sort-an-array/) 
2. **LeetCode 3011 - 判断一个数组是否可以变为有序**
   - 题目描述：通过交换操作实现排序，本质上是冒泡排序的做法。
   - 解题思路：模拟冒泡排序过程，判断是否可以通过交换相邻元素的二进制位数来实现排序。
   - 链接：[LeetCode 3011 - 判断一个数组是否可以变为有序](https://leetcode.cn/problems/find-if-array-can-be-sorted/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china) 
3. **LeetCode 148 - 排序链表**
   - 题目描述：对链表进行排序。
   - 解题思路：虽然冒泡排序可以用于链表排序，但效率较低，通常推荐使用更高效的算法（如归并排序）。
   - 链接：[LeetCode 148 - 排序链表](https://leetcode.cn/problems/sort-list/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china) 
4. **LeetCode 707 - 设计链表**
   - 题目描述：设计一个链表类，并实现插入、删除等操作。
   - 解题思路：虽然题目本身与冒泡排序无直接关系，但可以通过链表排序算法（如冒泡排序）来实现链表的排序功能。
   - 链接：[LeetCode 707 - 设计链表](https://leetcode.cn/problems/design-linked-list/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)
5. **LeetCode 347 - 前 K 个高频元素**
   - 题目描述：找出数组中出现频率最高的前 K 个元素。
   - 解题思路：通过排序后选择前 K 个高频元素，冒泡排序可以用于初步排序，但效率较低。
   - 链接：[LeetCode 347 - 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china) 

# 选择排序

## 选择排序的原理

选择排序（Selection Sort）是一种简单直观的排序算法。其核心思想是：**通过不断选择未排序序列中的最小（或最大）元素，将其与未排序序列的起始位置元素交换，逐步构建有序序列**。具体步骤如下：

1. **初始化**：将整个数组分为两部分，左侧为已排序序列（初始为空），右侧为未排序序列（初始为整个数组）。
2. **查找最小值**：遍历未排序序列，找到最小元素的索引。
3. **交换元素**：将找到的最小元素与未排序序列的起始位置元素交换。
4. **边界右移**：将已排序序列的右边界向右移动一位，扩大已排序序列范围。
5. **重复操作**：重复上述步骤，直到未排序序列仅剩一个元素。

**示例**：以数组 `{38, 65, 97, 76, 13, 27, 49}` 为例，每一趟排序结果如下：

- 第一趟：`13` 被选出并交换到首位 → `13, 65, 97, 76, 38, 27, 49`
- 第二趟：`27` 被选出 → `13, 27, 97, 76, 38, 65, 49`
- 后续依次类推，最终得到有序数组。

## 选择排序的C++实现

以下为选择排序的标准C++实现代码：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        swap(arr[i], arr[minIndex]);
    }
}

int main() {
    int a[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    int n = sizeof(a) / sizeof(a[0]);
    selectionSort(a, n);
    for (int i = 0; i < n; i++) {
        cout << a[i] << " ";
    }
    return 0;
}
```

**代码解析**：

- 外层循环控制已排序序列的边界（`i`从0到`n-1`）。
- 内层循环遍历未排序序列，找到最小元素的索引`minIndex`。
- 每次外层循环结束时，交换`arr[i]`与`arr[minIndex]`，将最小元素归位。

## 时间复杂度与空间复杂度分析

### 时间复杂度

选择排序的时间复杂度在所有情况下均为 **O(n²)** ，具体分析如下：

- **比较次数**：总比较次数为 (n−1)+(n−2)+⋯+1=n(n−1)2(*n*−1)+(*n*−2)+⋯+1=2*n*(*n*−1)，即近似于 O(n2)。
- **交换次数**：每次外层循环仅需一次交换，共 n−1次，即 O(n)。
- **稳定性**：无论输入是否有序，算法均需执行相同次数的比较，因此最佳、平均、最坏情况下时间复杂度一致。

### 空间复杂度

选择排序的 **空间复杂度为 O(1)** ，因为仅需常数级别的额外空间（如`minIndex`和交换时的临时变量）。

------

### 选择排序的优缺点

| **优点**               | **缺点**                             |
| ---------------------- | ------------------------------------ |
| 实现简单，逻辑清晰。   | 时间复杂度高，不适合大规模数据。     |
| 原地排序，空间效率高。 | 不稳定排序（可能改变相同元素顺序）。 |
| 交换次数少（O(n)）。   | 无法利用输入序列的已有有序性。       |

## LeetCode相关题目

虽然选择排序在实际应用中较少直接使用（因效率低），但以下题目可帮助理解其思想或作为练习：

1. **[LeetCode 912. 排序数组](https://leetcode.cn/problems/sort-an-array/)**
   - **要求**：对整数数组升序排序。
   - **选择排序实现**：直接应用上述代码，但由于时间复杂度为 O(n2)，可能无法通过大规模测试用例（如 n>104*n*>104 时会超时）。
2. **[LeetCode 143. 排序链表](https://leetcode.cn/problems/sort-list/)**
   - **要求**：对链表进行 O(nlog⁡n)时间复杂度和 O(1)空间复杂度的排序。
   - **选择排序的限制**：链表版选择排序的时间复杂度仍为 O(n2)*O*(*n*2)，不满足题目要求，但可作为练习理解链表操作。
3. **[LeetCode 80. 删除排序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)**
   - **要求**：原地删除有序数组中重复项，使每个元素最多出现两次。
   - **关联性**：虽不直接使用选择排序，但涉及原地操作和双指针技巧，与选择排序的空间优化思想相关。

# 插入排序

## 插入排序的原理

插入排序是一种基于逐个元素插入的简单排序算法，其核心思想是将未排序元素依次插入到已排序序列的正确位置中。具体步骤如下：

1. **初始状态**：将数组第一个元素视为已排序序列，剩余元素为未排序序列。
2. **逐步插入**：从未排序序列中取出第一个元素，与已排序序列从后向前比较，找到合适的位置插入。例如，若当前元素为 `arr[i]`，则比较 `arr[i]` 与 `arr[0...i-1]`，找到第一个比 `arr[i]` 小的元素 `arr[j]`，将 `arr[i]` 插入到 `arr[j+1]` 的位置。
3. **重复操作**：直至所有未排序元素均被插入到已排序序列中，完成排序。

**类比场景**：类似于整理扑克牌的过程，每次从牌堆中取一张牌，插入到手中已排序牌的正确位置。

## C++实现

以下为插入排序的C++实现代码，采用原地排序（in-place）方式，仅需常数级额外空间：

```cpp
void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {  // 外层循环处理未排序元素
        int key = arr[i];          // 当前待插入元素
        int j = i - 1;
        // 内层循环：将比key大的元素后移，腾出插入位置
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;          // 插入key到正确位置
    }
}
```

**优化点**：

- **提前终止**：若当前元素已大于有序序列末尾元素，无需继续比较。
- **减少交换操作**：先记录待插入元素，再移动数据，最后一次性插入，减少赋值次数。

## 时间复杂度与空间复杂度分析

### 时间复杂度

- **最优情况**：数组已完全有序。此时每次仅需比较一次，总比较次数为 O(n)。
- **最坏情况**：数组完全逆序。每个元素需与所有已排序元素比较，总比较次数为 1+2+⋯+(n−1)=n(n−1)21+2+⋯+(*n*−1)=2*n*(*n*−1)，时间复杂度为 O(n2)。
- **平均情况**：时间复杂度为 O(n2)，适用于随机排列的数组。

### 空间复杂度

- **原地排序**：仅需常数级额外空间存储临时变量（如 `key` 和索引），空间复杂度为 O(1)。

**稳定性**：插入排序是稳定的算法，相同元素的相对位置不会改变。

## LeetCode相关题目

#### 1. [142. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)

- **题意**：对单链表实现插入排序。

- **难点**：链表无法直接向前遍历，需从头开始查找插入位置。

- 示例代码

  ：

  ```cpp
  ListNode* insertionSortList(ListNode* head) {
      if (!head || !head->next) return head;
      ListNode dummy(0);        // 哑节点简化头插入
      ListNode *cur = head;
      while (cur) {
          ListNode *prev = &dummy;
          while (prev->next && prev->next->val <= cur->val) {
              prev = prev->next;
          }
          ListNode *next = cur->next;
          cur->next = prev->next;
          prev->next = cur;
          cur = next;
      }
      return dummy.next;
  }
  ```

#### 2. [913. 排序数组](https://leetcode.cn/problems/sort-an-array/)

- **题意**：对整数数组进行升序排序。
- **适用场景**：数据量较小时（如 n≤1000*n*≤1000），插入排序可接受。
- **优化建议**：结合其他算法（如快速排序）处理大规模数据。

#### 3. [34. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

- **关联点**：插入排序中的“查找插入位置”操作，可借助二分查找优化时间复杂度至 O(log⁡n)*O*(log*n*)。

#### 4. [55. 插入区间](https://leetcode.cn/problems/insert-interval/)

- **扩展应用**：插入操作在处理有序区间时的应用，需合并重叠区间。

------

## 插入排序的优缺点及适用场景

#### 优点

- **简单直观**：代码实现容易理解，适合教学和小规模数据排序。
- **高效场景**：对基本有序的数组或数据量小时性能较好。
- **稳定性**：保持相等元素的原始顺序。

#### 缺点

- **低效性**：大规模乱序数据下时间复杂度为 O(n2)*O*(*n*2)，性能较差。

#### 适用场景

- 数据规模较小（如 n≤1000*n*≤1000）。
- 输入数据基本有序或部分有序。
- 需要稳定排序且空间受限的场景。

------

## 总结

插入排序通过逐步构建有序序列实现排序，核心在于元素的逐个插入与位置调整。其简单性使其在小规模数据场景下具有优势，但时间复杂度较高限制了其在大规模数据中的应用。在LeetCode中，插入排序常用于链表排序或与其他算法结合优化性能。实际应用中，需根据数据规模与特性选择合适的排序算法。

# 希尔排序

## 希尔排序的基本原理

希尔排序的基本原理是通过将待排序的数组分成若干个子序列，每个子序列的元素间隔一定的增量（gap），然后对每个子序列分别进行直接插入排序。随着排序的进行，增量逐渐减小，直到增量为1，此时整个数组被分为一个子序列，再进行一次直接插入排序，最终完成排序。

具体步骤如下：

1. **选择增量序列**：通常选择一个递减的增量序列，如初始增量为数组长度的一半，然后每次减半，直到增量为1。
2. **分组插入排序**：根据当前的增量，将数组分成若干个子序列，每个子序列中的元素间隔为当前增量。对每个子序列分别进行直接插入排序。
3. **逐步缩小增量**：每次排序后，增量减小，重复上述过程，直到增量为1。
4. **最终直接插入排序**：当增量为1时，整个数组被分为一个子序列，再进行一次直接插入排序，完成排序。

希尔排序是一种改进的插入排序算法，通过分组和跳跃式分组逐步使数组有序，从而提高了排序效率。

## **具体示例讲解**

以数组 `{80, 30, 60, 40, 20, 10, 50, 70}` 为例，演示希尔排序过程。此处选择 **希尔增量（gap = n/2逐次折半）** 作为增量序列。

#### **1. 初始状态**

数组长度 `n = 8`，初始增量 `gap = 8/2 = 4`。

**分组方式**：

- 每个子序列由间隔为4的元素组成。例如，索引0、4为一组，索引1、5为一组，依此类推。
- 子序列分组结果：
  - 组1：80, 20
  - 组2：30, 10
  - 组3：60, 50
  - 组4：40, 70

**插入排序过程**：

- **组1**：80和20比较 → 交换 → 结果：20, 80
- **组2**：30和10比较 → 交换 → 结果：10, 30
- **组3**：60和50比较 → 交换 → 结果：50, 60
- **组4**：40和70有序 → 不交换

**第一趟排序后数组**：
`{20, 10, 50, 40, 80, 30, 60, 70}` 

------

#### **2. 缩小增量至 gap = 2**

**分组方式**：

- 间隔为2，分为2个子序列。例如，索引0、2、4、6为一组，索引1、3、5、7为一组。
- 子序列分组结果：
  - 组1：20, 50, 80, 60
  - 组2：10, 40, 30, 70

**插入排序过程**：

- 组1：
  - 20和50有序 → 不交换
  - 80和60比较 → 交换 → 结果：20, 50, 60, 80
- 组2：
  - 10和40有序 → 不交换
  - 30和70有序 → 不交换
  - 40和30比较 → 交换 → 最终结果：10, 30, 40, 70

**第二趟排序后数组**：
`{20, 10, 50, 30, 60, 40, 80, 70}` 

------

#### **3. 缩小增量至 gap = 1**

此时相当于执行普通插入排序。数组已接近有序，只需少量调整。

**插入排序过程**：

- 从第二个元素开始，依次与前序元素比较并插入合适位置。
- 最终数组变为完全有序：
  `{10, 20, 30, 40, 50, 60, 70, 80}`



## 希尔排序的C++实现代码示例

以下是希尔排序的C++实现代码示例：

```cpp
#include <iostream>
#include <vector>

void shellSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int gap = n / 2; gap > 0; gap /= 2) {//控制组数
        for (int i = gap; i < n; i++) {//对每组操作
            int temp = arr[i];
            int j;
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {//每组交换
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
    }
}

int main() {
    std::vector<int> arr = {12, 34, 54, 2, 3};
    shellSort(arr);
    std::cout << "Sorted array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

### 输出结果：

```cpp
Sorted array: 2 3 12 34 54
```

- 外层循环控制增量逐步缩小。
- 中层循环遍历每个子序列的起始位置。
- 内层循环执行插入排序，将元素插入正确位置

该代码首先定义了一个`shellSort`函数，该函数接受一个整数向量作为参数，并通过逐步减小增量`gap`来对数组进行排序。在`main`函数中，创建了一个示例数组并调用`shellSort`函数对其进行排序，最后输出排序后的数组。

## 希尔排序的时间复杂度分析

希尔排序的时间复杂度分析较为复杂，主要取决于所选择的增量序列。根据不同的增量序列，其时间复杂度可能有所不同。

1. ### **增量序列的影响**：

   - 使用原始的希尔增量（如每次将增量减半，从 n/2 开始），时间复杂度在最坏情况下可以达到 O(n^2) 。
   - 使用优化的增量序列（如Hibbard增量或Sedgewick增量），时间复杂度可以显著降低。例如，Hibbard增量的时间复杂度为 O(n3/2)，平均时间复杂度约为 O(n) ；Sedgewick增量的时间复杂度为 O(n4/3)，平均时间复杂度约为 O(n) 。

2. ### **理论分析的困难**：

   - 目前尚无统一的数学证明来确定希尔排序的时间复杂度，特别是对于增量序列的选择 。
   - 大量研究基于实验和观察得出结论，希尔排序的平均时间复杂度通常介于 O(nlog⁡n)和 O(n2)*O*(*n*2) 之间 。

3. ### **具体增量序列的时间复杂度**：

   - 在某些特定增量序列下，时间复杂度可以达到 O(nlog⁡n)。
   - 使用Shell增量序列时，时间复杂度为 O(n1.3)左右 。

4. ### **总结**：

   - 希尔排序的时间复杂度范围较广，从 O(n)到 O(n^2)不等，具体取决于增量序列的选择 。
   - 尽管没有精确的数学证明，但通过实验和观察，希尔排序在某些情况下比插入排序更高效 。

综上，希尔排序的时间复杂度分析依赖于增量序列的选择，具体时间复杂度范围较广，通常在 O(n)到 O(n^2)之间。

## 希尔排序的空间复杂度分析

希尔排序的空间复杂度为O(1)。这是因为希尔排序是一种原地排序算法，不需要额外的内存空间来存储临时数据或辅助数组。它仅使用常数级别的额外空间来存储增量序列和临时变量，因此无论输入数据的规模如何增长，所使用的额外空间保持不变。

## LeetCode中涉及希尔排序的题目列表

LeetCode中涉及希尔排序的题目列表如下：

1. **[LeetCode 912. 排序数组](https://leetcode.cn/problems/sort-an-array/description/)**

   - 题目描述：给定一个整数数组，实现希尔排序算法对数组进行排序。
   - 解题思路：希尔排序是一种改进的插入排序，通过逐步缩小增量来实现排序。具体实现方法包括选择增量序列、分组插入排序等步骤。
   - 难度：中等 

   

2. **[LeetCode 315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)**

   - 题目描述：计算数组中每个元素右侧小于该元素的个数，可以使用希尔排序对数组进行预排序。
   - 解题思路：希尔排序可以用于处理需要多次局部排序的场景，如计算右侧小于当前元素的个数。
   - 难度：困难

   

3. **[LeetCode 451. 根据字符频率排序字符串](https://leetcode.cn/problems/sort-characters-by-frequency/description/)**

   - 题目描述：根据字符频率对字符串进行排序，可以使用希尔排序对字符频率进行排序。
   - 解题思路：希尔排序可以用于处理需要多次局部排序的场景，如根据字符频率排序字符串。
   - 难度：中等 

### LeetCode 912. 排序数组是否明确要求使用希尔排序？

LeetCode 912. 排序数组并没有明确要求使用希尔排序。虽然有部分文章和博客提到了希尔排序的实现和优化，但这些内容主要是为了展示希尔排序的算法思想和性能特点，并未表明该题目必须使用希尔排序来解决。

从证据来看：

1. 多篇文章和博客提到希尔排序的实现和优化，但并未明确指出LeetCode 912题要求使用希尔排序。
2. LeetCode 912题的官方描述和解法中，也没有提到必须使用希尔排序。
3. 其他解法如快速排序、归并排序、堆排序等也被广泛讨论和实现，且这些解法在时间复杂度和空间复杂度上各有优势。

因此，LeetCode 912题并没有明确要求使用希尔排序，考生可以根据题目要求选择合适的排序算法。

### LeetCode 315. 计算右侧小于当前元素的个数是否明确要求使用希尔排序？

LeetCode 315. 计算右侧小于当前元素的个数并没有明确要求使用希尔排序。相反，搜索结果中提到了多种解法，包括插入排序、树状数组、归并排序、线段树和分块算法等。因此，希尔排序并不是解决该问题的必需方法。



# 冒泡&选择&插入&希尔性能比较

## **1. 时间复杂度对比**

| 算法         | 最好情况 | 平均情况       | 最坏情况 |
| ------------ | -------- | -------------- | -------- |
| **冒泡排序** | O(n)     | O(n²)          | O(n²)    |
| **选择排序** | O(n²)    | O(n²)          | O(n²)    |
| **插入排序** | O(n)     | O(n²)          | O(n²)    |
| **希尔排序** | O(n)     | O(n^1.3)~O(n²) | O(n²)    |

**关键说明**：

- **冒泡排序**在数据完全有序时仅需一次遍历即可完成（比较次数为n-1），但在逆序时需完整执行两层循环，导致O(n²)复杂度。
- **选择排序**无论数据是否有序，均需遍历所有未排序元素寻找最小值，因此时间复杂度恒为O(n²)。
- **插入排序**在数据有序时仅需线性时间，但在逆序时需频繁后移元素，复杂度升至O(n²)。
- **希尔排序**的时间复杂度取决于增量序列的选择。使用希尔增量（n/2递减）时最坏为O(n²)，但优化后的增量（如Hibbard序列）可达到O(n^1.5)或更低

## **2. 空间复杂度对比**

| 算法         | 空间复杂度 | 是否原地排序 |
| ------------ | ---------- | ------------ |
| **冒泡排序** | O(1)       | 是           |
| **选择排序** | O(1)       | 是           |
| **插入排序** | O(1)       | 是           |
| **希尔排序** | O(1)       | 是           |

**结论**：四者均为原地排序算法，仅需常数级别额外空间，适合内存敏感场景。

------

## **3. 稳定性分析**

| 算法         | 是否稳定 | 原因说明                   |
| ------------ | -------- | -------------------------- |
| **冒泡排序** | 是       | 相邻元素比较，相等时不交换 |
| **选择排序** | 否       | 跳跃式交换可能破坏顺序     |
| **插入排序** | 是       | 元素逐一插入有序序列       |
| **希尔排序** | 否       | 分组插入导致元素跨越式移动 |

**应用建议**：若需保持相等元素的相对顺序（如按多字段排序），优先选择冒泡或插入排序。

## **4. 实际性能与适用场景**

### **数据规模影响**

- 小规模数据（n ≤ 1000）：四者差异不大，但插入排序通常最优（因常数因子小）。
  - 实验数据：对1000个随机数，冒泡耗时约5ms，插入排序约30ms，希尔排序仅0.05ms。
- **中等规模数据（1000 < n ≤ 10^4）** ：希尔排序优势明显，其他三者为O(n²)，耗时显著增加。
- **大规模数据（n > 10^4）** ：均不适用，需采用O(n log n)算法（如快速排序、归并排序）。

### **数据特性影响**

| 场景             | 推荐算法      | 原因说明                      |
| ---------------- | ------------- | ----------------------------- |
| **数据基本有序** | 插入排序      | 比较次数接近O(n)              |
| **数据完全逆序** | 希尔排序      | 其他三者为O(n²)，希尔效率更高 |
| **交换成本高**   | 选择排序      | 仅需O(n)次交换                |
| **内存严格受限** | 冒泡/插入排序 | 代码简单，实现风险低          |

------

## **5. 综合对比与总结**

| 维度           | 冒泡排序       | 选择排序         | 插入排序         | 希尔排序       |
| -------------- | -------------- | ---------------- | ---------------- | -------------- |
| **时间复杂度** | 平均O(n²)      | 恒O(n²)          | 平均O(n²)        | 平均O(n^1.3)   |
| **空间复杂度** | O(1)           | O(1)             | O(1)             | O(1)           |
| **稳定性**     | 稳定           | 不稳定           | 稳定             | 不稳定         |
| **最佳场景**   | 小规模有序数据 | 小规模低交换需求 | 小规模或局部有序 | 中等规模通用   |
| **最差场景**   | 大规模逆序数据 | 任何大规模数据   | 大规模逆序数据   | 增量序列不佳时 |

# 快速排序

## 一、快速排序的原理

快速排序是一种基于**分治思想**的高效排序算法，由Tony Hoare于1960年提出。其核心原理是通过选择一个基准元素（pivot），将数组划分为两个子数组：**左边所有元素小于等于基准，右边所有元素大于等于基准**，再递归地对子数组进行排序，最终合并得到有序序列。

#### 具体步骤：

1. **选择基准元素**：通常选择第一个元素（如所述）或随机元素（优化方式）。
2. 分区操作（Partitioning）：
   - 定义两个指针（i和j），分别从数组两端向中间扫描。
   - 将小于基准的元素移到左侧，大于基准的元素移到右侧（中提到的双指针法）。
3. **递归排序**：对左右子数组重复上述过程，直到子数组长度为1或0时终止递归。

#### 示例分析（以数列14,11,25,37,9,28为例）：

- 选择首元素14为基准。
- 分区后得到左子数组[11,9]，右子数组[25,37,28]。
- 递归对左右子数组排序，最终合并为有序序列。

**关键特性**：

- **原地排序**：无需额外存储空间。
- **不稳定性**：相同元素可能因交换操作改变相对顺序

## 二、C++代码实现

以下是基于双指针法的快速排序实现，包含随机化基准选择以优化性能：

```cpp
#include <iostream>
#include <vector>
#include <cstdlib>
using namespace std;

// 分区函数：返回基准元素的最终位置
int partition(vector<int>& nums, int left, int right) {
    // 随机选择基准元素（优化最坏情况）
    int pivot_idx = left + rand() % (right - left + 1);
    swap(nums[left], nums[pivot_idx]);
    int pivot = nums[left];
    
    int i = left, j = right;
    while (i < j) {
        while (i < j && nums[j] >= pivot) j--;
        nums[i] = nums[j];
        while (i < j && nums[i] <= pivot) i++;
        nums[j] = nums[i];
    }
    nums[i] = pivot;
    return i;
}

// 递归排序函数
void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    int pos = partition(nums, left, right);
    quickSort(nums, left, pos - 1);
    quickSort(nums, pos + 1, right);
}

int main() {
    vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
    quickSort(nums, 0, nums.size() - 1);
    for (int num : nums) cout << num << " ";
    return 0;
}
```

**代码说明**：

- **随机基准选择**：通过`rand()`减少对已排序数组的最坏时间复杂度。
- **双指针法**：i从左向右扫描，j从右向左扫描，确保原地交换。

## 三、复杂度分析

#### 时间复杂度：

| 情况      | 复杂度     | 说明                                               |
| --------- | ---------- | -------------------------------------------------- |
| 最佳/平均 | O(n log n) | 每次分区将数组均匀划分为两部分                     |
| 最坏      | O(n²)      | 每次分区极不平衡（如数组已排序且选择首元素为基准） |

#### 空间复杂度：

| 情况 | 复杂度   | 原因                                       |
| ---- | -------- | ------------------------------------------ |
| 平均 | O(log n) | 递归栈深度与树的高度相关                   |
| 最坏 | O(n)     | 递归深度退化为线性（如每次仅划分一个元素） |

**优化策略**：

- 随机化基准选择（如上述代码所示）。
- 三数取中法（Median-of-Three）选择基准。
- 尾递归优化减少栈空间。

------

## 四、LeetCode练习题

#### 1. 直接应用快速排序

- 912. [排序数组](https://leetcode.cn/problems/sort-an-array/)

  - 题目要求：对整数数组升序排序。
  - 解法：直接实现快速排序。
  - 注意：需处理大量重复元素时，可结合三向切分（Dijkstra's 3-way Partition）。

#### 2. 快速排序思想扩展

- **[215. 数组中的第K个最大元素](https://leetcode.cn/problems/sort-an-array/)**
  - 题目要求：找到第K大的元素。
  - 解法：快速选择算法（QuickSelect），平均时间复杂度O(n)。
  - 关键代码：仅递归处理包含目标元素的子数组。
- **[148. 排序链表](https://leetcode.cn/problems/sort-list/)**
  - 题目要求：O(n log n)时间、常数空间排序链表。
  - 解法：快速排序变种（以头节点为基准，拆分链表为左右部分递归）。
  - 注意：链表操作需谨慎处理指针，归并排序更稳定。

#### 3. 综合应用

- **[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)**
  - 题目要求：将包含0、1、2的数组原地排序。
  - 解法：三向切分快速排序（荷兰国旗问题）。
  - 关键代码：双指针划分0、1、2的区域。
- **[179. 最大数](https://leetcode.cn/problems/sort-list/)**
  - 题目要求：将非负整数数组拼接成最大数。
  - 解法：自定义排序规则（结合快速排序的Comparator）。

# 归并排序

## 一、归并排序的原理

归并排序（Merge Sort）是一种基于**分治思想**的高效排序算法，其核心流程分为**分割**和**合并**两个阶段，通过递归实现稳定排序。

1. ### **分治思想**：

   - **分割**：将数组递归地分成两个长度近似相等的子数组，直到每个子数组仅包含一个元素（此时视为有序）。
   - **合并**：将两个有序子数组合并为一个有序数组。合并时，通过双指针从左到右遍历，选择较小元素依次放入临时数组，最后将剩余元素追加到结果中。

2. **稳定性保证**：

   - 在合并过程中，若两个子数组的首元素相等，优先选择前段元素，从而保持原始顺序的稳定性。

3. ### **关键步骤**：

   ```plaintext
   1. 分割数组：mid = (left + right) / 2
   2. 递归排序左子数组和右子数组
   3. 合并两个有序子数组
   ```

## 二、C++代码实现

以下是归并排序的典型C++实现，包含递归分割与合并操作：

```cpp
#include <vector>
using namespace std;

void merge(vector<int>& nums, int left, int mid, int right) {
    vector<int> tmp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    
    // 合并两个有序子数组
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j]) tmp[k++] = nums[i++]; // 保证稳定性
        else tmp[k++] = nums[j++];
    }
    
    // 处理剩余元素
    while (i <= mid) tmp[k++] = nums[i++];
    while (j <= right) tmp[k++] = nums[j++];
    
    // 将临时数组复制回原数组
    for (int p = 0; p < tmp.size(); p++) {
        nums[left + p] = tmp[p];
    }
}

void mergeSort(vector<int>& nums, int left, int right) {
    if (left >= right) return; // 递归终止条件：子数组长度为1
    int mid = left + (right - left) / 2;
    mergeSort(nums, left, mid);      // 递归排序左半部分
    mergeSort(nums, mid + 1, right); // 递归排序右半部分
    merge(nums, left, mid, right);   // 合并操作
}

// 示例用法：
vector<int> arr = {7, 8, 6, 4, 5, 4, 3};
mergeSort(arr, 0, arr.size() - 1);
```

**代码解析**：

- **merge函数**：负责合并两个有序子数组，使用双指针遍历并比较元素。
- **mergeSort函数**：递归分割数组，直至子数组长度为1，再合并排序后的子数组。
- **稳定性**：通过`nums[i] <= nums[j]`的判断保持相等元素的顺序。

#### 1. 临时数组的创建

```cpp
vector<int> tmp(right - left + 1);
```

- **作用**：创建一个大小为 `right-left+1` 的临时数组，用于存储合并后的有序结果。此大小正好覆盖原数组中从 `left` 到 `right` 的区间。
- **必要性**：避免直接在原数组上操作导致数据覆盖问题。

#### 2. 合并两个有序子数组

```cpp
while (i <= mid && j <= right) {
    if (nums[i] <= nums[j]) tmp[k++] = nums[i++]; // 保证稳定性
    else tmp[k++] = nums[j++];
}
```

- **指针逻辑**：`i` 和 `j` 分别指向左子数组（`[left, mid]`）和右子数组（`[mid+1, right]`）的当前元素，`k` 为临时数组索引。
- **稳定性实现**：比较时使用 `<=` 而非 `<`，确保当元素相等时优先保留左子数组元素的原始顺序，这是稳定排序的关键。

#### 3. 处理剩余元素

```cpp
while (i <= mid) tmp[k++] = nums[i++];
while (j <= right) tmp[k++] = nums[j++];
```

- **必要性**：当某一子数组遍历完成后，另一子数组可能仍有剩余元素需直接复制到临时数组。例如，左子数组未遍历完时，剩余元素已有序，可直接追加到 `tmp` 末尾。

#### 4. 数据回写原数组

```cpp
for (int p = 0; p < tmp.size(); p++) {
    nums[left + p] = tmp[p];
}
```

- **意义**：将合并后的有序数据从临时数组复制回原数组的 `[left, right]` 区间，完成该区间的排序。

------

## 三、时间复杂度与空间复杂度

1. **时间复杂度**：
   - **最优/最坏/平均情况**均为 **O(n log n)**。分割过程形成递归树，深度为 log n，每层合并操作的总时间复杂度为 O(n)。
   - 公式推导：T(n) = 2T(n/2) + O(n)，通过主定理可得 O(n log n)。
2. **空间复杂度**：
   - 主要来自临时数组，为 **O(n)**。递归调用栈的空间复杂度为 O(log n)，但通常以临时数组为主。

------

## 四、LeetCode练习题

以下是涉及归并排序的典型LeetCode题目及解题思路：

### 142.排序链表（Sort List）

**题目要求**：对链表进行 O(n log n) 时间复杂度的排序，且空间复杂度为 O(1)。

**归并排序应用**：

- 分割链表：快慢指针找到中点，断开链表为前后两部分。

- 递归排序左右子链表。

- 合并两个有序链表（类似合并两个有序数组）

  **代码关键点**：快慢指针分割链表、合并操作避免额外空间。

### **23. 合并K个升序链表**（Merge k Sorted Lists）

**题目要求**：合并K个有序链表为一个有序链表。

**归并排序应用**：分治策略两两合并链表，时间复杂度 O(kn log k)，优于逐次合并的 O(k²n)。

**优化点**：递归分治或使用优先队列（最小堆）。

### **314. 计算右侧小于当前元素的个数**（Count of Smaller Numbers After Self）

**题目要求**：统计数组中每个元素右侧比它小的元素数量。

**归并排序应用**：在合并过程中统计逆序对数量，利用排序后的有序性优化计算。

### **剑指 Offer 25. 合并两个排序的链表**

**题目要求**：合并两个递增链表为一个递增链表。

**归并排序应用**：双指针遍历链表，按顺序拼接节点。

------

## 五、归并排序的优缺点

| **优点**                     | **缺点**                     |
| ---------------------------- | ---------------------------- |
| 时间复杂度稳定为 O(n log n)  | 空间复杂度 O(n)，非原地排序  |
| 稳定排序，保持相等元素顺序   | 递归实现可能导致栈溢出风险   |
| 适合链表排序（空间复杂度低） | 对小规模数据效率不如插入排序 |

------

## 六、扩展思考

1. **非递归实现**：通过迭代自底向上合并子数组，避免递归栈空间。
2. **并行优化**：分治策略天然适合多线程，可并行处理子数组排序。
3. **外部排序应用**：处理超大规模数据时，归并排序常用于磁盘文件的多路归并。

# 堆排序

## 二叉堆、大根堆、小跟堆

### 二叉堆的定义与基本性质

二叉堆是一种**完全二叉树**，具有两种基本形态： **最大堆（大根堆）** 和 **最小堆（小根堆）**。其核心性质是**堆序性**，即父节点与子节点的值满足特定的大小关系：

- **最大堆**：每个父节点的值均**大于或等于其子节点**的值，根节点为堆中最大值 。
- **最小堆**：每个父节点的值均**小于或等于其子节点**的值，根节点为堆中最小值 。

#### 物理结构与实现

二叉堆通常通过**数组**实现，原因如下：

1. **空间利用率高**：完全二叉树的结构保证数组中没有空洞，连续存储无浪费 。

2. 索引计算高效

   ：通过数组索引可直接定位父子节点：

   - 父节点索引：`parent(i) = ⌊(i-1)/2⌋`（0-based索引）。
   - 左子节点索引：`left_child(i) = 2i + 1`。
   - 右子节点索引：`right_child(i) = 2i + 2` 。

#### 关键特性

- **局部有序性**：仅保证父子节点间的有序性，兄弟节点之间的大小无关 。
- **高度平衡性**：完全二叉树的高度为`⌊log₂n⌋`，确保操作时间复杂度为`O(log n)` 。

------

### 大根堆与小根堆的对比

| **特性**     | **大根堆**                                                   | **小根堆**                                                   |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **堆顶元素** | 最大值                                                       | 最小值                                                       |
| **插入操作** | 新元素置于数组末尾，通过**上浮**调整至合适位置               | 同大根堆，但比较规则相反                                     |
| **删除操作** | 删除堆顶后，将末尾元素移至堆顶，通过**下沉**调整至合适位置   | 同大根堆，但比较规则相反                                     |
| **典型应用** | 堆排序（升序）、优先队列（需快速获取最大值）                 | 优先队列（需快速获取最小值）、Dijkstra算法                   |
| **Java实现** | `PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder())` | `PriorityQueue<Integer> minHeap = new PriorityQueue<>()`（默认小根堆） |

------

### 堆的上浮调整（Heapify-up）

#### 应用场景

当**插入新元素**或**修改某个元素的值使其优先级提升**时，需通过上浮恢复堆序性 。

#### 操作步骤

1. **插入元素**：将新元素置于数组末尾。

2. 逐层比较

   ：将新元素与其父节点比较：

   - **大根堆**：若新元素值**大于**父节点，则交换位置。
   - **小根堆**：若新元素值**小于**父节点，则交换位置。

3. **终止条件**：当元素到达根节点，或满足堆序性时停止 。

#### 示例代码（大根堆）

```python
def sift_up(heap, index):
    while index > 0:
        parent = (index - 1) // 2
        if heap[index] > heap[parent]:
            heap[index], heap[parent] = heap[parent], heap[index]
            index = parent
        else:
            break
```

**时间复杂度**：`O(log n)`，最多需比较树的高度次 。

### 堆的下沉调整（Heapify-down）

#### 应用场景

当**删除堆顶元素**或**修改某个元素的值使其优先级降低**时，需通过下沉恢复堆序性 。

#### 操作步骤

1. **删除堆顶**：将堆顶元素与末尾元素交换，并删除末尾元素。

2. 逐层比较

   ：从新堆顶开始，与其子节点比较：

   - **大根堆**：选择**较大子节点**，若其值大于当前节点则交换。
   - **小根堆**：选择**较小子节点**，若其值小于当前节点则交换。

3. **终止条件**：当元素到达叶子节点，或满足堆序性时停止 。

#### 示例代码（大根堆）

```python
def sift_down(heap, index, size):
    while 2 * index + 1 < size:
        left = 2 * index + 1
        right = 2 * index + 2
        largest = index
        if left < size and heap[left] > heap[largest]:
            largest = left
        if right < size and heap[right] > heap[largest]:
            largest = right
        if largest != index:
            heap[index], heap[largest] = heap[largest], heap[index]
            index = largest
        else:
            break
```

**时间复杂度**：`O(log n)`，最多需比较树的高度次 。

### 堆的构建方法

#### **自下而上构建（Bottom-up）**：

- 从最后一个非叶子节点开始，依次向前对每个节点执行**下沉操作**。
- 时间复杂度：`O(n)`，优于自上而下方法 。

#### **自上而下构建（Top-down）**：

- 依次插入元素，每次插入后执行**上浮操作**。
- 时间复杂度：`O(n log n)` 

## 基于堆的优先级队列代码实现

### 一、实现原理与设计要点

#### 1. 数据结构选择

- **底层容器**：使用`std::vector`动态数组存储堆元素，支持快速随机访问和自动扩容。
- **堆类型**：默认实现最大堆（优先级最高元素在堆顶），可通过自定义比较器改为最小堆。

#### 2. 关键操作

- **插入元素**：将新元素添加至数组末尾，执行 **上浮（swim）** 操作维护堆性质。
- **删除堆顶**：交换堆顶与末尾元素，删除末尾元素后执行 **下沉（sink）** 操作。
- **动态调整**：当数组容量不足时，`vector`自动扩容（时间复杂度均摊O(1)）。

#### 3. 索引计算

- 父节点：`parent(i) = (i-1)/2`
- 左子节点：`left(i) = 2*i + 1`
- 右子节点：`right(i) = 2*i + 2`

------

### 二、完整代码实现

```cpp
#include <vector>
#include <functional>
#include <stdexcept>

template<typename T, typename Compare = std::less<T>>
class PriorityQueue {
private:
    std::vector<T> heap;
    Compare comp;  // 默认less生成最大堆，若需最小堆可传入greater

    // 上浮调整
    void swim(int index) {
        while (index > 0) {
            int parent = (index - 1) / 2;
            if (comp(heap[parent], heap[index])) { // 父节点 < 当前节点时交换
                std::swap(heap[parent], heap[index]);
                index = parent;
            } else {
                break;
            }
        }
    }

    // 下沉调整
    void sink(int index) {
        int size = heap.size();
        while (true) {
            int left = 2 * index + 1;
            int right = 2 * index + 2;
            int largest = index;

            if (left < size && comp(heap[largest], heap[left])) {
                largest = left;
            }
            if (right < size && comp(heap[largest], heap[right])) {
                largest = right;
            }
            if (largest != index) {
                std::swap(heap[index], heap[largest]);
                index = largest;
            } else {
                break;
            }
        }
    }

public:
    PriorityQueue() = default;

    // 插入元素
    void push(const T& value) {
        heap.push_back(value);
        swim(heap.size() - 1);
    }

    // 删除堆顶
    void pop() {
        if (heap.empty()) {
            throw std::out_of_range("PriorityQueue is empty");
        }
        std::swap(heap[0], heap.back());
        heap.pop_back();
        if (!heap.empty()) {
            sink(0);
        }
    }

    // 获取堆顶元素
    const T& top() const {
        if (heap.empty()) {
            throw std::out_of_range("PriorityQueue is empty");
        }
        return heap[0];
    }

    bool empty() const {
        return heap.empty();
    }

    size_t size() const {
        return heap.size();
    }
};
```

------

### 三、代码解析与关键逻辑

#### 1. 模板参数说明

- `T`：元素类型（需支持比较运算符）。
- `Compare`：比较器类型，默认`std::less<T>`生成最大堆；传入`std::greater<T>`则变为最小堆。

#### 2. 上浮（Swim）操作

- **触发时机**：插入新元素后，从末尾向根节点调整。
- **比较逻辑**：若父节点优先级低于当前节点，则交换位置，直至满足堆性质。

#### 3. 下沉（Sink）操作

- **触发时机**：删除堆顶后，从根节点向叶子节点调整。
- **子节点选择**：找出优先级更高的子节点进行交换，直至满足堆性质。

#### 4. 异常处理

- `pop()`和`top()`在队列为空时抛出`std::out_of_range`异常，避免未定义行为。

------

### 四、使用示例

```cpp
#include <iostream>

int main() {
    // 最大堆示例
    PriorityQueue<int> maxHeap;
    maxHeap.push(3);
    maxHeap.push(1);
    maxHeap.push(4);
    maxHeap.push(2);

    while (!maxHeap.empty()) {
        std::cout << maxHeap.top() << " ";
        maxHeap.pop();
    }
    // 输出：4 3 2 1 

    // 最小堆示例
    PriorityQueue<int, std::greater<int>> minHeap;
    minHeap.push(3);
    minHeap.push(1);
    minHeap.push(4);
    minHeap.push(2);

    std::cout << "\n";
    while (!minHeap.empty()) {
        std::cout << minHeap.top() << " ";
        minHeap.pop();
    }
    // 输出：1 2 3 4 

    return 0;
}
```

------

### 五、时间复杂度分析

| 操作    | 时间复杂度 | 说明                |
| ------- | ---------- | ------------------- |
| push()  | O(log n)   | 上浮调整至多log n次 |
| pop()   | O(log n)   | 下沉调整至多log n次 |
| top()   | O(1)       | 直接访问堆顶元素    |
| empty() | O(1)       | 检查容器是否为空    |

## 堆排序的原理

堆排序是一种基于堆数据结构的选择排序算法，其核心思想是通过构建大顶堆（或小顶堆）并反复调整堆结构实现排序。堆是一棵完全二叉树，满足以下性质：

- **大顶堆**：任意节点值 ≥ 其子节点值，根节点为最大值。
- **小顶堆**：任意节点值 ≤ 其子节点值，根节点为最小值。

**具体步骤**：

1. **构建初始堆**：将无序数组调整为堆结构。从最后一个非叶节点（索引为 `n/2-1`）开始，自底向上调整子树为堆。
2. 交换与调整：
   - 交换堆顶元素（最大值/最小值）与当前堆末尾元素。
   - 缩小堆范围，重新调整剩余元素为堆。
   - 重复直到所有元素有序。

**关键操作**：

- **下沉（Heapify）** ：若父节点不满足堆性质，则与较大的子节点交换，递归调整被破坏的子树。
- **建堆复杂度推导**：虽然单个节点的调整时间为 `O(log n)`，但所有非叶节点的高度总和为 `O(n)`，因此总建堆时间为 `O(n)` 。

## C++代码实现

**代码要点**：

- **索引从0开始**：子节点索引公式为 `left = 2*i + 1`，`right = 2*i + 2`。
- **Heapify函数**：维护以 `i` 为根的子树为大顶堆。
- **主排序逻辑**：先建堆，再依次交换堆顶与末尾元素并调整。

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 调整以i为根的子树为大顶堆
void heapify(vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest])
        largest = right;

    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);  // 递归调整被破坏的子树
    }
}

// 堆排序主函数
void heapSort(vector<int>& arr) {
    int n = arr.size();
    // 构建初始堆（从最后一个非叶节点开始调整）
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 依次交换堆顶元素并调整堆
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);  // 调整范围为[0, i)
    }
}

// 示例
int main() {
    vector<int> arr = {12, 11, 13, 5, 6, 7};
    heapSort(arr);
    for (int num : arr)
        cout << num << " ";
    return 0;
}
```

**代码解析**：

- **Heapify函数**：通过比较父节点与子节点，确保子树满足大顶堆性质。
- **建堆循环**：从 `n/2-1` 开始倒序调整，覆盖所有非叶节点。
- **排序过程**：每次交换堆顶（最大值）到数组末尾，缩小堆范围后重新调整 。

------

## 复杂度分析

| 操作            | 时间复杂度     | 空间复杂度 | 稳定性 |
| --------------- | -------------- | ---------- | ------ |
| 构建堆          | O(n)           | O(1)       | 不稳定 |
| 调整堆（n-1次） | O(n log n)     |            |        |
| **总复杂度**    | **O(n log n)** | **O(1)**   |        |

**详细说明**：

- 时间复杂度：
  - 构建堆的复杂度为 `O(n)`（通过数学推导，非叶节点高度总和为线性）。
  - 每次调整堆的复杂度为 `O(log n)`，共 `n-1` 次调整，总时间为 `O(n log n)`。
- **空间复杂度**：仅需常数空间交换元素，属于原地排序。
- **稳定性**：因元素交换是跳跃式的（如父节点与子节点交换），可能导致相同元素的相对位置改变 。

------

## LeetCode练习题

#### 1. **合并K个升序链表（#23）**

- **题目**：将k个有序链表合并为一个有序链表。
- **堆解法**：使用最小堆维护所有链表的当前头节点，每次取出最小值插入结果链表 。
- 代码片段

#### 2. **数组中的第K个最大元素（#215）**

- **题目**：在未排序数组中找到第k大的元素。

- **堆解法**：维护一个大小为k的最小堆，遍历数组保留最大的k个元素，堆顶即为第k大 。

- 代码片段

  （C++）：

  ```cpp
  int findKthLargest(vector<int>& nums, int k) {
      priority_queue<int, vector<int>, greater<int>> pq; // 最小堆
      for (int num : nums) {
          pq.push(num);
          if (pq.size() > k) pq.pop();
      }
      return pq.top();
  }
  ```

#### 3. **前K个高频元素（#347）**

- **题目**：统计数组中出现频率前k高的元素。
- **堆解法**：先用哈希表统计频率，再用最小堆按频率筛选 。
- **代码要点**：`priority_queue` 存储 `(频率, 元素)` 对，按频率排序。

#### 4. **数据流的中位数（#295）**

- **题目**：动态维护数据流的中位数。
- **堆应用**：用最大堆和最小堆分别存储数据流的前半部分和后半部分，平衡堆大小以快速获取中位数 。

#### 5. **有序矩阵中第K小的元素（#378）**

- **题目**：在每行每列递增的矩阵中找到第k小的元素。
- **堆解法**：将矩阵元素加入最小堆，依次弹出k次 

# 快排&归并&希尔&堆排序性能比较

## 一、时间复杂度与空间复杂度

| 算法     | 最好时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度（平均/最坏） | 稳定性 |
| -------- | -------------- | -------------- | -------------- | ----------------------- | ------ |
| 快速排序 | O(nlog⁡n)       | O(nlog⁡n)       | O(n2)          | *O*(log*n*) / O(n)      | 不稳定 |
| 归并排序 | O(nlog⁡n)       | O(nlog⁡n        | O(nlog⁡n)       | O(n)                    | 稳定   |
| 希尔排序 | O(nlog⁡2n)      | *O*(*n*1.3)    | O(n2)          | O(1)                    | 不稳定 |
| 堆排序   | O(nlog⁡n)       | O(nlog⁡n)       | O(nlog⁡n)       | O(1)                    | 不稳定 |

**注**：

1. 使用Sedgewick增量序列时，希尔排序最佳时间复杂度可达O(nlog⁡2n)。
2. 希尔排序平均时间复杂度与增量序列相关，常见优化后约为O(n1.3)。

------

## 二、核心特点与性能优劣

### 快速排序

**优势**：

- 平均性能最优：内循环紧凑，常数因子小，实际运行速度通常比其他O(nlog⁡n)算法更快 。

- 原地排序：仅需少量额外空间用于递归调用栈（平均*O*(log*n*)）。

  **劣势**：

- 最坏情况退化：当输入数据已有序或逆序时，时间复杂度退化为O(n2)。可通过随机选择基准值或三数取中法优化 。

- 不稳定：分区过程可能导致相同元素相对位置变化 。

### 归并排序

**优势**：

稳定且时间稳定：所有情况下时间复杂度均为O(nlog⁡n)，适合对稳定性有要求的场景（如数据库排序） 。

适合外部排序：分治特性便于处理大规模数据（如外存排序）

**劣势**：

空间占用高：需额外O(n)空间存储辅助数组，内存受限时可能不适用 。

### 希尔排序

**优势**：

原地排序：空间复杂度为O(1)，内存效率高 。

中等规模高效：在数千至数万量级的数据中，性能优于简单插入排序

**劣势**：

时间复杂度依赖增量序列：选择不当可能导致性能接近O(n2)。

理论分析复杂：数学上尚未证明最优增量序列 。

### 堆排序

- **优势**：

- 最坏情况可靠：所有情况下时间复杂度均为O(nlog⁡n)，适合实时系统等对稳定性要求高的场景 。
- 原地排序：仅需O(1)额外空间
- **劣势**：
- 缓存不友好：跳跃式访问元素，局部性差，实际运行速度常慢于快排 。
- 不稳定：堆调整过程可能破坏相同元素的顺序 。

------

## 三、稳定性对比

- **稳定算法**：归并排序 。
- **不稳定算法**：快速排序、希尔排序、堆排序 。

------

## 四、实际应用场景

1. **快速排序**：
   - 通用场景：大多数编程语言标准库的默认排序实现（如C++ `qsort`、Java `Arrays.sort()`） 。
   - 数据随机分布时性能最佳，需结合随机化基准选择避免退化。
2. **归并排序**：
   - 外部排序：处理无法一次性加载到内存的大文件（如日志分析） 。
   - 稳定性要求高：如多关键字排序（先按日期排序，再按金额排序） 。
3. **希尔排序**：
   - 内存受限环境：嵌入式系统或移动设备的中等规模数据排序 。
   - 增量序列优化后可用于替代插入排序（如游戏开发中的实时数据处理） 。
4. **堆排序**：
   - 实时系统：需保证最坏情况下时间复杂度稳定（如操作系统进程调度） 。
   - 优先级队列：堆结构天然支持动态数据的高效插入与删除（如任务调度） 。

# 基数排序（桶排序）

## 一、基数排序的原理

基数排序（Radix Sort）是一种非比较型整数排序算法，其核心思想是将整数按位数切割成不同的数字，按**从低位到高位**的顺序逐位进行**稳定排序**，最终实现整体有序。具体原理如下：

**按位排序**
从最低有效位（个位）开始，依次对十位、百位等高位进行排序。每次排序必须使用稳定排序（如计数排序），保证相同高位值的元素保留低位排序后的顺序。

**稳定排序的必要性**
若某次排序不稳定，高位排序可能破坏低位已确定的顺序，导致最终结果错误。例如，对数字 `[329, 439]` 按十位排序时，若不稳定可能导致 `329` 和 `439` 的顺序错误。

**适用范围**
基数排序不仅适用于整数，也可扩展至字符串或特定格式的浮点数（如固定位数的科学计数法表示）。

**示例过程**（以 `[329, 457, 839, 439, 720, 355, 350]` 为例）：

- **个位排序**：`720, 350, 329, 839, 355, 457, 439`
- **十位排序**：`720, 329, 839, 350, 355, 457, 439`
- **百位排序**：`329, 350, 355, 439, 457, 720, 839`
  最终得到有序数组。

------

## 二、C++代码实现

以下是基数排序的C++实现代码，包含负数处理：

```cpp
#include <vector>
#include <algorithm>
using namespace std;

// 获取数字的第k位（0表示个位）
int getDigit(int num, int k) {
    int divisor = pow(10, k);
    return (num / divisor) % 10;
}

// 基数排序主函数
void radixSort(vector<int>& arr) {
    if (arr.empty()) return;
    // 处理负数：将所有数转为非负数
    int minVal = *min_element(arr.begin(), arr.end());
    for (int& num : arr) num -= minVal;

    // 计算最大位数
    int maxVal = *max_element(arr.begin(), arr.end());
    int maxDigits = 0;
    while (maxVal > 0) {
        maxVal /= 10;
        maxDigits++;
    }
    // 按每位进行计数排序
    for (int d = 0; d < maxDigits; d++) {
        vector<vector<int>> buckets(10);
        for (int num : arr) {
            int digit = getDigit(num, d);
            buckets[digit].push_back(num);
        }
        // 收集桶中元素
        int idx = 0;
        for (auto& bucket : buckets) {
            for (int num : bucket) {
                arr[idx++] = num;
            }
        }
    }

    // 恢复原始数值
    for (int& num : arr) num += minVal;
}
```

### **一、基数排序的整体流程**

代码实现了 **最低位优先（LSD）** 的基数排序，核心思想是逐位排序（从个位到最高位），通过多次稳定的桶排序完成整体排序。主要步骤包括：

1. **处理负数**：将所有数转为非负
2. **计算最大位数**：确定排序轮次
3. **按位排序**：每次根据当前位分配到桶中
4. **恢复数值**：排序完成后还原原始值

------

### **二、处理负数的实现**

```cpp
int minVal = *min_element(arr.begin(), arr.end());
for (int& num : arr) num -= minVal;
```

**原理**：通过减去数组最小值，将所有负数转换为非负数，避免负数干扰位提取（如-5的个位可能被误判为负数）。

**必要性**：基数排序默认处理非负整数，此操作扩展了算法对负数的支持。

------

### **三、`getDigit`函数的作用**

```cpp
int getDigit(int num, int k) {
    int divisor = pow(10, k);
    return (num / divisor) % 10;
}
```

- **功能**：提取数字`num`的第`k`位（0表示个位，1表示十位，依此类推）。

- 实现细节：

  **数学运算**：通过除法和取模操作提取指定位，例如`num=329, k=0`返回9（个位）。

  **潜在问题**：`pow(10,k)`可能因浮点精度问题导致错误，建议改用循环乘法（如`divisor *= 10`）避免精度损失。

------

### **四、计算最大位数（`maxDigits`）**

```cpp
int maxVal = *max_element(arr.begin(), arr.end());
int maxDigits = 0;
while (maxVal > 0) {
    maxVal /= 10;
    maxDigits++;
}
```

**逻辑**：通过循环除以10统计最大值位数。例如，`maxVal=329`需要3轮循环（329→32→3→0）。

**优化点**：可用对数公式`log10(maxVal)+1`直接计算，但需处理`maxVal=0`的特殊情况。

------

### **五、按位计数排序的实现**

```cpp
for (int d = 0; d < maxDigits; d++) {
    vector<vector<int>> buckets(10);
    for (int num : arr) {
        int digit = getDigit(num, d);
        buckets[digit].push_back(num);
    }
    // 收集桶中元素
    int idx = 0;
    for (auto& bucket : buckets) {
        for (int num : bucket) {
            arr[idx++] = num;
        }
    }
}
```

步骤分解：

1. **分桶**：根据当前位（`d`）的值将元素分配到0-9的桶中。
2. **收集**：按桶顺序（0→9）合并元素，保证稳定性。

**时间复杂度**：每轮遍历`O(n)`，总时间复杂度为`O(d·n)`，其中`d`为最大位数。

------

### **六、恢复原始数值**

```cpp
for (int& num : arr) num += minVal;
```

**必要性**：排序完成后需还原原始数值，恢复负数。

**实现**：将每个元素加回最小值，抵消之前的减法操作。

## 三、时间复杂度和空间复杂度

#### 1. 时间复杂度

公式：O(d⋅(n+k))

其中：

d*d*：最大位数

n*n*：元素个数

k*k*：基数（十进制时 k=10）

分析：

- 若位数 d固定（如32位整数），复杂度趋近于 O(n)。
- 若位数过大（如浮点数），性能可能退化至 O(n2)，此时不适合使用基数排序。

#### 2. 空间复杂度

- **公式**：O(n+k)，用于存储桶和临时数组。

------

## 四、LeetCode练习题

#### 1. [162. 最大间距](https://leetcode.com/problems/maximum-gap/)

- **题目要求**：在未排序数组中找到排序后相邻元素的最大差值，要求时间/空间复杂度为 O(n)*O*(*n*)。

- 基数排序解法：

  1. 使用基数排序预处理数组。
  2. 遍历有序数组，计算相邻元素差值。

- 代码关键点：

  ```cpp
  int maximumGap(vector<int>& nums) {
      if (nums.size() < 2) return 0;
      radixSort(nums);
      int maxGap = 0;
      for (int i = 1; i < nums.size(); i++) {
          maxGap = max(maxGap, nums[i] - nums[i-1]);
      }
      return maxGap;
  }
  ```

#### 2. [913. 排序数组](https://leetcode.com/problems/sort-an-array/)

**题目要求**：实现高效的数组排序。

基数排序适用性：

需处理负数（如代码中的偏移量方法）。

时间复杂度 O(n)*O*(*n*)，击败约90%的提交。