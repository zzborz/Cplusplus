# 数组

## LeetCode704

[力扣题目链接](https://leetcode.cn/problems/binary-search/)

### 解法一

```cPP
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left{0};
        int right{static_cast<int>(nums.size())-1};
        while(left<=right){
            int middle=left+(right-left)/2;
            if(nums[middle]>target){
                right=middle-1;
            }
            else if(nums[middle]<target){
                left=middle+1;
            }
            else{
                return middle;
            }
        }
        return -1;
        
    }
};
```

### 解法二

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left{0};
        int right{static_cast<int>(nums.size()) };
        while (left <right) {
            int middle = left + ((right - left) >>1);
            if (nums[middle] > target) {
                right = middle ;
            } else if (nums[middle] < target) {
                left = middle + 1;
            } else {
                return middle;
            }
        }
        return -1;
    }
};
```

第一种解法左闭右闭，都需要加1或者减去1

第二种解法左闭右开，左闭需要加1

## LeetCode35

[力扣题目链接](https://leetcode.cn/problems/search-insert-position/)

### 解法一：暴力解法

```cPP
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            if(nums[i]>=target){
                return i;
            }
        }
        return nums.size();
        
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 解法二：二分法第一种写法

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n=static_cast<int>(nums.size());
        int left=0;
        int right=n-1;
        while(left<=right){
            int middle=left+(right-left)/2;
            if (nums[middle]>target){
                right=middle;
            }
            else if(nums[middle]<target){
                left=middle+1;
            }
            else{
                return middle;
            }
        }
        return right+1;
        
        
    }
};
```

四种情况：

```cpp
 目标值在数组所有元素之前  [0, -1]
```

```cpp
 目标值等于数组中某一个元素  return middle;
```

```cpp
目标值插入数组中的位置 [left, right]，return  right + 1
```

```cpp
目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1
```

### 解法二：二分法第二种写法

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n=static_cast<int>(nums.size());
        int left=0;
        int right=n;
        while(left<right){
            int middle=left+(right-left)/2;
            if (nums[middle]>target){
                right=middle-1;
            }
            else if(nums[middle]<target){
                left=middle+1;
            }
            else{
                return middle;
            }
        }
        return right;     
    }
};
```

- 时间复杂度：O(log n)
- 空间复杂度：O(1)

