# 数组



## LeetCode704

[力扣题目链接](https://leetcode.cn/problems/binary-search/)

### 解法一

```cPP
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left{0};
        int right{static_cast<int>(nums.size())-1};
        while(left<=right){
            int middle=left+(right-left)/2;
            if(nums[middle]>target){
                right=middle-1;
            }
            else if(nums[middle]<target){
                left=middle+1;
            }
            else{
                return middle;
            }
        }
        return -1;
        
    }
};
```

### 解法二

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left{0};
        int right{static_cast<int>(nums.size()) };
        while (left <right) {
            int middle = left + ((right - left) >>1);
            if (nums[middle] > target) {
                right = middle ;
            } else if (nums[middle] < target) {
                left = middle + 1;
            } else {
                return middle;
            }
        }
        return -1;
    }
};
```

第一种解法左闭右闭，都需要加1或者减去1

第二种解法左闭右开，左闭需要加1

## LeetCode35

[力扣题目链接](https://leetcode.cn/problems/search-insert-position/)

### 解法一：暴力解法

```cPP
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            if(nums[i]>=target){
                return i;
            }
        }
        return nums.size();
        
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

### 解法二：二分法第一种写法

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n=static_cast<int>(nums.size());
        int left=0;
        int right=n-1;
        while(left<=right){
            int middle=left+(right-left)/2;
            if (nums[middle]>target){
                right=middle;
            }
            else if(nums[middle]<target){
                left=middle+1;
            }
            else{
                return middle;
            }
        }
        return right+1;
        
        
    }
};
```

四种情况：

```cpp
 目标值在数组所有元素之前  [0, -1]
```

```cpp
 目标值等于数组中某一个元素  return middle;
```

```cpp
目标值插入数组中的位置 [left, right]，return  right + 1
```

```cpp
目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1
```

### 解法二：二分法第二种写法

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n=static_cast<int>(nums.size());
        int left=0;
        int right=n;
        while(left<right){
            int middle=left+(right-left)/2;
            if (nums[middle]>target){
                right=middle-1;
            }
            else if(nums[middle]<target){
                left=middle+1;
            }
            else{
                return middle;
            }
        }
        return right;     
    }
};
```

- 时间复杂度：O(log n)
- 空间复杂度：O(1)

## LeetCode34

[力扣链接](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left=getLeftBorder(nums,target);
        int right=getRightBorder(nums,target);
        if(left==-2||right==-2) return{-1,-1};
        if(right-left>1) return {left+1,right-1};
        return{-1,-1};
        
    }
private:
    int getRightBorder(vector<int>& nums,int target){
        int left=0;
        int right=nums.size()-1;
        int rightBorder=-2;
        while(left<=right){
            int middle=left+((right-left)/2);
            if(nums[middle]>target){
                right=middle-1;
            }else{
                left=middle+1;
                rightBorder=left;
            }
        }
        return rightBorder;
    }
    int getLeftBorder(vector<int>& nums,int target){
        int left=0;
        int right=nums.size()-1;
        int leftBorder=-2;
        while(left<=right){
            int middle=left+((right-left)/2);
            if(nums[middle]>=target){
                right=middle-1;
                leftBorder=right;
            }
            else{
                left=middle+1;
            }
        }
        return leftBorder;
    }
};
```

先寻找左右边界，左边界就减少right直到成功，右边界就减少left直到成功；

对于三种情况，

第一种情况，在左边界外还是有边界外，都返回[-1.-1]

第二情况，在数组范围内，但数组内不存在target，返回[-1,-1]

第三种情况，数组范围找到左右边界，但由于它是left<=right,跳出循环的时候`rightBorder+1,leftBorder-1`，故都需要在想等的时候跳回

## LeetCode69

[力扣链接](https://leetcode.cn/problems/sqrtx/description/)

```cpp
class Solution {
public:
    int mySqrt(int x) {
        int l=0,r=x,ans=-1;
        while(l<=r){
            int mid=l+(r-l)/2;
            if((long long)mid*mid<=x){
                ans=mid;
                l=mid+1;
            }
            else{
                r=mid-1;
            }
        }
        return ans;
        
    }
};
```

采用二分法完成这个问题

## LeetCode367

[力扣链接](https://leetcode.cn/problems/valid-perfect-square/submissions/575385575/)

```c++
class Solution {
public:
    bool isPerfectSquare(int num) {
        long long l=0,r=num;
        while(l<=r){
            long long mid=l+(r-l)/2;
            if(mid*mid==num){
                return true;
            }
            else if(mid*mid<num){
                l=mid+1;
            }
            else{
                 r=mid-1;
            }
        }
        return false;
        
    }
};
```

注意要点，使用long long扩大范围，防止计算移除

如果有0，1时，需要单独考虑情况
